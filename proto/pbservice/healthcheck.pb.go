// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/pbservice/healthcheck.proto

package pbservice

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	pbcommongogo "github.com/hashicorp/consul/proto/pbcommongogo"
	github_com_hashicorp_consul_types "github.com/hashicorp/consul/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// HealthCheck represents a single check on a given node
//
// mog annotation:
//
// target=github.com/hashicorp/consul/agent/structs.HealthCheck
// output=healthcheck.gen.go
// name=Structs
type HealthCheck struct {
	Node        string                                    `protobuf:"bytes,1,opt,name=Node,proto3" json:"Node,omitempty"`
	CheckID     github_com_hashicorp_consul_types.CheckID `protobuf:"bytes,2,opt,name=CheckID,proto3,casttype=github.com/hashicorp/consul/types.CheckID" json:"CheckID,omitempty"`
	Name        string                                    `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Status      string                                    `protobuf:"bytes,4,opt,name=Status,proto3" json:"Status,omitempty"`
	Notes       string                                    `protobuf:"bytes,5,opt,name=Notes,proto3" json:"Notes,omitempty"`
	Output      string                                    `protobuf:"bytes,6,opt,name=Output,proto3" json:"Output,omitempty"`
	ServiceID   string                                    `protobuf:"bytes,7,opt,name=ServiceID,proto3" json:"ServiceID,omitempty"`
	ServiceName string                                    `protobuf:"bytes,8,opt,name=ServiceName,proto3" json:"ServiceName,omitempty"`
	ServiceTags []string                                  `protobuf:"bytes,9,rep,name=ServiceTags,proto3" json:"ServiceTags,omitempty"`
	Type        string                                    `protobuf:"bytes,12,opt,name=Type,proto3" json:"Type,omitempty"`
	Definition  HealthCheckDefinition                     `protobuf:"bytes,10,opt,name=Definition,proto3" json:"Definition"`
	// mog: func-to=RaftIndexToStructs func-from=NewRaftIndexFromStructs
	pbcommongogo.RaftIndex `protobuf:"bytes,11,opt,name=RaftIndex,proto3,embedded=RaftIndex" json:"RaftIndex"`
	// mog: func-to=EnterpriseMetaToStructs func-from=NewEnterpriseMetaFromStructs
	EnterpriseMeta pbcommongogo.EnterpriseMeta `protobuf:"bytes,13,opt,name=EnterpriseMeta,proto3" json:"EnterpriseMeta"`
	// mog: func-to=int func-from=int32
	ExposedPort int32  `protobuf:"varint,14,opt,name=ExposedPort,proto3" json:"ExposedPort,omitempty"`
	Interval    string `protobuf:"bytes,15,opt,name=Interval,proto3" json:"Interval,omitempty"`
	Timeout     string `protobuf:"bytes,16,opt,name=Timeout,proto3" json:"Timeout,omitempty"`
}

func (m *HealthCheck) Reset()         { *m = HealthCheck{} }
func (m *HealthCheck) String() string { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()    {}
func (*HealthCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a6f7448747c9fbe, []int{0}
}
func (m *HealthCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheck.Merge(m, src)
}
func (m *HealthCheck) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheck.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheck proto.InternalMessageInfo

type HeaderValue struct {
	Value []string `protobuf:"bytes,1,rep,name=Value,proto3" json:"Value,omitempty"`
}

func (m *HeaderValue) Reset()         { *m = HeaderValue{} }
func (m *HeaderValue) String() string { return proto.CompactTextString(m) }
func (*HeaderValue) ProtoMessage()    {}
func (*HeaderValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a6f7448747c9fbe, []int{1}
}
func (m *HeaderValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeaderValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeaderValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderValue.Merge(m, src)
}
func (m *HeaderValue) XXX_Size() int {
	return m.Size()
}
func (m *HeaderValue) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderValue.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderValue proto.InternalMessageInfo

// HealthCheckDefinition of a single HealthCheck.
//
// mog annotation:
//
// target=github.com/hashicorp/consul/agent/structs.HealthCheckDefinition
// output=healthcheck.gen.go
// name=Structs
type HealthCheckDefinition struct {
	HTTP          string `protobuf:"bytes,1,opt,name=HTTP,proto3" json:"HTTP,omitempty"`
	TLSServerName string `protobuf:"bytes,19,opt,name=TLSServerName,proto3" json:"TLSServerName,omitempty"`
	TLSSkipVerify bool   `protobuf:"varint,2,opt,name=TLSSkipVerify,proto3" json:"TLSSkipVerify,omitempty"`
	// mog: func-to=MapHeadersToStructs func-from=NewMapHeadersFromStructs
	Header   map[string]HeaderValue `protobuf:"bytes,3,rep,name=Header,proto3" json:"Header" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Method   string                 `protobuf:"bytes,4,opt,name=Method,proto3" json:"Method,omitempty"`
	Body     string                 `protobuf:"bytes,18,opt,name=Body,proto3" json:"Body,omitempty"`
	TCP      string                 `protobuf:"bytes,5,opt,name=TCP,proto3" json:"TCP,omitempty"`
	Interval types.Duration         `protobuf:"bytes,6,opt,name=Interval,proto3" json:"Interval"`
	// mog: func-to=uint func-from=uint32
	OutputMaxSize                  uint32         `protobuf:"varint,9,opt,name=OutputMaxSize,proto3" json:"OutputMaxSize,omitempty"`
	Timeout                        types.Duration `protobuf:"bytes,7,opt,name=Timeout,proto3" json:"Timeout"`
	DeregisterCriticalServiceAfter types.Duration `protobuf:"bytes,8,opt,name=DeregisterCriticalServiceAfter,proto3" json:"DeregisterCriticalServiceAfter"`
	ScriptArgs                     []string       `protobuf:"bytes,10,rep,name=ScriptArgs,proto3" json:"ScriptArgs,omitempty"`
	DockerContainerID              string         `protobuf:"bytes,11,opt,name=DockerContainerID,proto3" json:"DockerContainerID,omitempty"`
	Shell                          string         `protobuf:"bytes,12,opt,name=Shell,proto3" json:"Shell,omitempty"`
	H2PING                         string         `protobuf:"bytes,20,opt,name=H2PING,proto3" json:"H2PING,omitempty"`
	H2PingUseTLS                   bool           `protobuf:"varint,21,opt,name=H2PingUseTLS,proto3" json:"H2PingUseTLS,omitempty"`
	GRPC                           string         `protobuf:"bytes,13,opt,name=GRPC,proto3" json:"GRPC,omitempty"`
	GRPCUseTLS                     bool           `protobuf:"varint,14,opt,name=GRPCUseTLS,proto3" json:"GRPCUseTLS,omitempty"`
	AliasNode                      string         `protobuf:"bytes,15,opt,name=AliasNode,proto3" json:"AliasNode,omitempty"`
	AliasService                   string         `protobuf:"bytes,16,opt,name=AliasService,proto3" json:"AliasService,omitempty"`
	TTL                            types.Duration `protobuf:"bytes,17,opt,name=TTL,proto3" json:"TTL"`
}

func (m *HealthCheckDefinition) Reset()         { *m = HealthCheckDefinition{} }
func (m *HealthCheckDefinition) String() string { return proto.CompactTextString(m) }
func (*HealthCheckDefinition) ProtoMessage()    {}
func (*HealthCheckDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a6f7448747c9fbe, []int{2}
}
func (m *HealthCheckDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheckDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheckDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheckDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheckDefinition.Merge(m, src)
}
func (m *HealthCheckDefinition) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheckDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheckDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheckDefinition proto.InternalMessageInfo

// CheckType is used to create either the CheckMonitor or the CheckTTL.
// The following types are supported: Script, HTTP, TCP, Docker, TTL, GRPC,
// Alias. Script, H2PING,
// HTTP, Docker, TCP, H2PING and GRPC all require Interval. Only one of the types may
// to be provided: TTL or Script/Interval or HTTP/Interval or TCP/Interval or
// Docker/Interval or GRPC/Interval or H2PING/Interval or AliasService.
//
// mog annotation:
//
// target=github.com/hashicorp/consul/agent/structs.CheckType
// output=healthcheck.gen.go
// name=Structs
type CheckType struct {
	CheckID    github_com_hashicorp_consul_types.CheckID `protobuf:"bytes,1,opt,name=CheckID,proto3,casttype=github.com/hashicorp/consul/types.CheckID" json:"CheckID,omitempty"`
	Name       string                                    `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Status     string                                    `protobuf:"bytes,3,opt,name=Status,proto3" json:"Status,omitempty"`
	Notes      string                                    `protobuf:"bytes,4,opt,name=Notes,proto3" json:"Notes,omitempty"`
	ScriptArgs []string                                  `protobuf:"bytes,5,rep,name=ScriptArgs,proto3" json:"ScriptArgs,omitempty"`
	HTTP       string                                    `protobuf:"bytes,6,opt,name=HTTP,proto3" json:"HTTP,omitempty"`
	// mog: func-to=MapHeadersToStructs func-from=NewMapHeadersFromStructs
	Header            map[string]HeaderValue `protobuf:"bytes,20,rep,name=Header,proto3" json:"Header" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Method            string                 `protobuf:"bytes,7,opt,name=Method,proto3" json:"Method,omitempty"`
	Body              string                 `protobuf:"bytes,26,opt,name=Body,proto3" json:"Body,omitempty"`
	TCP               string                 `protobuf:"bytes,8,opt,name=TCP,proto3" json:"TCP,omitempty"`
	Interval          types.Duration         `protobuf:"bytes,9,opt,name=Interval,proto3" json:"Interval"`
	AliasNode         string                 `protobuf:"bytes,10,opt,name=AliasNode,proto3" json:"AliasNode,omitempty"`
	AliasService      string                 `protobuf:"bytes,11,opt,name=AliasService,proto3" json:"AliasService,omitempty"`
	DockerContainerID string                 `protobuf:"bytes,12,opt,name=DockerContainerID,proto3" json:"DockerContainerID,omitempty"`
	Shell             string                 `protobuf:"bytes,13,opt,name=Shell,proto3" json:"Shell,omitempty"`
	H2PING            string                 `protobuf:"bytes,28,opt,name=H2PING,proto3" json:"H2PING,omitempty"`
	H2PingUseTLS      bool                   `protobuf:"varint,30,opt,name=H2PingUseTLS,proto3" json:"H2PingUseTLS,omitempty"`
	GRPC              string                 `protobuf:"bytes,14,opt,name=GRPC,proto3" json:"GRPC,omitempty"`
	GRPCUseTLS        bool                   `protobuf:"varint,15,opt,name=GRPCUseTLS,proto3" json:"GRPCUseTLS,omitempty"`
	TLSServerName     string                 `protobuf:"bytes,27,opt,name=TLSServerName,proto3" json:"TLSServerName,omitempty"`
	TLSSkipVerify     bool                   `protobuf:"varint,16,opt,name=TLSSkipVerify,proto3" json:"TLSSkipVerify,omitempty"`
	Timeout           types.Duration         `protobuf:"bytes,17,opt,name=Timeout,proto3" json:"Timeout"`
	TTL               types.Duration         `protobuf:"bytes,18,opt,name=TTL,proto3" json:"TTL"`
	// mog: func-to=int func-from=int32
	SuccessBeforePassing int32 `protobuf:"varint,21,opt,name=SuccessBeforePassing,proto3" json:"SuccessBeforePassing,omitempty"`
	// mog: func-to=int func-from=int32
	FailuresBeforeWarning int32 `protobuf:"varint,29,opt,name=FailuresBeforeWarning,proto3" json:"FailuresBeforeWarning,omitempty"`
	// mog: func-to=int func-from=int32
	FailuresBeforeCritical int32 `protobuf:"varint,22,opt,name=FailuresBeforeCritical,proto3" json:"FailuresBeforeCritical,omitempty"`
	// Definition fields used when exposing checks through a proxy
	ProxyHTTP string `protobuf:"bytes,23,opt,name=ProxyHTTP,proto3" json:"ProxyHTTP,omitempty"`
	ProxyGRPC string `protobuf:"bytes,24,opt,name=ProxyGRPC,proto3" json:"ProxyGRPC,omitempty"`
	// DeregisterCriticalServiceAfter, if >0, will cause the associated
	// service, if any, to be deregistered if this check is critical for
	// longer than this duration.
	DeregisterCriticalServiceAfter types.Duration `protobuf:"bytes,19,opt,name=DeregisterCriticalServiceAfter,proto3" json:"DeregisterCriticalServiceAfter"`
	// mog: func-to=int func-from=int32
	OutputMaxSize int32 `protobuf:"varint,25,opt,name=OutputMaxSize,proto3" json:"OutputMaxSize,omitempty"`
}

func (m *CheckType) Reset()         { *m = CheckType{} }
func (m *CheckType) String() string { return proto.CompactTextString(m) }
func (*CheckType) ProtoMessage()    {}
func (*CheckType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a6f7448747c9fbe, []int{3}
}
func (m *CheckType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckType.Merge(m, src)
}
func (m *CheckType) XXX_Size() int {
	return m.Size()
}
func (m *CheckType) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckType.DiscardUnknown(m)
}

var xxx_messageInfo_CheckType proto.InternalMessageInfo

func init() {
	proto.RegisterType((*HealthCheck)(nil), "pbservice.HealthCheck")
	proto.RegisterType((*HeaderValue)(nil), "pbservice.HeaderValue")
	proto.RegisterType((*HealthCheckDefinition)(nil), "pbservice.HealthCheckDefinition")
	proto.RegisterMapType((map[string]HeaderValue)(nil), "pbservice.HealthCheckDefinition.HeaderEntry")
	proto.RegisterType((*CheckType)(nil), "pbservice.CheckType")
	proto.RegisterMapType((map[string]HeaderValue)(nil), "pbservice.CheckType.HeaderEntry")
}

func init() { proto.RegisterFile("proto/pbservice/healthcheck.proto", fileDescriptor_8a6f7448747c9fbe) }

var fileDescriptor_8a6f7448747c9fbe = []byte{
	// 1096 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xdd, 0x4e, 0xe3, 0xc6,
	0x17, 0x8f, 0x09, 0x49, 0xf0, 0x64, 0x61, 0x97, 0x59, 0xe0, 0x3f, 0x9b, 0xff, 0xd6, 0xa4, 0x74,
	0x2f, 0xa8, 0x4a, 0x1d, 0x95, 0x56, 0x55, 0x3f, 0xd4, 0x4a, 0x84, 0xb0, 0x90, 0x0a, 0x68, 0xea,
	0xa4, 0x5b, 0xa9, 0x77, 0xc6, 0x99, 0x38, 0x16, 0x89, 0x27, 0x1a, 0x8f, 0x11, 0xe9, 0x53, 0xf4,
	0xb2, 0x0f, 0xd0, 0x87, 0xe1, 0x92, 0xcb, 0x5e, 0xa1, 0x16, 0x9e, 0xa1, 0x37, 0xbd, 0xaa, 0xe6,
	0x8c, 0x9d, 0xd8, 0x1b, 0x2f, 0x64, 0xa5, 0xed, 0x55, 0xce, 0xf9, 0x9d, 0x8f, 0x19, 0x9f, 0x73,
	0x7e, 0x67, 0x82, 0xde, 0x1f, 0x71, 0x26, 0x58, 0x6d, 0x74, 0x16, 0x50, 0x7e, 0xe1, 0x39, 0xb4,
	0xd6, 0xa7, 0xf6, 0x40, 0xf4, 0x9d, 0x3e, 0x75, 0xce, 0x4d, 0xb0, 0x61, 0x7d, 0x62, 0xac, 0x18,
	0x2e, 0x63, 0xee, 0x80, 0xd6, 0xc0, 0x70, 0x16, 0xf6, 0x6a, 0xdd, 0x90, 0xdb, 0xc2, 0x63, 0xbe,
	0x72, 0xad, 0x6c, 0xc6, 0xd9, 0x1c, 0x36, 0x1c, 0x32, 0xdf, 0x65, 0x2e, 0xab, 0x29, 0x31, 0x72,
	0x58, 0x93, 0x90, 0x72, 0x92, 0x92, 0x42, 0xb7, 0xee, 0x16, 0x51, 0xf9, 0x08, 0xce, 0xdd, 0x97,
	0xe7, 0x62, 0x8c, 0x16, 0x4f, 0x59, 0x97, 0x12, 0xad, 0xaa, 0x6d, 0xeb, 0x16, 0xc8, 0xf8, 0x10,
	0x95, 0xc0, 0xd8, 0x6c, 0x90, 0x05, 0x09, 0xd7, 0x3f, 0xfe, 0xe7, 0x66, 0xf3, 0x43, 0xd7, 0x13,
	0xfd, 0xf0, 0xcc, 0x74, 0xd8, 0xb0, 0xd6, 0xb7, 0x83, 0xbe, 0xe7, 0x30, 0x3e, 0xaa, 0x39, 0xcc,
	0x0f, 0xc2, 0x41, 0x4d, 0x8c, 0x47, 0x34, 0x30, 0xa3, 0x20, 0x2b, 0x8e, 0x86, 0xe4, 0xf6, 0x90,
	0x92, 0x7c, 0x94, 0xdc, 0x1e, 0x52, 0xbc, 0x81, 0x8a, 0x6d, 0x61, 0x8b, 0x30, 0x20, 0x8b, 0x80,
	0x46, 0x1a, 0x5e, 0x43, 0x85, 0x53, 0x26, 0x68, 0x40, 0x0a, 0x00, 0x2b, 0x45, 0x7a, 0x7f, 0x1f,
	0x8a, 0x51, 0x28, 0x48, 0x51, 0x79, 0x2b, 0x0d, 0x3f, 0x47, 0x7a, 0x5b, 0x15, 0xaa, 0xd9, 0x20,
	0x25, 0x30, 0x4d, 0x01, 0x5c, 0x45, 0xe5, 0x48, 0x81, 0xe3, 0x97, 0xc0, 0x9e, 0x84, 0x12, 0x1e,
	0x1d, 0xdb, 0x0d, 0x88, 0x5e, 0xcd, 0x27, 0x3c, 0x24, 0x24, 0xef, 0xde, 0x19, 0x8f, 0x28, 0x79,
	0xa4, 0xee, 0x2e, 0x65, 0xfc, 0x12, 0xa1, 0x06, 0xed, 0x79, 0xbe, 0x27, 0xfb, 0x40, 0x50, 0x55,
	0xdb, 0x2e, 0xef, 0x56, 0xcd, 0x49, 0xcf, 0xcc, 0x44, 0x61, 0xa7, 0x7e, 0xf5, 0xc5, 0xab, 0x9b,
	0xcd, 0x9c, 0x95, 0x88, 0xc4, 0xdf, 0x20, 0xdd, 0xb2, 0x7b, 0xa2, 0xe9, 0x77, 0xe9, 0x25, 0x29,
	0x43, 0x9a, 0x75, 0x73, 0xda, 0x47, 0x73, 0x62, 0xac, 0x2f, 0xc9, 0xd8, 0xeb, 0x9b, 0x4d, 0xcd,
	0x9a, 0x46, 0xe0, 0x23, 0xb4, 0x72, 0xe0, 0x0b, 0xca, 0x47, 0xdc, 0x0b, 0xe8, 0x09, 0x15, 0x36,
	0x59, 0x86, 0x1c, 0x95, 0x64, 0x8e, 0xb4, 0x47, 0x74, 0x89, 0xd7, 0xe2, 0x64, 0x19, 0x0e, 0x2e,
	0x47, 0x2c, 0xa0, 0xdd, 0x16, 0xe3, 0x82, 0xac, 0x54, 0xb5, 0xed, 0x82, 0x95, 0x84, 0x70, 0x05,
	0x2d, 0x35, 0x65, 0xcc, 0x85, 0x3d, 0x20, 0x8f, 0xa1, 0x14, 0x13, 0x1d, 0x13, 0x54, 0xea, 0x78,
	0x43, 0xca, 0x42, 0x41, 0x9e, 0x80, 0x29, 0x56, 0xb7, 0x3e, 0x80, 0x21, 0xeb, 0x52, 0xfe, 0xca,
	0x1e, 0x84, 0x54, 0xf6, 0x16, 0x04, 0xa2, 0x41, 0x9d, 0x95, 0xb2, 0xf5, 0x7b, 0x09, 0xad, 0x67,
	0x56, 0x4c, 0xd6, 0xfe, 0xa8, 0xd3, 0x69, 0xc5, 0x43, 0x29, 0x65, 0xfc, 0x02, 0x2d, 0x77, 0x8e,
	0xdb, 0xb2, 0x43, 0x94, 0x43, 0x57, 0x9f, 0x82, 0x31, 0x0d, 0xc6, 0x5e, 0xe7, 0xde, 0xe8, 0x15,
	0xe5, 0x5e, 0x6f, 0x0c, 0x03, 0xbc, 0x64, 0xa5, 0x41, 0xfc, 0x1d, 0x2a, 0xaa, 0xeb, 0x91, 0x7c,
	0x35, 0xbf, 0x5d, 0xde, 0xdd, 0x79, 0xa8, 0x87, 0xa6, 0x72, 0x3f, 0xf0, 0x05, 0x1f, 0x47, 0xa5,
	0x8c, 0x32, 0xc8, 0x09, 0x3d, 0xa1, 0xa2, 0xcf, 0xba, 0xf1, 0x3c, 0x2b, 0x4d, 0x7e, 0x43, 0x9d,
	0x75, 0xc7, 0x04, 0xab, 0x6f, 0x90, 0x32, 0x7e, 0x82, 0xf2, 0x9d, 0xfd, 0x56, 0x34, 0xe1, 0x52,
	0xc4, 0x5f, 0x27, 0xca, 0x5b, 0x84, 0x26, 0x3e, 0x33, 0x15, 0xf1, 0xcd, 0x98, 0xf8, 0x66, 0x23,
	0x22, 0x7e, 0x74, 0xf0, 0xb4, 0xfe, 0x2f, 0xd0, 0xb2, 0xa2, 0xc3, 0x89, 0x7d, 0xd9, 0xf6, 0x7e,
	0xa1, 0x44, 0xaf, 0x6a, 0xdb, 0xcb, 0x56, 0x1a, 0xc4, 0x5f, 0x4e, 0xbb, 0x54, 0x9a, 0xef, 0x84,
	0xd8, 0x1f, 0xbb, 0xc8, 0x68, 0x50, 0x4e, 0x5d, 0x2f, 0x10, 0x94, 0xef, 0x73, 0x4f, 0x78, 0x8e,
	0x3d, 0x88, 0x48, 0xb2, 0xd7, 0x13, 0x94, 0x03, 0xb5, 0xe6, 0xc8, 0xf8, 0x40, 0x1a, 0x6c, 0x20,
	0xd4, 0x76, 0xb8, 0x37, 0x12, 0x7b, 0xdc, 0x0d, 0x08, 0x82, 0x29, 0x49, 0x20, 0x78, 0x07, 0xad,
	0x36, 0x98, 0x73, 0x4e, 0xf9, 0x3e, 0xf3, 0x85, 0xed, 0xf9, 0x94, 0x37, 0x1b, 0x40, 0x1c, 0xdd,
	0x9a, 0x35, 0xc8, 0x71, 0x6b, 0xf7, 0xe9, 0x60, 0x10, 0x71, 0x57, 0x29, 0xb2, 0x51, 0x47, 0xbb,
	0xad, 0xe6, 0xe9, 0x21, 0x59, 0x53, 0x8d, 0x52, 0x1a, 0xde, 0x42, 0x8f, 0x8e, 0x76, 0x5b, 0x9e,
	0xef, 0xfe, 0x18, 0xd0, 0xce, 0x71, 0x9b, 0xac, 0xc3, 0xc4, 0xa4, 0x30, 0xd9, 0xcc, 0x43, 0xab,
	0xb5, 0x0f, 0x3c, 0xd3, 0x2d, 0x90, 0xe5, 0x9d, 0xe5, 0x6f, 0x14, 0xb5, 0x02, 0x51, 0x09, 0x44,
	0xae, 0xa8, 0xbd, 0x81, 0x67, 0x07, 0xb0, 0x5e, 0x15, 0x75, 0xa6, 0x80, 0x3c, 0x15, 0x94, 0xa8,
	0x0c, 0x11, 0x81, 0x52, 0x18, 0xfe, 0x04, 0xe5, 0x3b, 0x9d, 0x63, 0xb2, 0x3a, 0x5f, 0x8d, 0xa5,
	0x6f, 0xe5, 0x87, 0x98, 0x78, 0x30, 0xaa, 0x72, 0xe0, 0xce, 0xe9, 0x38, 0xe2, 0x91, 0x14, 0xf1,
	0x0e, 0x2a, 0x5c, 0x00, 0x15, 0x17, 0x20, 0xeb, 0x46, 0x7a, 0xf2, 0x63, 0xc6, 0x5a, 0xca, 0xe9,
	0xab, 0x85, 0x2f, 0xb4, 0xad, 0xbf, 0x75, 0xa4, 0x03, 0x1d, 0x60, 0x05, 0x26, 0xde, 0x06, 0xed,
	0x9d, 0xbc, 0x0d, 0x0b, 0x99, 0x6f, 0x43, 0x3e, 0xfb, 0x6d, 0x58, 0x4c, 0xbe, 0x0d, 0xe9, 0xa1,
	0x29, 0xcc, 0x0c, 0x4d, 0xbc, 0x45, 0x8a, 0x89, 0x2d, 0xf2, 0xed, 0x84, 0xf9, 0x6b, 0xc0, 0xfc,
	0xe4, 0xf6, 0x9e, 0x7c, 0xe4, 0x5c, 0x6c, 0x2f, 0x65, 0xb2, 0xbd, 0x32, 0xcb, 0xf6, 0xa5, 0x6c,
	0xb6, 0xeb, 0x6f, 0xcb, 0xf6, 0xd4, 0x3c, 0xa1, 0x87, 0xe6, 0xa9, 0x9c, 0x31, 0x4f, 0x99, 0x2c,
	0x7a, 0xf4, 0x20, 0x8b, 0x96, 0xb3, 0x59, 0xf4, 0xfc, 0x5e, 0x16, 0x19, 0xf7, 0xb0, 0x68, 0xe5,
	0x8d, 0x2c, 0x7a, 0x3c, 0xc3, 0xa2, 0x99, 0xb5, 0xff, 0xff, 0xb9, 0xd6, 0xfe, 0x93, 0xac, 0xb5,
	0x9f, 0xd8, 0x84, 0xab, 0x6f, 0xb9, 0x09, 0x23, 0x2a, 0xe2, 0xf9, 0xa9, 0x88, 0x77, 0xd1, 0x5a,
	0x3b, 0x74, 0x1c, 0x1a, 0x04, 0x75, 0xda, 0x63, 0x9c, 0xb6, 0xec, 0x20, 0xf0, 0x7c, 0x17, 0xf6,
	0x4b, 0xc1, 0xca, 0xb4, 0xe1, 0xcf, 0xd0, 0xfa, 0x4b, 0xdb, 0x1b, 0x84, 0x9c, 0x46, 0x86, 0x9f,
	0x6c, 0xee, 0xcb, 0xa0, 0xf7, 0x20, 0x28, 0xdb, 0x88, 0x3f, 0x47, 0x1b, 0x69, 0x43, 0xbc, 0x63,
	0xc9, 0x06, 0x84, 0xbd, 0xc1, 0x2a, 0x27, 0xaa, 0xc5, 0xd9, 0xe5, 0x18, 0x58, 0xf2, 0x3f, 0x35,
	0x51, 0x13, 0x60, 0x62, 0x85, 0x96, 0x91, 0x84, 0x15, 0xfa, 0xf6, 0xf0, 0xd3, 0xf0, 0xf4, 0xdd,
	0x3c, 0x0d, 0x33, 0x8f, 0xdc, 0x33, 0xf8, 0xa6, 0x34, 0xf8, 0x1f, 0xec, 0xbd, 0xfa, 0xc9, 0xd5,
	0x5f, 0x46, 0xee, 0xea, 0xd6, 0xd0, 0xae, 0x6f, 0x0d, 0xed, 0xcf, 0x5b, 0x43, 0xfb, 0xf5, 0xce,
	0xc8, 0xfd, 0x76, 0x67, 0xe4, 0xae, 0xef, 0x8c, 0xdc, 0x1f, 0x77, 0x46, 0xee, 0xe7, 0x8f, 0xee,
	0x5b, 0x7b, 0xaf, 0xfd, 0xd9, 0x3f, 0x2b, 0x02, 0xf0, 0xe9, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x87, 0x18, 0xc2, 0xd7, 0x06, 0x0c, 0x00, 0x00,
}

func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Timeout) > 0 {
		i -= len(m.Timeout)
		copy(dAtA[i:], m.Timeout)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Timeout)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Interval) > 0 {
		i -= len(m.Interval)
		copy(dAtA[i:], m.Interval)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Interval)))
		i--
		dAtA[i] = 0x7a
	}
	if m.ExposedPort != 0 {
		i = encodeVarintHealthcheck(dAtA, i, uint64(m.ExposedPort))
		i--
		dAtA[i] = 0x70
	}
	{
		size, err := m.EnterpriseMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthcheck(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x62
	}
	{
		size, err := m.RaftIndex.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthcheck(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.Definition.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthcheck(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.ServiceTags) > 0 {
		for iNdEx := len(m.ServiceTags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ServiceTags[iNdEx])
			copy(dAtA[i:], m.ServiceTags[iNdEx])
			i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.ServiceTags[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ServiceID) > 0 {
		i -= len(m.ServiceID)
		copy(dAtA[i:], m.ServiceID)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.ServiceID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Output) > 0 {
		i -= len(m.Output)
		copy(dAtA[i:], m.Output)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Output)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CheckID) > 0 {
		i -= len(m.CheckID)
		copy(dAtA[i:], m.CheckID)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.CheckID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Value[iNdEx])
			copy(dAtA[i:], m.Value[iNdEx])
			i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Value[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HealthCheckDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheckDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.H2PingUseTLS {
		i--
		if m.H2PingUseTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.H2PING) > 0 {
		i -= len(m.H2PING)
		copy(dAtA[i:], m.H2PING)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.H2PING)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.TLSServerName) > 0 {
		i -= len(m.TLSServerName)
		copy(dAtA[i:], m.TLSServerName)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.TLSServerName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	{
		size, err := m.TTL.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthcheck(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if len(m.AliasService) > 0 {
		i -= len(m.AliasService)
		copy(dAtA[i:], m.AliasService)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.AliasService)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.AliasNode) > 0 {
		i -= len(m.AliasNode)
		copy(dAtA[i:], m.AliasNode)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.AliasNode)))
		i--
		dAtA[i] = 0x7a
	}
	if m.GRPCUseTLS {
		i--
		if m.GRPCUseTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.GRPC) > 0 {
		i -= len(m.GRPC)
		copy(dAtA[i:], m.GRPC)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.GRPC)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Shell) > 0 {
		i -= len(m.Shell)
		copy(dAtA[i:], m.Shell)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Shell)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.DockerContainerID) > 0 {
		i -= len(m.DockerContainerID)
		copy(dAtA[i:], m.DockerContainerID)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.DockerContainerID)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ScriptArgs) > 0 {
		for iNdEx := len(m.ScriptArgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ScriptArgs[iNdEx])
			copy(dAtA[i:], m.ScriptArgs[iNdEx])
			i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.ScriptArgs[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.OutputMaxSize != 0 {
		i = encodeVarintHealthcheck(dAtA, i, uint64(m.OutputMaxSize))
		i--
		dAtA[i] = 0x48
	}
	{
		size, err := m.DeregisterCriticalServiceAfter.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthcheck(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthcheck(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthcheck(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.TCP) > 0 {
		i -= len(m.TCP)
		copy(dAtA[i:], m.TCP)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.TCP)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Header) > 0 {
		for k := range m.Header {
			v := m.Header[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHealthcheck(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintHealthcheck(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintHealthcheck(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TLSSkipVerify {
		i--
		if m.TLSSkipVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.HTTP) > 0 {
		i -= len(m.HTTP)
		copy(dAtA[i:], m.HTTP)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.HTTP)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.H2PingUseTLS {
		i--
		if m.H2PingUseTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.FailuresBeforeWarning != 0 {
		i = encodeVarintHealthcheck(dAtA, i, uint64(m.FailuresBeforeWarning))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if len(m.H2PING) > 0 {
		i -= len(m.H2PING)
		copy(dAtA[i:], m.H2PING)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.H2PING)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.TLSServerName) > 0 {
		i -= len(m.TLSServerName)
		copy(dAtA[i:], m.TLSServerName)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.TLSServerName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.OutputMaxSize != 0 {
		i = encodeVarintHealthcheck(dAtA, i, uint64(m.OutputMaxSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.ProxyGRPC) > 0 {
		i -= len(m.ProxyGRPC)
		copy(dAtA[i:], m.ProxyGRPC)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.ProxyGRPC)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.ProxyHTTP) > 0 {
		i -= len(m.ProxyHTTP)
		copy(dAtA[i:], m.ProxyHTTP)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.ProxyHTTP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.FailuresBeforeCritical != 0 {
		i = encodeVarintHealthcheck(dAtA, i, uint64(m.FailuresBeforeCritical))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.SuccessBeforePassing != 0 {
		i = encodeVarintHealthcheck(dAtA, i, uint64(m.SuccessBeforePassing))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.Header) > 0 {
		for k := range m.Header {
			v := m.Header[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHealthcheck(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintHealthcheck(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintHealthcheck(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	{
		size, err := m.DeregisterCriticalServiceAfter.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthcheck(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	{
		size, err := m.TTL.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthcheck(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	{
		size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthcheck(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.TLSSkipVerify {
		i--
		if m.TLSSkipVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.GRPCUseTLS {
		i--
		if m.GRPCUseTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.GRPC) > 0 {
		i -= len(m.GRPC)
		copy(dAtA[i:], m.GRPC)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.GRPC)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Shell) > 0 {
		i -= len(m.Shell)
		copy(dAtA[i:], m.Shell)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Shell)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.DockerContainerID) > 0 {
		i -= len(m.DockerContainerID)
		copy(dAtA[i:], m.DockerContainerID)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.DockerContainerID)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.AliasService) > 0 {
		i -= len(m.AliasService)
		copy(dAtA[i:], m.AliasService)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.AliasService)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.AliasNode) > 0 {
		i -= len(m.AliasNode)
		copy(dAtA[i:], m.AliasNode)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.AliasNode)))
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthcheck(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.TCP) > 0 {
		i -= len(m.TCP)
		copy(dAtA[i:], m.TCP)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.TCP)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.HTTP) > 0 {
		i -= len(m.HTTP)
		copy(dAtA[i:], m.HTTP)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.HTTP)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ScriptArgs) > 0 {
		for iNdEx := len(m.ScriptArgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ScriptArgs[iNdEx])
			copy(dAtA[i:], m.ScriptArgs[iNdEx])
			i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.ScriptArgs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CheckID) > 0 {
		i -= len(m.CheckID)
		copy(dAtA[i:], m.CheckID)
		i = encodeVarintHealthcheck(dAtA, i, uint64(len(m.CheckID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintHealthcheck(dAtA []byte, offset int, v uint64) int {
	offset -= sovHealthcheck(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HealthCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.CheckID)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.ServiceID)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	if len(m.ServiceTags) > 0 {
		for _, s := range m.ServiceTags {
			l = len(s)
			n += 1 + l + sovHealthcheck(uint64(l))
		}
	}
	l = m.Definition.Size()
	n += 1 + l + sovHealthcheck(uint64(l))
	l = m.RaftIndex.Size()
	n += 1 + l + sovHealthcheck(uint64(l))
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = m.EnterpriseMeta.Size()
	n += 1 + l + sovHealthcheck(uint64(l))
	if m.ExposedPort != 0 {
		n += 1 + sovHealthcheck(uint64(m.ExposedPort))
	}
	l = len(m.Interval)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.Timeout)
	if l > 0 {
		n += 2 + l + sovHealthcheck(uint64(l))
	}
	return n
}

func (m *HeaderValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovHealthcheck(uint64(l))
		}
	}
	return n
}

func (m *HealthCheckDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HTTP)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	if m.TLSSkipVerify {
		n += 2
	}
	if len(m.Header) > 0 {
		for k, v := range m.Header {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovHealthcheck(uint64(len(k))) + 1 + l + sovHealthcheck(uint64(l))
			n += mapEntrySize + 1 + sovHealthcheck(uint64(mapEntrySize))
		}
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.TCP)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = m.Interval.Size()
	n += 1 + l + sovHealthcheck(uint64(l))
	l = m.Timeout.Size()
	n += 1 + l + sovHealthcheck(uint64(l))
	l = m.DeregisterCriticalServiceAfter.Size()
	n += 1 + l + sovHealthcheck(uint64(l))
	if m.OutputMaxSize != 0 {
		n += 1 + sovHealthcheck(uint64(m.OutputMaxSize))
	}
	if len(m.ScriptArgs) > 0 {
		for _, s := range m.ScriptArgs {
			l = len(s)
			n += 1 + l + sovHealthcheck(uint64(l))
		}
	}
	l = len(m.DockerContainerID)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.Shell)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.GRPC)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	if m.GRPCUseTLS {
		n += 2
	}
	l = len(m.AliasNode)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.AliasService)
	if l > 0 {
		n += 2 + l + sovHealthcheck(uint64(l))
	}
	l = m.TTL.Size()
	n += 2 + l + sovHealthcheck(uint64(l))
	l = len(m.Body)
	if l > 0 {
		n += 2 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.TLSServerName)
	if l > 0 {
		n += 2 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.H2PING)
	if l > 0 {
		n += 2 + l + sovHealthcheck(uint64(l))
	}
	if m.H2PingUseTLS {
		n += 3
	}
	return n
}

func (m *CheckType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CheckID)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	if len(m.ScriptArgs) > 0 {
		for _, s := range m.ScriptArgs {
			l = len(s)
			n += 1 + l + sovHealthcheck(uint64(l))
		}
	}
	l = len(m.HTTP)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.TCP)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = m.Interval.Size()
	n += 1 + l + sovHealthcheck(uint64(l))
	l = len(m.AliasNode)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.AliasService)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.DockerContainerID)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.Shell)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.GRPC)
	if l > 0 {
		n += 1 + l + sovHealthcheck(uint64(l))
	}
	if m.GRPCUseTLS {
		n += 2
	}
	if m.TLSSkipVerify {
		n += 3
	}
	l = m.Timeout.Size()
	n += 2 + l + sovHealthcheck(uint64(l))
	l = m.TTL.Size()
	n += 2 + l + sovHealthcheck(uint64(l))
	l = m.DeregisterCriticalServiceAfter.Size()
	n += 2 + l + sovHealthcheck(uint64(l))
	if len(m.Header) > 0 {
		for k, v := range m.Header {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovHealthcheck(uint64(len(k))) + 1 + l + sovHealthcheck(uint64(l))
			n += mapEntrySize + 2 + sovHealthcheck(uint64(mapEntrySize))
		}
	}
	if m.SuccessBeforePassing != 0 {
		n += 2 + sovHealthcheck(uint64(m.SuccessBeforePassing))
	}
	if m.FailuresBeforeCritical != 0 {
		n += 2 + sovHealthcheck(uint64(m.FailuresBeforeCritical))
	}
	l = len(m.ProxyHTTP)
	if l > 0 {
		n += 2 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.ProxyGRPC)
	if l > 0 {
		n += 2 + l + sovHealthcheck(uint64(l))
	}
	if m.OutputMaxSize != 0 {
		n += 2 + sovHealthcheck(uint64(m.OutputMaxSize))
	}
	l = len(m.Body)
	if l > 0 {
		n += 2 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.TLSServerName)
	if l > 0 {
		n += 2 + l + sovHealthcheck(uint64(l))
	}
	l = len(m.H2PING)
	if l > 0 {
		n += 2 + l + sovHealthcheck(uint64(l))
	}
	if m.FailuresBeforeWarning != 0 {
		n += 2 + sovHealthcheck(uint64(m.FailuresBeforeWarning))
	}
	if m.H2PingUseTLS {
		n += 3
	}
	return n
}

func sovHealthcheck(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHealthcheck(x uint64) (n int) {
	return sovHealthcheck(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealthcheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckID = github_com_hashicorp_consul_types.CheckID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceTags = append(m.ServiceTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterpriseMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EnterpriseMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposedPort", wireType)
			}
			m.ExposedPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExposedPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealthcheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealthcheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealthcheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealthcheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSSkipVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLSSkipVerify = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = make(map[string]HeaderValue)
			}
			var mapkey string
			mapvalue := &HeaderValue{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHealthcheck
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHealthcheck
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthHealthcheck
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthHealthcheck
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHealthcheck
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthHealthcheck
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthHealthcheck
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HeaderValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipHealthcheck(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthHealthcheck
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Header[mapkey] = *mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeregisterCriticalServiceAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeregisterCriticalServiceAfter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMaxSize", wireType)
			}
			m.OutputMaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputMaxSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptArgs = append(m.ScriptArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerContainerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerContainerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shell", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shell = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GRPC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPCUseTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GRPCUseTLS = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TTL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TLSServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H2PING", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H2PING = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H2PingUseTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.H2PingUseTLS = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHealthcheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealthcheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckID = github_com_hashicorp_consul_types.CheckID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptArgs = append(m.ScriptArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerContainerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerContainerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shell", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shell = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GRPC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPCUseTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GRPCUseTLS = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSSkipVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLSSkipVerify = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TTL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeregisterCriticalServiceAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeregisterCriticalServiceAfter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = make(map[string]HeaderValue)
			}
			var mapkey string
			mapvalue := &HeaderValue{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHealthcheck
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHealthcheck
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthHealthcheck
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthHealthcheck
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHealthcheck
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthHealthcheck
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthHealthcheck
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HeaderValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipHealthcheck(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthHealthcheck
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Header[mapkey] = *mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessBeforePassing", wireType)
			}
			m.SuccessBeforePassing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessBeforePassing |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailuresBeforeCritical", wireType)
			}
			m.FailuresBeforeCritical = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailuresBeforeCritical |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyHTTP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyHTTP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyGRPC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyGRPC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMaxSize", wireType)
			}
			m.OutputMaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputMaxSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TLSServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H2PING", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthcheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H2PING = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailuresBeforeWarning", wireType)
			}
			m.FailuresBeforeWarning = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailuresBeforeWarning |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H2PingUseTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.H2PingUseTLS = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHealthcheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHealthcheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHealthcheck(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHealthcheck
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHealthcheck
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHealthcheck
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHealthcheck
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHealthcheck
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHealthcheck        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHealthcheck          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHealthcheck = fmt.Errorf("proto: unexpected end of group")
)

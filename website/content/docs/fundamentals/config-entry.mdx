---
layout: docs
page_title: Configuration entries
description: >-
  Configuration entries define the behavior of Consul service mesh components. Learn how to use the `consul config` command to create, manage, and delete configuration entries.
---

# Configuration entries

Configuration entries can be created to provide cluster-wide defaults for
various aspects of Consul.

Outside of Kubernetes, configuration entries can be specified in HCL or JSON using either
`snake_case` or `CamelCase` for key names. On Kubernetes, configuration
entries can be managed by custom resources in YAML.

Outside of Kubernetes, every configuration entry specified in HCL or JSON has at least two fields:
`Kind` and `Name`. Those two fields are used to uniquely identify a
configuration entry. Configuration entries specified as HCL or JSON objects
use either `snake_case` or `CamelCase` for key names.

<CodeBlockConfig heading="Example config specified outside of Kubernetes">

```hcl
Kind = "<supported kind>"
Name = "<name of entry>"
```

</CodeBlockConfig>

On Kubernetes, `Kind` is set as the custom resource `kind` and `Name` is set
as `metadata.name`:

<CodeBlockConfig heading="Example config specified on Kubernetes">

```yaml
apiVersion: consul.hashicorp.com/v1alpha1
kind: <supported kind>
metadata:
  name: <name of entry>
```

</CodeBlockConfig>

## Supported Config Entries

See [Service Mesh - Config Entries](/consul/docs/fundamentals/config-entry) for the list
of supported config entries.

## Managing Configuration Entries In Kubernetes

See [Kubernetes Custom Resource Definitions](/consul/docs/fundamentals/config-entry).

## Managing Configuration Entries Outside Of Kubernetes

Configuration entries outside of Kubernetes should be managed with the Consul
[CLI](/consul/commands/config) or [API](/consul/api-docs/config). Additionally, as a
convenience for initial cluster bootstrapping, configuration entries can be
specified in all of the Consul server
[configuration files](/consul/docs/reference/agent/configuration-file#config_entries_bootstrap)

### Managing Configuration Entries with the CLI

#### Creating or Updating a Configuration Entry

The [`consul config write`](/consul/commands/config/write) command is used to
create and update configuration entries. This command will load either a JSON or
HCL file holding the configuration entry definition and then will push this
configuration to Consul.

Example HCL Configuration File:

<CodeBlockConfig filename="proxy-defaults.hcl">

```hcl
Kind = "proxy-defaults"
Name = "global"
Config {
   local_connect_timeout_ms = 1000
   handshake_timeout_ms = 10000
}
```

</CodeBlockConfig>

Then to apply this configuration, run:

```shell-session
$ consul config write proxy-defaults.hcl
```

If you need to make changes to a configuration entry, simple edit that file and
then rerun the command. This command will not output anything unless there is an
error in applying the configuration entry. The `write` command also supports a
`-cas` option to enable performing a compare-and-swap operation to prevent
overwriting other unknown modifications.

#### Reading a Configuration Entry

The [`consul config read`](/consul/commands/config/read) command is used to
read the current value of a configuration entry. The configuration entry will be
displayed in JSON form which is how its transmitted between the CLI client and
Consul's HTTP API.

Example:

```shell-session
$ consul config read -kind service-defaults -name web
{
   "Kind": "service-defaults",
   "Name": "web",
   "Protocol": "http"
}
```

#### Listing Configuration Entries

The [`consul config list`](/consul/commands/config/list) command is used to
list out all the configuration entries for a given kind.

Example:

```shell-session
$ consul config list -kind service-defaults
web
api
db
```

#### Deleting Configuration Entries

The [`consul config delete`](/consul/commands/config/delete) command is used
to delete an entry by specifying both its `kind` and `name`.

Example:

```shell-session
$ consul config delete -kind service-defaults -name web
```

This command will not output anything when the deletion is successful.

#### Configuration Entry Management with Namespaces <EnterpriseAlert inline />

Configuration entry operations support passing a namespace in
order to isolate the entry to affect only operations within that namespace. This was
added in Consul 1.7.0.

Example:

```shell-session
$ consul config write service-defaults.hcl -namespace foo
```

```shell-session
$ consul config list -kind service-defaults -namespace foo
web
api
```

### Bootstrapping From A Configuration File

Configuration entries can be bootstrapped by adding them [inline to each Consul
server's configuration file](/consul/docs/reference/agent/configuration-file#config_entries). When a
server gains leadership, it will attempt to initialize the configuration entries.
If a configuration entry does not already exist outside of the servers
configuration, then it will create it. If a configuration entry does exist, that
matches both `kind` and `name`, then the server will do nothing.

---
layout: docs
page_title: Configuration entries
description: >-
  Configuration entries define service mesh behaviors in order to secure and manage traffic. Learn about Consul’s different config entry kinds and get links to configuration reference pages.
---

# Configuration entries

This page describes configuration entries, which define service behavior for services registered to Consul.

Configuration entries can be used to configure the behavior of Consul service mesh.

The following configuration entries are supported:

- [API Gateway](/consul/docs/reference/config-entry/api-gateway) - defines the configuration for an API gateway

- [Ingress Gateway](/consul/docs/reference/config-entry/ingress-gateway) - defines the
  configuration for an ingress gateway

- [Mesh](/consul/docs/reference/config-entry/mesh) - controls
  mesh-wide configuration that applies across namespaces and federated datacenters.
  
- [Exported Services](/consul/docs/reference/config-entry/exported-services) - enables 
  Consul to export service instances to other peers or to other admin partitions local or remote to the datacenter. 

- [Proxy Defaults](/consul/docs/reference/config-entry/proxy-defaults) - controls
  proxy configuration

- [Sameness Group](/consul/docs/reference/config-entry/sameness-group) - defines partitions and cluster peers with identical services

- [Service Defaults](/consul/docs/reference/config-entry/service-defaults) - configures
  defaults for all the instances of a given service

- [Service Intentions](/consul/docs/reference/config-entry/service-intentions) - defines
  the [intentions](/consul/docs/secure-mesh/intention) for a destination service

- [Service Resolver](/consul/docs/reference/config-entry/service-resolver) - matches
  service instances with a specific Connect upstream discovery requests

- [Service Router](/consul/docs/reference/config-entry/service-router) - defines
  where to send layer 7 traffic based on the HTTP route

- [Service Splitter](/consul/docs/reference/config-entry/service-splitter) - defines
  how to divide requests for a single HTTP route based on percentages

- [Terminating Gateway](/consul/docs/reference/config-entry/terminating-gateway) - defines the
  services associated with terminating gateway

## Managing Configuration Entries

See [Agent - Config Entries](/consul/docs/fundamentals/config-entry).

## Using Configuration Entries For Service Defaults

Outside of Kubernetes, when the agent is
[configured](/consul/docs/reference/agent/configuration-file#enable_central_service_config) to enable
central service configurations, it will look for service configuration defaults
that match a registering service instance. If it finds any, the agent will merge
those defaults with the service instance configuration. This allows for things
like service protocol or proxy configuration to be defined globally and
inherited by any affected service registrations.

---
layout: docs
page_title: Custom Resource Definitions for Consul on Kubernetes
description: >-
  Consul on Kubernetes supports Consul's configuration entry kind through Custom Resource Definitions (CRDs). Learn how to configure Helm charts to enable CRDs and use kubectl to create, manage, and delete mesh components like gateways and intentions on k8s.
---

# Custom Resource Definitions (CRDs) for Consul on Kubernetes

This topic describes how to manage Consul [configuration entries](/consul/docs/fundamentals/config-entry)
with Kubernetes Custom Resources. Configuration entries provide cluster-wide defaults for the service mesh.

## Supported Configuration Entries

You can specify the following values in the `kind` field. Click on a configuration entry to view its documentation:

- [`Mesh`](/consul/docs/reference/config-entry/mesh) 
- [`ExportedServices`](/consul/docs/reference/config-entry/exported-services)
- [`PeeringAcceptor`](/consul/docs/k8s/connect/cluster-peering/tech-specs#peeringacceptor)
- [`PeeringDialer`](/consul/docs/k8s/connect/cluster-peering/tech-specs#peeringdialer)
- [`ProxyDefaults`](/consul/docs/reference/config-entry/proxy-defaults)
- [`Registration`](/consul/docs/reference/config-entry/registration)
- [`SamenessGroup`](/consul/docs/reference/config-entry/sameness-group)
- [`ServiceDefaults`](/consul/docs/reference/config-entry/service-defaults)
- [`ServiceSplitter`](/consul/docs/reference/config-entry/service-splitter)
- [`ServiceRouter`](/consul/docs/reference/config-entry/service-router)
- [`ServiceResolver`](/consul/docs/reference/config-entry/service-resolver)
- [`ServiceIntentions`](/consul/docs/reference/config-entry/service-intentions) 
- [`IngressGateway`](/consul/docs/reference/config-entry/ingress-gateway)
- [`TerminatingGateway`](/consul/docs/reference/config-entry/terminating-gateway)

## Installation

Verify that the minimum version of the helm chart (`0.28.0`) is installed:

```shell-session
$ helm search repo hashicorp/consul
NAME            	CHART VERSION	APP VERSION	DESCRIPTION
hashicorp/consul	0.28.0       	1.9.1      	Official HashiCorp Consul Chart
```

Update your helm repository cache if necessary:

```shell-session
$ helm repo update
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "hashicorp" chart repository
Update Complete. ⎈Happy Helming!⎈
```

Refer to [Install with Helm Chart](/consul/docs/deploy/server/k8s/helm) for further installation
instructions.

**Note**: Configuration entries require `connectInject` to be enabled, which is a default behavior in the official Helm Chart. If you disabled this setting, you must re-enable it to use CRDs.

## Upgrading An Existing Cluster to CRDs

If you have an existing Consul cluster running on Kubernetes you may need to perform
extra steps to migrate to CRDs. Refer to [Upgrade An Existing Cluster to CRDs](/consul/docs/k8s/crds/upgrade-to-crds) for full instructions.

## Usage

Once installed, you can use `kubectl` to create and manage Consul's configuration entries.

### Create

You can create configuration entries with `kubectl apply`.

```shell-session
$ cat <<EOF | kubectl apply --filename -
apiVersion: consul.hashicorp.com/v1alpha1
kind: ServiceDefaults
metadata:
  name: foo
spec:
  protocol: "http"
EOF

servicedefaults.consul.hashicorp.com/foo created
```

Refer to [Configuration Entries](/consul/docs/fundamentals/config-entry) for detailed schema documentation.

### Get

You can use `kubectl get [kind] [name]` to get the status of the configuration entry:

```shell-session
$ kubectl get servicedefaults foo
NAME  SYNCED
foo   True
```

The `SYNCED` status shows whether the configuration entry was successfully created
in Consul.

### Describe

You can use `kubectl describe [kind] [name]` to investigate the status of the
configuration entry. If `SYNCED` is false, the status contains the reason
why.

```shell-session
$ kubectl describe servicedefaults foo
Status:
  Conditions:
    Last Transition Time:  2020-10-09T21:15:50Z
    Status:                True
    Type:                  Synced
```

### Edit

You can use `kubectl edit [kind] [name]` to edit the configuration entry:

```shell-session
$ kubectl edit servicedefaults foo
# change protocol: http => protocol: tcp
servicedefaults.consul.hashicorp.com/foo edited
```

You can then use `kubectl get` to ensure the change was synced to Consul:

```shell-session
$ kubectl get servicedefaults foo
NAME  SYNCED
foo   True
```

### Delete

You can use `kubectl delete [kind] [name]` to delete the configuration entry:

```shell-session
$ kubectl delete servicedefaults foo
servicedefaults.consul.hashicorp.com "foo" deleted
```

You can then use `kubectl get` to ensure the configuration entry was deleted:

```shell-session
$ kubectl get servicedefaults foo
Error from server (NotFound): servicedefaults.consul.hashicorp.com "foo" not found
```

#### Delete Hanging

If running `kubectl delete` hangs without exiting, there may be
a dependent configuration entry registered with Consul that prevents the target configuration entry from being
deleted. For example, if you set the protocol of your service to `http` in `ServiceDefaults` and then
create a `ServiceSplitter`, you will not be able to delete `ServiceDefaults`.

This is because by deleting the `ServiceDefaults` config, you are setting the
protocol back to the default which is `tcp`. Because `ServiceSplitter` requires
that the service has an `http` protocol, Consul will not allow the `ServiceDefaults`
to be deleted since that would put Consul into a broken state.

In order to delete the `ServiceDefaults` config, you would need to first delete
the `ServiceSplitter`.

## Kubernetes Namespaces

### Consul CE ((#consul_oss))

Consul Community Edition (Consul CE) ignores Kubernetes namespaces and registers all services into the same
global Consul registry based on their names. For example, service `web` in Kubernetes namespace
`web-ns` and service `admin` in Kubernetes namespace `admin-ns` are registered into
Consul as `web` and `admin` with the Kubernetes source namespace ignored.

When creating custom resources to configure these services, the namespace of the
custom resource is also ignored. For example, you can create a `ServiceDefaults`
custom resource for service `web` in the Kubernetes namespace `admin-ns` even though
the `web` service is actually running in the `web-ns` namespace (although this is not recommended):

```yaml
apiVersion: consul.hashicorp.com/v1alpha1
kind: ServiceDefaults
metadata:
  name: web
  namespace: admin-ns
spec:
  protocol: http
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
  namespace: web-ns
spec: ...
```

~> **Note:** If you create two custom resources with identical `kind` and `name` values in different Kubernetes namespaces, the last one you create is not able to sync.

#### ServiceIntentions Special Case

`ServiceIntentions` are different from the other custom resources because the
name of the resource doesn't matter. For other resources, the name of the resource
determines which service it configures. For example, this resource configures
the service `web`:

<CodeBlockConfig highlight="4">

```yaml
apiVersion: consul.hashicorp.com/v1alpha1
kind: ServiceDefaults
metadata:
  name: web
spec:
  protocol: http
```

</CodeBlockConfig>

For `ServiceIntentions`, because we need to support the ability to create
wildcard intentions (e.g. `foo => * (allow)` meaning that `foo` can talk to **any** service),
and because `*` is not a valid Kubernetes resource name, we instead use the field `spec.destination.name`
to configure the destination service for the intention:

<CodeBlockConfig highlight="6-8,18-20">

```yaml
# foo => * (allow)
apiVersion: consul.hashicorp.com/v1alpha1
kind: ServiceIntentions
metadata:
  name: name-does-not-matter
spec:
  destination:
    name: '*'
  sources:
    - name: foo
      action: allow
---
# foo => web (allow)
apiVersion: consul.hashicorp.com/v1alpha1
kind: ServiceIntentions
metadata:
  name: name-does-not-matter
spec:
  destination:
    name: web
  sources:
    - name: foo
      action: allow
```

</CodeBlockConfig>

~> **Note:** If two `ServiceIntentions` resources set the same `spec.destination.name`, the
last one created is not synced.

### Consul Enterprise <EnterpriseAlert inline />

Consul Enterprise supports multiple configurations for how Kubernetes namespaces are mapped
to Consul namespaces. The Consul namespace that the custom resource is registered
into depends on the configuration being used but in general, you should create your
custom resources in the same Kubernetes namespace as the service they configure.

The details on each configuration are:

1. **Mirroring** - The Kubernetes namespace is mirrored into Consul. For example, the
   service `web` in Kubernetes namespace `web-ns` is registered as service `web`
   in the Consul namespace `web-ns`. In the same vein, a `ServiceDefaults` custom resource with
   name `web` in Kubernetes namespace `web-ns` configures that same service.

   This is configured with [`connectInject.consulNamespaces`](/consul/docs/reference/k8s/helm#v-connectinject-consulnamespaces):

   <CodeBlockConfig highlight="6-7">

   ```yaml
   global:
     name: consul
     enableConsulNamespaces: true
     image: hashicorp/consul-enterprise:<tag>-ent
   connectInject:
     consulNamespaces:
       mirroringK8S: true
   ```

   </CodeBlockConfig>

1. **Mirroring with prefix** - The Kubernetes namespace is mirrored into Consul
   with a prefix added to the Consul namespace. For example, if the prefix is `k8s-` then service `web` in Kubernetes namespace `web-ns` will be registered as service `web`
   in the Consul namespace `k8s-web-ns`. In the same vein, a `ServiceDefaults` custom resource with
   name `web` in Kubernetes namespace `web-ns` configures that same service.

   This is configured with [`connectInject.consulNamespaces`](/consul/docs/reference/k8s/helm#v-connectinject-consulnamespaces):

   <CodeBlockConfig highlight="8">

   ```yaml
   global:
     name: consul
     enableConsulNamespaces: true
     image: hashicorp/consul-enterprise:<tag>-ent
   connectInject:
     consulNamespaces:
       mirroringK8S: true
       mirroringK8SPrefix: k8s-
   ```

   </CodeBlockConfig>

1. **Single destination namespace** - The Kubernetes namespace is ignored and all services
   are registered into the same Consul namespace. For example, if the destination Consul
   namespace is `my-ns` then service `web` in Kubernetes namespace `web-ns` is registered as service `web` in Consul namespace `my-ns`.

   In this configuration, the Kubernetes namespace of the custom resource is ignored.
   For example, a `ServiceDefaults` custom resource with the name `web` in Kubernetes
   namespace `admin-ns` configures the service with name `web` even though that
   service is running in Kubernetes namespace `web-ns` because the `ServiceDefaults`
   resource ends up registered into the same Consul namespace `my-ns`.

   This is configured with [`connectInject.consulNamespaces`](/consul/docs/reference/k8s/helm#v-connectinject-consulnamespaces):

   <CodeBlockConfig highlight="7">

   ```yaml
   global:
     name: consul
     enableConsulNamespaces: true
     image: hashicorp/consul-enterprise:<tag>-ent
   connectInject:
     consulNamespaces:
       consulDestinationNamespace: 'my-ns'
   ```

   </CodeBlockConfig>

   ~> **Note:** In this configuration, if two custom resources are created in two Kubernetes namespaces with identical `name` and `kind` values, the last one created is not synced.

#### ServiceIntentions Special Case (Enterprise)

`ServiceIntentions` are different from the other custom resources because the
name of the resource does not matter. For other resources, the name of the resource
determines which service it configures. For example, this resource configures
the service `web`:

<CodeBlockConfig highlight="4">

```yaml
apiVersion: consul.hashicorp.com/v1alpha1
kind: ServiceDefaults
metadata:
  name: web
spec:
  protocol: http
```

</CodeBlockConfig>

For `ServiceIntentions`, because we need to support the ability to create
wildcard intentions (e.g. `foo => * (allow)` meaning that `foo` can talk to any service),
and because `*` is not a valid Kubernetes resource name, we instead use the field `spec.destination.name`
to configure the destination service for the intention:

<CodeBlockConfig highlight="6-8,18-20">

```yaml
# foo => * (allow)
apiVersion: consul.hashicorp.com/v1alpha1
kind: ServiceIntentions
metadata:
  name: name-does-not-matter
spec:
  destination:
    name: '*'
  sources:
    - name: foo
      action: allow
---
# foo => web (allow)
apiVersion: consul.hashicorp.com/v1alpha1
kind: ServiceIntentions
metadata:
  name: name-does-not-matter
spec:
  destination:
    name: web
  sources:
    - name: foo
      action: allow
```

</CodeBlockConfig>

In addition, we support the field `spec.destination.namespace` to configure
the destination service's Consul namespace. If `spec.destination.namespace`
is empty, then the Consul namespace used is the same as the other
config entries as outlined above.

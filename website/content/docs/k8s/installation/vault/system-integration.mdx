---
layout: docs
page_title: Vault as Secrets Backend Systems Integration Overview
description: >-
  Overview of the system integration aspects to using Vault as secrets backend for Consul on Kubernetes.
---

# Vault as the secrets backend - Systems Integration

## Requirements
### Vault Helm Config

A minimal valid installation of Vault Kubernetes must include the Agent Injector which is utilized for accessing secrets from Vault. Vault servers could be deployed
external to Vault on Kubernetes as described via the [`externalvaultaddr`](https://www.vaultproject.io/docs/platform/k8s/helm/configuration#externalvaultaddr) value in the Vault Helm Configuration 

<CodeBlockConfig filename="values.yaml">

```yaml
injector:
  enabled: "true"
```

</CodeBlockConfig>

### Vault Kubernetes Auth Method

Prior to creating Vault auth roles for the Consul servers and clients, ensure that the Vault Kubernetes auth method is enabled:

```shell-session
$ vault auth enable kubernetes
```

After enabling the Kubernetes auth method, in Vault, ensure that you have configured the Kubernetes Auth method properly as described in [Kubernetes Auth Method Configuration](https://www.vaultproject.io/docs/auth/kubernetes#configuration). The command should look similar to the following with a custom `kubernetes_host` config provided from the information provided via `kubectl cluster-info`.

```shell-session
$ vault write auth/kubernetes/config \
    token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
    kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443" \
    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
```

### Vault KV Secrets Engine - Version 2

In order to utilize Vault as a secrets backend, we must enable the [Vault KV secrets engine - Version 2](https://www.vaultproject.io/docs/secrets/kv/kv-v2).

```shell-session
$ vault secrets enable -path=consul kv-v2
```

### Vault PKI Engine

The Vault PKI Engine must be enabled in order to leverage Vault for issuing Consul Server TLS certificates. More details for configuring the PKI Engine is found in [Bootstrapping the PKI Engine](/docs/k8s/installation/vault/server-tls#bootstrapping-the-pki-engine) under the Server TLS section.

```shell-session
$ vault secrets enable pki
```


## Set Environment Variables to ensure integration consistency
### DATA_CENTER_NAME
  - **Recommended value:** value of `global.datacenter` in you helm values file.
    ```shell
    $ export DATA_CENTER_NAME=dc1
    ```
### VAULT_AUTH_METHOD_NAME 
  - **Recommended value:** a concatentation of a `kubernetes-` prefix (to denote the auth method type) with `DATA_CENTER_NAME` environment variable.
    ```shell
    export VAULT_AUTH_METHOD_NAME=kubernetes-${DATA_CENTER_NAME}
    ```
### VAULT_SERVER_HOST
  - **Recommended value:** find the external IP address of your Vault cluster. 
    - If Vault is install in a Kubernetes cluster, get the external IP or DNS name of the Vault server load balancer. 
      - On GKE or AKS, it'll be an IP:
        ```shell
        $ export VAULT_SERVER_HOST=$(kubectl get svc vault-dc1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        ```
      - On EKS, it'll be a hostname:
        ```shell
        $ export VAULT_SERVER_HOST=$(kubectl get svc vault-dc1 -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        ```
    - If Vault is not running on Kubernetes, <TO DO: HOW DO WE DESCRIBE HOW TO GET THIS?>
        ```shell
        $ export VAULT_SERVER_HOST=<external IP for vault cluster>
        ```
### VAULT_ADDR
  - **Recommended value:** Connecting to Port 8200 of 
    ```shell
    $ export VAULT_ADDR=http://${VAULT_SERVER_HOST}:8200
    ```

## Install Vault Injector in your Consul k8s cluster

```shell
$ cat <<EOF >> vault-injector.yaml
# vault-injector.yaml
server:
  enabled: false
injector:
  enabled: true
  externalVaultAddr: http://${VAULT_SERVER_HOST}:8200
  authPath: auth/${VAULT_AUTH_METHOD_NAME}
EOF
``` 

```shell
$ helm install vault-${DATA_CENTER_NAME} -f vault-injector.yaml hashicorp/vault --wait
```

## Configure the Kubernetes Auth Method in Vault for the data center

### Create a Service Account in Consul data center that will call Vault
```yaml
$ cat <<EOF >> auth-method.yaml
# auth-method.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault-${DATA_CENTER_NAME}-auth-method
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-delegator
subjects:
- kind: ServiceAccount
  name: vault-${DATA_CENTER_NAME}-auth-method
  namespace: default
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-${DATA_CENTER_NAME}-auth-method
  namespace: default
EOF
```

```shell
$ kubectl apply -f auth-method.yaml
clusterrolebinding.rbac.authorization.k8s.io/vault-${DATA_CENTER_NAME}-auth-method created
serviceaccount/vault-${DATA_CENTER_NAME}-auth-method created
```

### Enable the Auth Method
```shell
$ vault auth enable -path=kubernetes-${DATA_CENTER_NAME} kubernetes
```

### Configure Auth Method with JWT token of service account
Next, get the token and CA cert from that service account secret.

```shell
$ K8S_DC2_CA_CERT="$(kubectl get secret `kubectl get serviceaccounts vault-${DATA_CENTER_NAME}-auth-method -o jsonpath='{.secrets[0].name}'` -o jsonpath='{.data.ca\.crt}' | base64 -d)"

$ K8S_DC2_JWT_TOKEN="$(kubectl get secret `kubectl get serviceaccounts vault-${DATA_CENTER_NAME}-auth-method -o jsonpath='{.secrets[0].name}'` -o jsonpath='{.data.token}' | base64 -d)"
```

Next, get the externally reachable address of the Consul Kubernetes cluster:

```
$ export KUBE_API_URL=$(kubectl config view -o jsonpath="{.clusters[?(@.name == \"$(kubectl config current-context)\")].cluster.server}")
```

```shell
$ vault write auth/kubernetes-${DATA_CENTER_NAME}/config kubernetes_host="${KUBE_API_URL}" token_reviewer_jwt="${K8S_DC2_JWT_TOKEN}" kubernetes_ca_cert="${K8S_DC2_CA_CERT}"
```
<!-- 
### Create Vault Kuberenetes Auth Roles

We will need to create auth roles for the consul-k8s components so that they access secrets that they will need. For each auth method in Vault, we will need roles for:

* Consul server
* Consul client
* `server-acl-init` job
* Role for Consul server CA

#### Create roles for `kubernetes-dc1`

```shell
vault write auth/kubernetes-dc1/role/consul-server \
        bound_service_account_names=consul-server \
        bound_service_account_namespaces="default" \
        policies="gossip,connect-ca-dc1,consul-cert-dc1" \
        ttl=24h
vault write auth/kubernetes-dc1/role/consul-client \
        bound_service_account_names=consul-client \
        bound_service_account_namespaces="default" \
        policies="gossip" \
        ttl=24h
vault write auth/kubernetes-dc1/role/server-acl-init \
        bound_service_account_names=consul-server-acl-init \
        bound_service_account_namespaces="default" \
        policies="replication-token" \
        ttl=24h
vault write auth/kubernetes-dc1/role/consul-ca \
        bound_service_account_names="*" \
        bound_service_account_namespaces="default" \
        policies=ca-policy \
        ttl=1h
```

#### Create roles for `kubernetes-dc2`

```shell
vault write auth/kubernetes-dc2/role/consul-server \
        bound_service_account_names=consul-server \
        bound_service_account_namespaces="default" \
        policies="gossip,connect-ca-dc2,consul-cert-dc2,replication-token" \
        ttl=24h
vault write auth/kubernetes-dc2/role/consul-client \
        bound_service_account_names=consul-client \
        bound_service_account_namespaces="default" \
        policies="gossip" \
        ttl=24h
vault write auth/kubernetes-dc2/role/server-acl-init \
        bound_service_account_names=consul-server-acl-init \
        bound_service_account_namespaces="default" \
        policies="replication-token" \
        ttl=24h
vault write auth/kubernetes-dc2/role/consul-ca \
        bound_service_account_names="*" \
        bound_service_account_namespaces="default" \
        policies=ca-policy \
        ttl=1h
```

### Create gossip key secret and policy

```
$ vault secrets enable -path=consul kv-v2
$ vault kv put consul/secret/gossip key="$(consul keygen)"
$ vault policy write gossip - <<EOF
path "consul/data/secret/gossip" {
  capabilities = ["read"]
}
EOF
```

### Create replication token secret and policy

```
$ vault kv put consul/secret/replication token="$(uuidgen | tr '[:upper:]' '[:lower:]')"
$ vault policy write replication-token - <<EOF
path "consul/data/secret/replication" {
  capabilities = ["read"]
}
EOF
```

### Configure Consul server PKI

#### Root CA and policy

First, we need to enable the PKI engine and generate the root CA:

```
vault secrets enable pki
vault write pki/root/generate/internal common_name="Consul CA" ttl=87600
vault policy write ca-policy - <<EOF
path "pki/cert/ca" {
  capabilities = ["read"]
}
EOF
```

#### Server cert role and policy in DC1

```
vault write pki/roles/consul-cert-dc1 \
  allowed_domains="dc1.consul,consul-server,consul-server.default,consul-server.default.svc" \
  allow_subdomains=true \
  allow_bare_domains=true \
  allow_localhost=true \
  generate_lease=true \
  max_ttl="720h"
```

```
vault policy write consul-cert-dc1 - <<EOF
path "pki/issue/consul-cert-dc1"
{
  capabilities = ["create","update"]
}
EOF
```

#### Server cert role and policy in DC2

```
vault write pki/roles/consul-cert-dc2 \
  allowed_domains="dc2.consul,consul-server,consul-server.default,consul-server.default.svc" \
  allow_subdomains=true \
  allow_bare_domains=true \
  allow_localhost=true \
  generate_lease=true \
  max_ttl="720h"
```

```
vault policy write consul-cert-dc2 - <<EOF
path "pki/issue/consul-cert-dc2"
{
  capabilities = ["create","update"]
}
EOF
```

### Create Connect CA policy

This policy will allow Consul servers to use Vault as the CA for the service mesh. We need to create one for each datacenter, as they will have different intermediates.

```
vault policy write connect-ca-dc1 - <<EOF
path "/sys/mounts" {
  capabilities = [ "read" ]
}
path "/sys/mounts/connect_root" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/sys/mounts/dc1/connect_inter" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/connect_root/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/dc1/connect_inter/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
EOF
```

```
vault policy write connect-ca-dc2 - <<EOF
path "/sys/mounts" {
  capabilities = [ "read" ]
}
path "/sys/mounts/connect_root" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/sys/mounts/dc2/connect_inter" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/connect_root/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/dc2/connect_inter/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
EOF
```

## 3. Deploy Consul

### Consul in dc1

Create Helm values for dc1:

```yaml
# consul-dc1.yaml
global:
  datacenter: "dc1"
  name: consul
  secretsBackend:
    vault:
      enabled: true
      consulServerRole: consul-server
      consulClientRole: consul-client
      consulCARole: consul-ca
      manageSystemACLsRole: server-acl-init
      connectCA:
        address: http://vault-dc1.default:8200
        rootPKIPath: connect_root/
        intermediatePKIPath: dc1/connect_inter/
        authMethodPath: kubernetes-dc1
  tls:
    enabled: true
    enableAutoEncrypt: true
    caCert:
      secretName: "pki/cert/ca"
  federation:
    enabled: true
  acls:
    manageSystemACLs: true
    createReplicationToken: true
    replicationToken:
      secretName: consul/data/secret/replication
      secretKey: token
  gossipEncryption:
    secretName: consul/data/secret/gossip
    secretKey: key
server:
  replicas: 1
  serverCert:
    secretName: "pki/issue/consul-cert-dc1"
connectInject:
  replicas: 1
  enabled: true
controller:
  enabled: true
meshGateway:
  enabled: true
  replicas: 1
```

```
helm install consul-dc1 -f consul-dc1.yaml hashicorp/consul
```

### Consul in dc2

For the second datacenter, we will need to get the address of the mesh gateway from the **dc1** cluster:

On GKE and AKS:

```
MESH_GW_HOST=$(kubectl get svc consul-mesh-gateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
```

On EKS:
```
MESH_GW_HOST=$(kubectl get svc consul-mesh-gateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
```

```shell
cat <<EOF >> consul-dc2.yaml
global:
  datacenter: "dc2"
  name: consul
  secretsBackend:
    vault:
      enabled: true
      consulServerRole: consul-server
      consulClientRole: consul-client
      consulCARole: consul-ca
      manageSystemACLsRole: server-acl-init
      connectCA:
        address: http://${VAULT_SERVER_HOST}:8200
        rootPKIPath: connect_root/
        intermediatePKIPath: dc2/connect_inter/
        authMethodPath: kubernetes-dc2
  tls:
    enabled: true
    enableAutoEncrypt: true
    caCert:
      secretName: "pki/cert/ca"
  federation:
    enabled: true
    primaryDatacenter: dc1
    primaryGateways:
    - ${MESH_GW_HOST}:443
  acls:
    manageSystemACLs: true
    replicationToken:
      secretName: consul/data/secret/replication
      secretKey: token
  gossipEncryption:
    secretName: consul/data/secret/gossip
    secretKey: key
server:
  replicas: 1
  serverCert:
    secretName: "pki/issue/consul-cert-dc2"
connectInject:
  replicas: 1
  enabled: true
controller:
  enabled: true
meshGateway:
  enabled: true
  replicas: 1
EOF
```

Switch to **dc2** cluster and run:

```
helm install consul-dc2 -f consul-dc2.yaml hashicorp/consul
``` -->

## Next Steps

To utilize Vault as a secrets backend with Consul it is necessary to add several configuration fields to the Vault installation
which bootstrap Vault Auth roles and Policies for Consul to use. For the supported Vault secrets please see the individual secret
guides and ensure to, when combining the secrets, append the Vault Policies to your Vault Kube Auth Roles via a comma separated value (i.e. `policies=gossip-policy,consul-ca,consul-server,custom-policy`).
Ex:
```shell-session
$ vault write auth/kubernetes/role/consul-server \
    bound_service_account_names=<Consul server service account> \
    bound_service_account_namespaces=<Consul installation namespace> \
    policies=gossip-policy,consul-ca,consul-server \
    ttl=1h
```

## Troubleshooting

The Vault integration with Consul on Kubernetes makes use of the Vault Agent Injectors. Kubernetes annotations are added to the
deployments of the Consul components which cause the Vault Agent Injector to be added as an init-container that will then attach
Vault secrets to Consul's pods at startup. Additionally the Vault Agent sidecar is added to the Consul component pods which
is responsible for synchronizing and reissuing secrets at runtime.
As a result of these additional sidecar containers the typical location for logging is expanded in the Consul components.

As a general rule the best way to troubleshoot startup issues for your Consul installation when using the Vault integration
is to establish if the `vault-agent-init` container has completed or not via `kubectl logs -f <your-consul-component> -c vault-agent-int`
and checking to see if the secrets have completed rendering.
* If the secrets are not properly rendered the underlying problem will be logged in `vault-agent-init` init-container
  and generally is related to the Vault Kube Auth Role not having the correct policies for the specific secret
  e.g. `global.secretsBackend.vault.consulServerRole` not having the correct policies for TLS.
* If the secrets are rendered and the `vault-agent-init` container has completed AND the Consul component has not become `Ready`,
  this generally points to an issue with Consul being unable to utilize the Vault secret. This can occur if, for example, the Vault Role
  created for the PKI engine does not have the correct `alt_names` or otherwise is not properly configured. The best logs for this
  circumstance are the Consul container logs: `kubectl logs -f <your-consul-component> -c consul`.

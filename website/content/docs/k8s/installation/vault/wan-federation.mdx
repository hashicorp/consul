---
layout: docs
page_title: Federation Between Kubernetes Clusters with Vault as Secrets Backend
description: >-
  Federating multiple Kubernetes clusters using Vault as secrets backend.
---

# Federation Between Kubernetes Clusters with Vault as Secrets Backend

## Overview

~> This topic requires familiarity with [Mesh Gateways](/docs/connect/gateways/mesh-gateway/service-to-service-traffic-datacenters), [WAN Federation Via Mesh Gateways](/docs/connect/gateways/mesh-gateway/wan-federation-via-mesh-gateways).

This page describes how to federate multiple Kubernetes cluseres utilizing Vault as the secrets backend.  

## Differences with Federating Kubernetes Clusters when using Vault
The [Federation Between Kubernetes Clusters](/docs/k8s/installation/multi-cluster/kubernetes) page provides an overview of WAN Federation using   
Mesh Gateways with Kubernetes secrets as the secret backend.  When using Vault as the secrets backend, there will be different systems and data integration configuration that we will get into the [Usage](#usage) section of this page.  The other main difference is that when using Vault, there is no [Federation Secret](docs/k8s/installation/multi-cluster/kubernetes#federation-secret).

When federating Consul Kubernetes clusters with Kubernetes secrets, the Federation Secret is utilized in the following manner:
- `global.federation.createFederationSecret` in primary data center is set to true
- A Kubernetes secret called `<RELEASE-NAME>-federation` will be created in the primary datacenter. The federation secret's contents are outline in [Federation Secret Contents](https://www.consul.io/docs/k8s/installation/multi-cluster/kubernetes#federation-secret-contents)
- The federation secret will need to be exportedto a yaml file
- The federation secret will be imported as a Kubernetes secret into all secondary datacenters and the Consul configuration will need to reference the Federation secret and its keys for all needed secrets as outlined in the [Secondary Cluster(s)](https://www.consul.io/docs/k8s/installation/multi-cluster/kubernetes#secondary-cluster-s) section of the [Federation Between Kubernetes Clusters](/docs/k8s/installation/multi-cluster/kubernetes) page.

## Usage

The expected use case is to create WAN Federation on Kubernetes clusters. The following procedure will result in a WAN Federation with Vault as the secrets backend configuration between two clusters, dc1 and dc2. dc1 will act as the primary Consul cluster and will also contain the Vault server installation.  dc2 will be the seconday Consul cluster.

Please refer to the outline provided in the [Systems Integration](/docs/website/content/docs/k8s/installation/vault/systems-integration) and [Data Integration](/docs/website/content/docs/k8s/installation/vault/data-integration) sections of the [Vault as a Secrets Backend](/docs/website/content/docs/k8s/installation/vault) area of the Consul on Kubernetes documentation.

### Pre-existing Vault installation in dc1

In this setup, you will deploy Vault server in the dc1 Kubernetes cluster, which is also the primary Consul datacenter. You will configure your Vault Helm installation in the dc2 Kubernetes cluster to use it as an external server. This way there will be a single vault server cluster that will be used by both Consul datacenters.

For demonstration purposes, we will deploy Vault server in dev mode, although for production installations, this is not recommended. 

Change your Kubernetes current context to target dc1:

```shell-session
$ kubectl config use-context <context for dc1>
```

Now, use the above values files for you helm install:

<CodeBlockConfig filename="vault-dc1.yaml" linenumbers>

```yaml
# vault-dc1.yaml
server:
  dev:
    enabled: true
  service:
    enabled: true
    type: LoadBalancer
ui:
  enabled: true
```
</CodeBlockConfig>

```shell-session
$ helm install vault-dc1 -f vault-dc1.yaml hashicorp/vault --wait
```

Now you will have Vault running in dc1 as a pre-existing Vault installation prior to installing Consul.


### Configuring VAULT_TOKEN and VAULT_ADDR in order to run commands from your local machine

#### VAULT_TOKEN

Since you are running Vault in dev mode, VAULT_TOKEN can be set to to `root`.

```shell-session
$ export VAULT_ADDR=root
```

#### VAULT_ADDR
First, still targeting your dc1 cluster, get the external IP or DNS name of the Vault server load balancer.

<Tabs>
  <Tab heading="EKS">
  On EKS, you'll get the hostname of the Vault server load balancer:

  ```shell-session
  $ export VAULT_SERVER_HOST=$(kubectl get svc vault-dc1 -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
  ```

  </Tab>

  <Tab heading="GKE">

  On GKE, you'll get the IP of the Vault server load balancer:

  ```shell-session
  $ export VAULT_SERVER_HOST=$(kubectl get svc vault-dc1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  ```

  </Tab>

  <Tab heading="AKS">

  On AKS, you'll get the IP of the Vault server load balancer:

  ```shell-session
  $ export VAULT_SERVER_HOST=$(kubectl get svc vault-dc1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  ```

  </Tab>
</Tabs>

Then set the VAULT_ADDR environment variable:

```shell-session
$ export VAULT_ADDR=http://${VAULT_SERVER_HOST}:8200
```

## Systems Integation

### One time setup on Vault
#### Enable Vault KV Secrets Engine - Version 2
The following secrets will be stored in Vault KV secrets engine:
- Gossip encryption key ([`global.gossipEncryption`]())
- ACL Replication token ([`global.acls.replicationToken`](/docs/k8s/helm#v-global-acls-replicationtoken))

Therefore, we must enable the [Vault KV secrets engine - Version 2](https://www.vaultproject.io/docs/secrets/kv/kv-v2).

```shell-session
$ vault secrets enable -path=consul kv-v2
```

#### Enable Vault PKI Engine

The Vault PKI Engine must be enabled in order to leverage Vault for issuing Consul Server TLS certificates.

* Enable the PKI Secrets Engine:

  ```shell-session
  $ vault secrets enable pki
  ```

* Tune the engine to enable longer TTL:

  ```shell-session
  $ vault secrets tune -max-lease-ttl=87600h pki
  ```

### Setup per Consul datacenter
#### dc1 Datacenter
##### Install Vault Injector in your Consul k8s cluster
A minimal valid installation of Vault Kubernetes must include the Agent Injector which is utilized for accessing secrets from Vault. 
In dc1, we will not have to configure `injector.externalvaultaddr` value because the Vault Server is in the same dc1 cluster.

<CodeBlockConfig filename="vault-dc1.yaml" linenumbers lineNumbers highlight="8,9,10">

```yaml
# vault-dc1.yaml
server:
  dev:
    enabled: true
  service:
    enabled: true
    type: LoadBalancer
injector:
  enabled: true
  authPath: auth/kubernetes-dc1
ui:
  enabled: true
```
</CodeBlockConfig>

```shell-session
$ helm upgrade vault-dc1 -f vault-dc1.yaml hashicorp/vault --wait
```

##### Configure the Kubernetes Auth Method in Vault for the datacenter
###### Enable the Auth Method
Enable the Vault Kubernetes auth method.

```shell-session
$ vault auth enable -path=kubernetes-dc1 kubernetes
```

Since we are running Consul in the same datacenter cluster as Vault, the Vault Auth Method can use its own CA Cert and JWT to call authenticate Consul dc1 service account requests.  Therefore, we do not need to set `token_reviewer` and `kubernetes_ca_cert` on the dc1 Kubernetes Auth Method.
###### Configure Auth Method with Kubernetes API host
```shell
$ vault write auth/kubernetes-dc1/config kubernetes_host=https://kubernetes.default.svc
```
#####  Enable Vault as the secrets backend in the Consul datacenter
Finally, you will configure the Consul on Kubernetes helm chart for the dc1 datacenter to enable Vault as the Secrets backend.  However, you will not yet apply the Helm chart.  A complete chart for the dc1 datacenter is applied at the end of the Data Integration section.

<CodeBlockConfig filename="consul-dc1.yaml" linenumbers>

```yaml
global:
  secretsBackend:
    vault:
      enabled: true
```

</CodeBlockConfig>


####  dc2 Datacenter
##### Install Vault Injector in your Consul k8s cluster
A minimal valid installation of Vault Kubernetes must include the Agent Injector which is utilized for accessing secrets from Vault. 
In dc2, we will have to configure `externalvaultaddr` value point to the external address of the Vault server in dc1.

Change your Kubernetes current context to target dc2:

```shell-session
$ kubectl config use-context <context for dc2>
```

<CodeBlockConfig filename="vault-dc2.yaml" linenumbers lineNumbers highlight="6,7">

```yaml
# vault-dc2.yaml
server:
  enabled: false
injector:
  enabled: true
  externalVaultAddr: ${VAULT_ADDR}
  authPath: auth/kubernetes-dc2
```

</CodeBlockConfig>


```shell-session
$ helm install vault-dc2 -f vault-dc2.yaml hashicorp/vault --wait
```

##### Configure the Kubernetes Auth Method in Vault for the datacenter

###### Enable the Auth Method
Enable the Vault Kubernetes auth method.

```shell-session
$ vault auth enable -path=kubernetes-dc2 kubernetes
```

###### Create a service account with access to Kubenetes API in dc2
For the dc2 auth method, we first need to create a service account that allows Vault server in dc1 cluster to talk to the Kubernetes API in the dc2 cluster.

Target your dc2 cluster and apply the following:

```shell-session
$ cat <<EOF >> auth-method-serviceaccount.yaml
# auth-method.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault-dc2-auth-method
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-delegator
subjects:
- kind: ServiceAccount
  name: vault-dc2-auth-method
  namespace: default
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-dc2-auth-method
  namespace: default
EOF
```

```shell-session
$ kubectl apply -f auth-method-serviceaccount.yaml
```

Next, we will need to get the token and CA cert from that service account secret.

```shell-session
$ export K8S_DC2_CA_CERT="$(kubectl get secret `kubectl get serviceaccounts vault-dc2-auth-method -o jsonpath='{.secrets[0].name}'` -o jsonpath='{.data.ca\.crt}' | base64 -d)"
```

```shell-seession
$ export K8S_DC2_JWT_TOKEN="$(kubectl get secret `kubectl get serviceaccounts vault-dc2-auth-method -o jsonpath='{.secrets[0].name}'` -o jsonpath='{.data.token}' | base64 -d)"
```
###### Configure Auth Method with JWT token of service account

First, get the externally reachable address of the dc2 Consul Kubernetes cluster.

```shell-session
$ export KUBE_API_URL_DC2=$(kubectl config view -o jsonpath="{.clusters[?(@.name == \"$(kubectl config current-context)\")].cluster.server}")
```

```shell-session
$ vault write auth/kubernetes-dc2/config \
  kubernetes_host="${KUBE_API_URL_DC2}" \
  token_reviewer_jwt="${K8S_DC2_JWT_TOKEN}" \
  kubernetes_ca_cert="${K8S_DC2_CA_CERT}"
```

##### Enable Vault as the secrets backend in the Consul datacenter
Finally, you will configure the Consul on Kubernetes helm chart for the dc2 datacenter to enable Vault as the Secrets backend.  However, you will not yet apply the Helm chart.  A complete chart for the dc2 datacenter is applied at the end of the Data Integration section.

<CodeBlockConfig filename="values-dc2.yaml" linenumbers>

```yaml
global:
  secretsBackend:
    vault:
      enabled: true
```

</CodeBlockConfig> 

## Data Integration
### Overview
To use Vault as the Service Mesh Certificate Provider on Kubernetes, please follow the process guidelines in the [Data Integration](/docs/k8s/installation/vault/data-integration) section:

- One time setup in Vault
  1. Store the secrets in Vault.
  1. Create a Vault policy that authorizes the desired level of access to the secrets.
- Setup per Consul datacenter
  1. Create Vault Kubernetes auth roles that link the policy to each Consul on Kubernetes service account that requires access.
  1. Configure the Vault Kubernetes auth role in the Consul on Kubernetes helm chart.

### One time setup in Vault
#### Store the secrets in Vault
##### Gossip encryption key secret

```shell-session
$ vault kv put consul/secret/gossip key="$(consul keygen)"
```
##### Replication token secret

```shell-session
$ vault kv put consul/secret/replication token="$(uuidgen | tr '[:upper:]' '[:lower:]')"
```  
##### Root CA certificate
```shell-session
$ vault write pki/root/generate/internal common_name="Consul CA" ttl=87600h
``` 
#### Create Vault policies that authorize the desired level of access to the secrets
##### Gossip encryption key policy

```shell-session
$ vault policy write gossip - <<EOF
path "consul/data/secret/gossip" {
  capabilities = ["read"]
}
EOF
```

##### Replication token policy

```shell-session
$ vault policy write replication-token - <<EOF
path "consul/data/secret/replication" {
  capabilities = ["read"]
}
EOF
```

##### CA policy

```shell-session
$ vault policy write ca-policy - <<EOF
path "pki/cert/ca" {
  capabilities = ["read"]
}
EOF
```

### Setup per Consul datacenter
#### dc1 datacenter

Change your Kubernetes current context to target dc1:
```shell-session
$ kubectl config use-context <context for dc1>
```

##### Create Server TLS and Service Mesh Cert Policies
##### Server TLS Cert policy

```shell-session
$ vault policy write consul-cert-dc1 - <<EOF
path "pki/issue/consul-cert-dc1"
{
  capabilities = ["create","update"]
}
EOF
```

##### Service Mesh Cert policy

```shell-session
$ vault policy write connect-ca-dc1 - <<EOF
path "/sys/mounts" {
  capabilities = [ "read" ]
}
path "/sys/mounts/connect_root" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/sys/mounts/dc1/connect_inter" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/connect_root/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/dc1/connect_inter/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
EOF
```

##### Create Vault Kubernetes auth roles that link the policy to each Consul on Kubernetes service account that requires access
We will need to create auth roles for the consul-k8s components so that they access secrets that they will need. For each auth method in Vault, we will need roles for:

* Consul server
* Consul client
* `server-acl-init` job
* Role for Consul server CA

```shell-session
$ vault write auth/kubernetes-dc1/role/consul-server \
        bound_service_account_names=consul-server \
        bound_service_account_namespaces="default" \
        policies="gossip,connect-ca-dc1,consul-cert-dc1" \
        ttl=24h
```

```shell-session
$ vault write auth/kubernetes-dc1/role/consul-client \
        bound_service_account_names=consul-client \
        bound_service_account_namespaces="default" \
        policies="gossip" \
        ttl=24h
```

```shell-session
$ vault write auth/kubernetes-dc1/role/server-acl-init \
        bound_service_account_names=consul-server-acl-init \
        bound_service_account_namespaces="default" \
        policies="replication-token" \
        ttl=24h
```

```shell-session
$ vault write auth/kubernetes-dc1/role/consul-ca \
        bound_service_account_names="*" \
        bound_service_account_namespaces="default" \
        policies=ca-policy \
        ttl=1h
```

##### Server TLS Cert role

```shell-session
$ vault write pki/roles/consul-cert-dc1 \
  allowed_domains="dc1.consul,consul-server,consul-server.default,consul-server.default.svc" \
  allow_subdomains=true \
  allow_bare_domains=true \
  allow_localhost=true \
  generate_lease=true \
  max_ttl="720h"
```

##### Configure the Vault Kubernetes auth role in the Consul on Kubernetes helm chart
Now you can configure and install Consul in dc1 datacenter.

<CodeBlockConfig filename="consul-dc1.yaml" linenumbers>

```yaml
# consul-dc1.yaml
global:
  datacenter: "dc1"
  name: consul
  secretsBackend:
    vault:
      enabled: true
      consulServerRole: consul-server
      consulClientRole: consul-client
      consulCARole: consul-ca
      manageSystemACLsRole: server-acl-init
      connectCA:
        address: http://vault-dc1.default:8200
        rootPKIPath: connect_root/
        intermediatePKIPath: dc1/connect_inter/
        authMethodPath: kubernetes-dc1
  tls:
    enabled: true
    enableAutoEncrypt: true
    caCert:
      secretName: "pki/cert/ca"
  federation:
    enabled: true
  acls:
    manageSystemACLs: true
    createReplicationToken: true
    replicationToken:
      secretName: consul/data/secret/replication
      secretKey: token
  gossipEncryption:
    secretName: consul/data/secret/gossip
    secretKey: key
server:
  replicas: 1
  serverCert:
    secretName: "pki/issue/consul-cert-dc1"
connectInject:
  replicas: 1
  enabled: true
controller:
  enabled: true
meshGateway:
  enabled: true
  replicas: 1
```

</CodeBlockConfig>

```shell-session
$ helm install consul-dc1 -f consul-dc1.yaml hashicorp/consul
```

#### dc2 datacenter
##### Create Server TLS and Service Mesh Cert Policies
##### Server TLS Cert policy

```shell-session
$ vault policy write consul-cert-dc2 - <<EOF
path "pki/issue/consul-cert-dc2"
{
  capabilities = ["create","update"]
}
EOF
```

##### Service Mesh Cert policy

```shell-session
$ vault policy write connect-ca-dc2 - <<EOF
path "/sys/mounts" {
  capabilities = [ "read" ]
}
path "/sys/mounts/connect_root" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/sys/mounts/dc2/connect_inter" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/connect_root/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/dc2/connect_inter/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
EOF
```

##### Create Vault Kubernetes auth roles that link the policy to each Consul on Kubernetes service account that requires access
We will need to create auth roles for the consul-k8s components so that they access secrets that they will need. For each auth method in Vault, we will need roles for:

* Consul server
* Consul client
* `server-acl-init` job
* Role for Consul server CA

```shell-session
$ vault write auth/kubernetes-dc2/role/consul-server \
        bound_service_account_names=consul-server \
        bound_service_account_namespaces="default" \
        policies="gossip,connect-ca-dc2,consul-cert-dc2,replication-token" \
        ttl=24h
```

```shell-session
$ vault write auth/kubernetes-dc2/role/consul-client \
        bound_service_account_names=consul-client \
        bound_service_account_namespaces="default" \
        policies="gossip" \
        ttl=24h
```

```shell-session
$ vault write auth/kubernetes-dc2/role/server-acl-init \
        bound_service_account_names=consul-server-acl-init \
        bound_service_account_namespaces="default" \
        policies="replication-token" \
        ttl=24h
```

```shell-session
$ vault write auth/kubernetes-dc2/role/consul-ca \
        bound_service_account_names="*" \
        bound_service_account_namespaces="default" \
        policies=ca-policy \
        ttl=1h
```

##### Server TLS Cert role

```shell-session
$ vault write pki/roles/consul-cert-dc2 \
  allowed_domains="dc2.consul,consul-server,consul-server.default,consul-server.default.svc" \
  allow_subdomains=true \
  allow_bare_domains=true \
  allow_localhost=true \
  generate_lease=true \
  max_ttl="720h"
```

##### Configure the Vault Kubernetes auth role in the Consul on Kubernetes helm chart
Now you can configure and install Consul in dc2 datacenter. 
##### Set the Mesh Gateway address from DC1.
For dc2 datacenter, we will need to get the address of the mesh gateway from the **dc1** cluster.  Change your Kubernetes current context to target dc1 and set the `MESH_GW_HOST` environment variable that you will use in the Consul Helm chart for dc2 datacenter.

```shell-session
$ kubectl config use-context <context for dc1>
```

Now, get the mesh gateway address:

<Tabs>
  <Tab heading="EKS">

  ```shell-session
  export MESH_GW_HOST=$(kubectl get svc consul-mesh-gateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
  ```

  </Tab>

  <Tab heading="GKE">

  ```shell-session
  export MESH_GW_HOST=$(kubectl get svc consul-mesh-gateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  ```

  </Tab>

  <Tab heading="AKS">

  ```shell-session
  export MESH_GW_HOST=$(kubectl get svc consul-mesh-gateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  ```

  </Tab>
</Tabs>

##### Set the Mesh Gateway address from DC1.
-> Note To configure Vault as the Connect CA in secondary datacenters, you need to make sure that the Root CA path is the same,
but the intermediate is different for each datacenter. In the `connectCA` Helm configuration for a secondary datacenter,
you can specify a `intermediatePKIPath` that is, for example, prefixed with the datacenter
for which this configuration is intended (e.g. `dc2/connect-intermediate`).

<CodeBlockConfig filename="consul-dc2.yaml" linenumbers>

```yaml
# consul-dc2.yaml
global:
  datacenter: "dc2"
  name: consul
  secretsBackend:
    vault:
      enabled: true
      consulServerRole: consul-server
      consulClientRole: consul-client
      consulCARole: consul-ca
      manageSystemACLsRole: server-acl-init
      connectCA:
        address: ${VAULT_ADDR}
        rootPKIPath: connect_root/
        intermediatePKIPath: dc2/connect_inter/
        authMethodPath: kubernetes-dc2
  tls:
    enabled: true
    enableAutoEncrypt: true
    caCert:
      secretName: "pki/cert/ca"
  federation:
    enabled: true
    primaryDatacenter: dc1
    k8sAuthMethodHost: ${KUBE_API_URL_DC2}
    primaryGateways:
    - ${MESH_GW_HOST}:443
  acls:
    manageSystemACLs: true
    replicationToken:
      secretName: consul/data/secret/replication
      secretKey: token
  gossipEncryption:
    secretName: consul/data/secret/gossip
    secretKey: key
server:
  replicas: 1
  serverCert:
    secretName: "pki/issue/consul-cert-dc2"
connectInject:
  replicas: 1
  enabled: true
controller:
  enabled: true
meshGateway:
  enabled: true
  replicas: 1
```

</CodeBlockConfig>

Change your Kubernetes current context to target dc2:

```shell-session
$ kubectl config use-context <context for dc2>
```


Now, use the above values files for you helm install:

```shell-session
$ helm install consul-dc2 -f consul-dc2.yaml hashicorp/consul
```

## Next steps
For further detail on specific Consul secrets that are available to be stored in Vault, please checkout the detailed information in the [Data Integration](/docs/website/content/docs/k8s/installation/vault/data-integration) section of the [Vault as a Secrets Backend](/docs/website/content/docs/k8s/installation/vault) area of the Consul on Kubernetes documentation.

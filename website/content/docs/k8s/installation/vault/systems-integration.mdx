---
layout: docs
page_title: Vault as Secrets Backend Systems Integration Overview
description: >-
  Overview of the system integration aspects to using Vault as secrets backend for Consul on Kubernetes.
---

# Vault as the secrets backend - Systems Integration

## Set Environment Variables to ensure integration consistency
### DATA_CENTER_NAME
  - **Recommended value:** value of `global.datacenter` in you helm values file.
    ```shell
    $ export DATA_CENTER_NAME=dc1
    ```
### VAULT_AUTH_METHOD_NAME 
  - **Recommended value:** a concatentation of a `kubernetes-` prefix (to denote the auth method type) with `DATA_CENTER_NAME` environment variable.
    ```shell
    export VAULT_AUTH_METHOD_NAME=kubernetes-${DATA_CENTER_NAME}
    ```
### VAULT_SERVER_HOST
  - **Recommended value:** find the external IP address of your Vault cluster. 
    - If Vault is install in a Kubernetes cluster, get the external IP or DNS name of the Vault server load balancer. 
      - On GKE or AKS, it'll be an IP:
        ```shell
        $ export VAULT_SERVER_HOST=$(kubectl get svc vault-dc1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        ```
      - On EKS, it'll be a hostname:
        ```shell
        $ export VAULT_SERVER_HOST=$(kubectl get svc vault-dc1 -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        ```
    - If Vault is not running on Kubernetes, <TO DO: HOW DO WE DESCRIBE HOW TO GET THIS?>
        ```shell
        $ export VAULT_SERVER_HOST=<external IP for vault cluster>
        ```
### VAULT_ADDR
  - **Recommended value:** Connecting to Port 8200 of 
    ```shell
    $ export VAULT_ADDR=http://${VAULT_SERVER_HOST}:8200
    ```

## Install Vault Injector in your Consul k8s cluster

```shell
$ cat <<EOF >> vault-injector.yaml
# vault-injector.yaml
server:
  enabled: false
injector:
  enabled: true
  externalVaultAddr: http://${VAULT_SERVER_HOST}:8200
  authPath: auth/${VAULT_AUTH_METHOD_NAME}
EOF
``` 

```shell
$ helm install vault-${DATA_CENTER_NAME} -f vault-injector.yaml hashicorp/vault --wait
```

## Configure the Kubernetes Auth Method in Vault for the data center

### Create a Service Account in Consul data center that will call Vault
```yaml
$ cat <<EOF >> auth-method.yaml
# auth-method.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault-${DATA_CENTER_NAME}-auth-method
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-delegator
subjects:
- kind: ServiceAccount
  name: vault-${DATA_CENTER_NAME}-auth-method
  namespace: default
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-${DATA_CENTER_NAME}-auth-method
  namespace: default
EOF
```

```shell
$ kubectl apply -f auth-method.yaml
clusterrolebinding.rbac.authorization.k8s.io/vault-${DATA_CENTER_NAME}-auth-method created
serviceaccount/vault-${DATA_CENTER_NAME}-auth-method created
```

### Enable the Auth Method
```shell
$ vault auth enable -path=kubernetes-${DATA_CENTER_NAME} kubernetes
```

### Configure Auth Method with JWT token of service account
Next, get the token and CA cert from that service account secret.

```shell
$ K8S_DC2_CA_CERT="$(kubectl get secret `kubectl get serviceaccounts vault-${DATA_CENTER_NAME}-auth-method -o jsonpath='{.secrets[0].name}'` -o jsonpath='{.data.ca\.crt}' | base64 -d)"

$ K8S_DC2_JWT_TOKEN="$(kubectl get secret `kubectl get serviceaccounts vault-${DATA_CENTER_NAME}-auth-method -o jsonpath='{.secrets[0].name}'` -o jsonpath='{.data.token}' | base64 -d)"
```

Next, get the externally reachable address of the Consul Kubernetes cluster:

```
$ export KUBE_API_URL=$(kubectl config view -o jsonpath="{.clusters[?(@.name == \"$(kubectl config current-context)\")].cluster.server}")
```

```shell
$ vault write auth/kubernetes-${DATA_CENTER_NAME}/config kubernetes_host="${KUBE_API_URL}" token_reviewer_jwt="${K8S_DC2_JWT_TOKEN}" kubernetes_ca_cert="${K8S_DC2_CA_CERT}"
```
<!-- 
### Create Vault Kuberenetes Auth Roles

We will need to create auth roles for the consul-k8s components so that they access secrets that they will need. For each auth method in Vault, we will need roles for:

* Consul server
* Consul client
* `server-acl-init` job
* Role for Consul server CA

#### Create roles for `kubernetes-dc1`

```shell
vault write auth/kubernetes-dc1/role/consul-server \
        bound_service_account_names=consul-server \
        bound_service_account_namespaces="default" \
        policies="gossip,connect-ca-dc1,consul-cert-dc1" \
        ttl=24h
vault write auth/kubernetes-dc1/role/consul-client \
        bound_service_account_names=consul-client \
        bound_service_account_namespaces="default" \
        policies="gossip" \
        ttl=24h
vault write auth/kubernetes-dc1/role/server-acl-init \
        bound_service_account_names=consul-server-acl-init \
        bound_service_account_namespaces="default" \
        policies="replication-token" \
        ttl=24h
vault write auth/kubernetes-dc1/role/consul-ca \
        bound_service_account_names="*" \
        bound_service_account_namespaces="default" \
        policies=ca-policy \
        ttl=1h
```

#### Create roles for `kubernetes-dc2`

```shell
vault write auth/kubernetes-dc2/role/consul-server \
        bound_service_account_names=consul-server \
        bound_service_account_namespaces="default" \
        policies="gossip,connect-ca-dc2,consul-cert-dc2,replication-token" \
        ttl=24h
vault write auth/kubernetes-dc2/role/consul-client \
        bound_service_account_names=consul-client \
        bound_service_account_namespaces="default" \
        policies="gossip" \
        ttl=24h
vault write auth/kubernetes-dc2/role/server-acl-init \
        bound_service_account_names=consul-server-acl-init \
        bound_service_account_namespaces="default" \
        policies="replication-token" \
        ttl=24h
vault write auth/kubernetes-dc2/role/consul-ca \
        bound_service_account_names="*" \
        bound_service_account_namespaces="default" \
        policies=ca-policy \
        ttl=1h
```

### Create gossip key secret and policy

```
$ vault secrets enable -path=consul kv-v2
$ vault kv put consul/secret/gossip key="$(consul keygen)"
$ vault policy write gossip - <<EOF
path "consul/data/secret/gossip" {
  capabilities = ["read"]
}
EOF
```

### Create replication token secret and policy

```
$ vault kv put consul/secret/replication token="$(uuidgen | tr '[:upper:]' '[:lower:]')"
$ vault policy write replication-token - <<EOF
path "consul/data/secret/replication" {
  capabilities = ["read"]
}
EOF
```

### Configure Consul server PKI

#### Root CA and policy

First, we need to enable the PKI engine and generate the root CA:

```
vault secrets enable pki
vault write pki/root/generate/internal common_name="Consul CA" ttl=87600
vault policy write ca-policy - <<EOF
path "pki/cert/ca" {
  capabilities = ["read"]
}
EOF
```

#### Server cert role and policy in DC1

```
vault write pki/roles/consul-cert-dc1 \
  allowed_domains="dc1.consul,consul-server,consul-server.default,consul-server.default.svc" \
  allow_subdomains=true \
  allow_bare_domains=true \
  allow_localhost=true \
  generate_lease=true \
  max_ttl="720h"
```

```
vault policy write consul-cert-dc1 - <<EOF
path "pki/issue/consul-cert-dc1"
{
  capabilities = ["create","update"]
}
EOF
```

#### Server cert role and policy in DC2

```
vault write pki/roles/consul-cert-dc2 \
  allowed_domains="dc2.consul,consul-server,consul-server.default,consul-server.default.svc" \
  allow_subdomains=true \
  allow_bare_domains=true \
  allow_localhost=true \
  generate_lease=true \
  max_ttl="720h"
```

```
vault policy write consul-cert-dc2 - <<EOF
path "pki/issue/consul-cert-dc2"
{
  capabilities = ["create","update"]
}
EOF
```

### Create Connect CA policy

This policy will allow Consul servers to use Vault as the CA for the service mesh. We need to create one for each datacenter, as they will have different intermediates.

```
vault policy write connect-ca-dc1 - <<EOF
path "/sys/mounts" {
  capabilities = [ "read" ]
}
path "/sys/mounts/connect_root" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/sys/mounts/dc1/connect_inter" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/connect_root/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/dc1/connect_inter/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
EOF
```

```
vault policy write connect-ca-dc2 - <<EOF
path "/sys/mounts" {
  capabilities = [ "read" ]
}
path "/sys/mounts/connect_root" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/sys/mounts/dc2/connect_inter" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/connect_root/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/dc2/connect_inter/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
EOF
```

## 3. Deploy Consul

### Consul in dc1

Create Helm values for dc1:

```yaml
# consul-dc1.yaml
global:
  datacenter: "dc1"
  name: consul
  secretsBackend:
    vault:
      enabled: true
      consulServerRole: consul-server
      consulClientRole: consul-client
      consulCARole: consul-ca
      manageSystemACLsRole: server-acl-init
      connectCA:
        address: http://vault-dc1.default:8200
        rootPKIPath: connect_root/
        intermediatePKIPath: dc1/connect_inter/
        authMethodPath: kubernetes-dc1
  tls:
    enabled: true
    enableAutoEncrypt: true
    caCert:
      secretName: "pki/cert/ca"
  federation:
    enabled: true
  acls:
    manageSystemACLs: true
    createReplicationToken: true
    replicationToken:
      secretName: consul/data/secret/replication
      secretKey: token
  gossipEncryption:
    secretName: consul/data/secret/gossip
    secretKey: key
server:
  replicas: 1
  serverCert:
    secretName: "pki/issue/consul-cert-dc1"
connectInject:
  replicas: 1
  enabled: true
controller:
  enabled: true
meshGateway:
  enabled: true
  replicas: 1
```

```
helm install consul-dc1 -f consul-dc1.yaml hashicorp/consul
```

### Consul in dc2

For the second datacenter, we will need to get the address of the mesh gateway from the **dc1** cluster:

On GKE and AKS:

```
MESH_GW_HOST=$(kubectl get svc consul-mesh-gateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
```

On EKS:
```
MESH_GW_HOST=$(kubectl get svc consul-mesh-gateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
```

```shell
cat <<EOF >> consul-dc2.yaml
global:
  datacenter: "dc2"
  name: consul
  secretsBackend:
    vault:
      enabled: true
      consulServerRole: consul-server
      consulClientRole: consul-client
      consulCARole: consul-ca
      manageSystemACLsRole: server-acl-init
      connectCA:
        address: http://${VAULT_SERVER_HOST}:8200
        rootPKIPath: connect_root/
        intermediatePKIPath: dc2/connect_inter/
        authMethodPath: kubernetes-dc2
  tls:
    enabled: true
    enableAutoEncrypt: true
    caCert:
      secretName: "pki/cert/ca"
  federation:
    enabled: true
    primaryDatacenter: dc1
    primaryGateways:
    - ${MESH_GW_HOST}:443
  acls:
    manageSystemACLs: true
    replicationToken:
      secretName: consul/data/secret/replication
      secretKey: token
  gossipEncryption:
    secretName: consul/data/secret/gossip
    secretKey: key
server:
  replicas: 1
  serverCert:
    secretName: "pki/issue/consul-cert-dc2"
connectInject:
  replicas: 1
  enabled: true
controller:
  enabled: true
meshGateway:
  enabled: true
  replicas: 1
EOF
```

Switch to **dc2** cluster and run:

```
helm install consul-dc2 -f consul-dc2.yaml hashicorp/consul
``` -->

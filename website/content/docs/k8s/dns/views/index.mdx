---
layout: docs
page_title: Consul DNS views for Kubernetes
description: ->
    Learn how to schedule a Consul DNS proxy for Kubernetes Pods so that your applications can return Consul DNS results for service discovery.
---

# Consul DNS views for Kubernetes

This topic describes how to schedule a dedicated Consul DNS proxy in a Kubernetes Pod so that Kubernetes Services can use Consul DNS addresses. 

## Introduction

Kubernetes operators typically choose networking tools such as [kube-dns](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/) or [CoreDNS](https://kubernetes.io/docs/tasks/administer-cluster/coredns/) for their service discovery operations, and choose to bypass Consul DNS entirely. These options may be sufficient for service networking operations within a single Kubernetes cluster.

Because Consul is interoperabile between runtimes and cloud providers, you can use Consul on Kubernetes to discover services that were registered with any Consul datacenter, even ones running on non-Kubernetes deployments. For example, you can [create a cluster peering connection](/consul/docs/k8s/connect/cluster-peering/usage/establish-peering) between a Consul datacenter running on Kubernetes and a Consul datacenter running on a virtual machine. Then, you can run the Consul DNS proxy as a Kubernetes Service so that other Services can use Consul DNS to resolve the services running on the VM.

To use Consul DNS for service discovery on Kubernetes, deploy a `consul-proxy` service in each Kubernetes Pod that needs to resolve Consul DNS. All DNS requests in the Kubernetes Pod are sent to the Kubernetes controller first. The controller forwards requests for the `.consul` domain to the `consul-proxy` service, which then queries the Consul catalog and returns service discovery results.

The `consul-proxy` does not require the presence of Consul client agents or Consul dataplanes. As a result, it removes gossip communication as a requirement for Consul DNS.

## Workflows

The process to enable Consul DNS views for service discovery in Kubernetes deployments consists of the following steps:

1. Update the Helm chart for your Consul on Kubernetes deployment so that `dns.proxy.enabled=true`. When you apply the update, Kubernetes deploys the Consul DNS proxy.
1. Look up the IP address for the Consul DNS proxy in the Kubernetes Pod.
1. Update the DNS configuration in the Kubernetes cluster to forward requests for the `.consul` domain to the IP address of the Consul DNS proxy.

For more information about the underlying concepts, refer to [DNS forwarding overview](/consul/docs/services/discovery/dns-forwarding).

## Benefits

Consul on Kubernetes currently uses [Consul dataplanes](/consul/docs/connect/dataplane) by default. These lightweight processes provide Consul access to the sidecar proxies in the service mesh, but leave Kubernetes in charge of most other service discovery and service mesh operations.

- **Use KubeDNS and Consul DNS in a single deployment**.  The Consul DNS proxy enables any Service in a Pod to resolve an address through Consul DNS without changes to the underlying Kubernetes DNS functionality.
- **Consul service discovery using less resources**. When you use the Consul DNS proxy for service discovery, you do not need to schedule Consul client agents or dataplanes. One Kubernetes Service that uses the same resources as a single Consul dataplane provides the entire Pod access to the Consul catalog.
- **Consul DNS without gossip communication**. The Consul DNS service runs on both Consul server and Consul client agents, which use [gossip communication](/consul/docs/security/encryption/gossip) to ensure that service discovery results are up-to-date. The Consul DNS proxy provides access to Consul DNS without the security overhead of agent-to-agent gossip.

## Constraints and limitations

If you experience issues using the Consul DNS proxy for Kubernetes, refer to the following list of technical constraints and limitations.

- You cannot schedule the Consul DNS proxy in other container-based environments. You must use Kubernetes.
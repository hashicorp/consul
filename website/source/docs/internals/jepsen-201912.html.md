---
layout: "docs"
page_title: "Jepsen Testing in Consul, 2019 Update"
sidebar_current: "docs-internals-jepsen"
description: |-
  TODO
---

# FIXME(proofing, consistency flag) Jepsen Testing in Consul, 2019 Update

NOTE This is probably better in just the blog post. Website documentation has a significantly different voice, I believe.
## FIXME(proofing, requires link to previous consul/jepsen docs, discuss  stale reads on ?consistent) Introduction
  In December of 2019, I joined the Consul Core team as a Senior Software Engineer to build and rigoriously verify all of that networked, distributed goodness. I'm a contributing author for [Jepsen](https://jepsen.io) and a major contributor to both the [Jepsen library](https://github.com/jepsen-io/jepsen) and the [Knossos linearizability checker](https://github.com/jepsen-io/knossos). 

  NOTE For review: This synopsis has not taken the behavior talked about in #talk-jepsen where reads are not passed through the consensus module when `?consistent` is enabled
  In this blog post, we're going to explore Consul's [Jepsen testing efforts](TODO LINK to previous analysis) and recent work we've done to improve it. We'll explain what Jepsen testing is all about, dig into the prior jepsen testing performed by the Consul team, how a linearizable register test work, what we've added, how Consul has again passed its more rigorous suite, and what future work remains.

  It's important to note that, while I have worked with database vendors and Jepsen, LLC as an indepedent researcher in (2017-2019), and [published a formal Jepsen analysis](http://jepsen.io/analyses/mongodb-3-6-4), this is **NOT** an offical Jepsen report. Official Jepsen analyses are performed as an indepedent entity, in accordance with the [Jepsen Ethics Policy](https://jepsen.io/ethics), and verified by Kyle Kingbury (aphyr). Though I follow Jepsen's research ethics policy to the best of my ability in this and prior work, as an employee of HashiCorp I have an unambiguous and direct conflict of interest. Therefore, readers of this article **must not** consider this a substitute for an offical Jepsen [analysis](http://jepsen.io/analyses) on Consul.

## FIXME(proofing) What is Consul?
  [HashiCorp Consul](https://consul.io) is an open source tool that provides service discovery, health checking, load balancing, and a globally distributed key-value store. Consul is a large distributed system, providing all of its core functionality over networks, whether as traffic between servers, health checking services, or serving requests on its state to clients. It's well understood that [networks are not reliable](https://aphyr.com/posts/288-the-network-is-reliable) and distributed systems are [notoriously difficult to implement correctly](http://jepsen.io/analyses). With so many concurrently running processes, there's a large surface area for unexpected behavior to occur. So that's why the Consul team works hard to verify the behavior of the software as much as possible.

## FIXME(proofing) What is Jepsen?
  [Jepsen](http://jepsen.io/#about-jepsen) started as a [library](https://github.com/jepsen-io/jepsen) written by Kyle Kingsbury (aphyr) to test the reliability of actual running distributed systems such as databases, queues, locking services, consensus systems, and more. The goal is to help verify the expectations vendors set with their users in documentation and promotional material and drive better understanding about the real behavior these systems. Jepsen specializes in testing systems under the kinds of adverse conditions, like network partitions, system clock instability, and unexpected changes in cluster membership, that are [known to occur](https://queue.acm.org/detail.cfm?id=2655736) but for which comprehensive testing options otherwise lacked. Since its beginning in 2013, Jepsen analyses have strongly influenced popular databases in use today, bridging the gap between formal verification and practical testing in our field.

Over the years, Jepsen has grown into an LLC offering indepedent research and training, and as a destination for readers to understand distributed systems in use today through their portfolio of [analyses](http://jepsen.io/analyses), and learn more about their properties through resources like [talks](http://jepsen.io/talks) and articles on the field of distributed systems verification, such as the [graph of consistency levels and their descriptions](http://jepsen.io/consistency). [Ethically](https://jepsen.io/ethics) backed and rigorous fault injection testing provided by indepedent sources, such as Jepsen, matters because it encourages database vendors, HashiCorp included, to keep the promises they make to their users about the real-life behavior of their systems. Functionally, it's a lot like security testing. Instead of testing a system against a malicious actor, we test a data carrying system against specific advese environmental factors that can compromise the safety of our systems.

Black-box style Jepsen test suites are complementary to practices like unit and integration testing, and, [composed with other means](https://queue.acm.org/detail.cfm?id=2889274), form a constellation of practices that database vendors may adopt to confidently offer their products to users with demanding reliability needs.

We can see a bit more about how a Jepsen test works under nemesis behavior with Jepens's [perf checkers](TODO LINK) providing latency plots, throughput graphs, and others. Jepsen has limits in temporal resolution and tests only very specific machine circumstances, so it's not to be taken as an authority on benchmarking. However, by observing the regions where nemeses are active, you can see the cluster's behavior change. The `random-halves partitioner` will sometimes place the leader on the minority side of the 2-3 partitioned cluster, in which case we'll see Consul's KV store stop serving requests, seek to elect a new leader on the majority side.

![Raw latency plot](https://consul-jepsen.s3.us-east-2.amazonaws.com/201912/latency-raw.png)
![Graph of ops throughput](https://consul-jepsen.s3.us-east-2.amazonaws.com/201912/rate.png)

## FIXME(proofing) Consul's Jepsen Tests
Jepsen tests one of the foundational components of Consul: its [consensus layer](https://www.consul.io/docs/internals/consensus.html). Utilizeing ashiCorp's own [open source implementation of Raft](https://github.com/hashicorp/raft) to replicate a [finite state machine](https://github.com/hashicorp/consul/tree/master/agent/consul/fsm) between [agents](https://www.consul.io/docs/agent/basics.html). [Raft](https://raft.github.io/raft.pdf) is [proven to be linearizable](https://github.com/uwplse/verdi/pull/16) when implemented correctly. 

In 2014 (five and a half years ago at the time of this article was written) the early Consul team did a rare thing in the industry at the time. They elected to [write their own Jepsen tests](https://github.com/jepsen-io/jepsen/commit/a9fe0a1c7deed9a50d3ca40c2d949d090e02c1ea#diff-e5bb30b574d23c7714625461ef5255cf). We did uncover a small window of stale reads that occur after a new leader is elected in the cluster. In response, we added support for different [consistency levels](https://www.consul.io/api/features/consistency.html). You can read more about the tests in [Consul's previous writeup](TODO Link to jepsen.consul 2014) and Kyle Kingsbury's exploration of the test and results [back in 2014](https://aphyr.com/posts/316-call-me-maybe-etcd-and-consul).

- A [register test](https://github.com/jepsen-io/jepsen/blob/master/jepsen/src/jepsen/tests/linearizable_register.clj) is a way of checking that a history of operations can be [linearized](https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf). Linearizability is the requirement that all operations on a single object, appear in order on all nodes with strict realtime constraints. [Consul's key-value](https://www.consul.io/docs/agent/kv.html) store gives us a direct way to model Consul's replicated FSM as a register. We treat each key as a single value that we write to, many times concurrently, from many clients to each of the 5 nodes. Then we see if all the nodes agree on the value with regards to precise real-time bounds. In this way, linearizable systems are simple to reason about. At **no** observable instant can **any** of the nodes read different values of the register Which is to say, they must all strictly agree on every value at every moment.

We can interact with the register by abstracting GET and POST requests from our clients as :read, :write, and :cas (compare-and-swap) operations. Reads give us a view of the state of each node. Writes alter the state of the register a given number. CAS ops are composed of a read then a write: we read the value of the register acquiring the node's current value and the value's index, and if the read value is the same, we issue CAS request using KV-put and specifiying the index of the previous value with the request, to ensure the value has not changed since we read it. Together, all of these operations form a history of their invocations and completion.

By measuring the inverval between invocation and completion of ops in the history, we can make deductions about the behavior of the system. The linearizability checker, [Knosses](https://github.com/jepsen-io/knossos), explores sections of operations that are easy to evaluate, until we find a path through them that can be linearized. If no linaerizable paths are found, we continue searching more and more complex spaces all paths are explored. Only then can safely say that a history is not valid, and there is no linearizable path through the history.

![Register 7 linear.png](https://consul-jepsen.s3.us-east-2.amazonaws.com/201912/jepsen-7-linear.png)

To better illustrate the behavior of a register test, we can induce a simple failure in the Consul tests by performing the register test with `stale` reads enabled. Below, the `:read 3` operation returned from process 3 while process 8's `:cas 0 1` op meant the client read the value 0 before writing 1. In other words, for `[:cas 0 1]` to have succeeded within the time bounds we've observed, process 3 and process 8 must have read a different view of the cluster. Therefore, we know that these two operations cannot be linearized, because linearizability requires that all processes agree on the state of the register within strictly observable time bounds.

![Register 7 timeline.png](https://consul-jepsen.s3.us-east-2.amazonaws.com/201912/jepsen-7-timeline.png)

If we look closer at the behavior of the key, we can see that process 3's `[:read 3]` was able to successfully read the result of process X's `[:op val]`. However, process 8's `[:cas 0 1]` succeeded in comparing the initial value of the register, `0` and writing `1` despite writes succeeding before it in the timeline. You may also notice in the timeline that process 8 has a successful `[:write 4]` op before it invoked the non-linearizable cas operation. If this is setting off red flags in your _brain's_ consistency-checker than you're right! The write operation was passed through the consensus system, and you can see it (or process 29's concurrent `[:write 4]`) read out process 1 and process 5. However, with stale reads enabled, that value was _not_ able to be read in its own process. So while writes themselves are of course safe when reads with the `stale` flag are performed, performing stale reads on Consul's KV store means that it will fail to reflect even one of the [consistency levels](http://jepsen.io/consistency), [Read Your Writes](http://jepsen.io/consistency/models/read-your-writes)(RYW). There *are* use cases where stale KV store reads below RYW are valid. As users of Consul, it's worth understanding if you wish to make that tradeoff.

It's worth reiterating that this is an intentionally-failing example. Stale reads are not intended to be linearizable.

## FIXME(proofing) What's new?
After five and a half years, the old test suite got a bit dusty and didn't run anymore. So, we started by bumping the test version up to [Jepsen v0.1.15](https://github.com/jepsen-io/jepsen/blob/4317df78555c338e9aa0327bdfa9ee7a33fb94db/consul/src/jepsen/consul/project.clj#L7). We rewrote the test runner to accept a spec of [CLI args](https://github.com/jepsen-io/jepsen/blob/master/consul/src/jepsen/consul.clj#L58) and we can now implement tests as [workloads](https://github.com/jepsen-io/jepsen/blob/4317df78555c338e9aa0327bdfa9ee7a33fb94db/consul/src/jepsen/consul.clj#L15). Workloads allow us to run sets of tests at once (or no tests at all) by specifying which, e.g. `--workload register`. As you can imagine, this is useful in all contexts of running and developing a test suite -- with the ability to run specific tests in a suite, or none at all to exercise setup code for the suite and db. We also paramaterized [different release versions of Consul](https://github.com/jepsen-io/jepsen/blob/4317df78555c338e9aa0327bdfa9ee7a33fb94db/consul/src/jepsen/consul/db.clj#L58). All of the tests for this post were run against [Consul v1.6.1](https://github.com/jepsen-io/jepsen/blob/4317df78555c338e9aa0327bdfa9ee7a33fb94db/consul/src/jepsen/consul.clj#L61).

Once we'd upgraded the structure of the tests to fit jepsen's newer abstractions, we double checked all the behavior of the previous register test implementation. While most of the previous tests were still valid, we found a various places to improve the stictness of the tests. First, we fixed a [bug](https://github.com/jepsen-io/jepsen/commit/db24fac7c68c3283b9c2c20e742fa508268ab07e#diff-f5e04f13dad45e9e80332ddce9d754e8R57) with the register test's `client` that prevented CAS (compare-and-swap) operations from ever being completed. We also ported the register test's generator to [jepsen.independent/concurrent-generator](https://github.com/jepsen-io/jepsen/commit/19b085f49471abffb57fa240021a15640d0005a5#diff-71833489f38c369aa9ca5454002fe061R64) to raise the thoughput significantly by writing to [multiple keys in parallel](http://jepsen-io.github.io/jepsen/jepsen.independent.html#var-concurrent-generator) with 10 threads per key. This also speeds up and reduces the memory footprint of the checker by subdividing the state space that [Knossos' two competing implementations](https://github.com/jepsen-io/knossos/blob/master/src/knossos/competition.clj#L18-L19) have to explore. Linearizability checking over arbitrary histories is unbounded, but in practice violations over very long time periods (think, multiple minutes) are rare. So we can afford to take that specific tradeoff when generating histories from running systems, making linear checking stable and practical.

## FIXME(proofing, upload the test store bits, discuss stale reads on ?consistent) Results
NOTE For review blocking publishing: This version of the results has not taken the behavior of `?consistent` into account

Based on weeks of testing against the updated register workload, we're happy to announce that Consul continues to pass its jepsen test suite! While there's certainly more workloads besides the register  to explore (see Future Work below), after five and a half years and a much higher throughput, stricter test, Consul appears to continue to implement hashicorp/Raft correctly to utilize a linearizable consensus-backed [Finite State Machine](TODO Link to hashicorp/consul/agent/consul/fsm). NOTE (?consistency flag needs to be discussed) There are also no known consistency issues with Consul's consensus system or hashicorp/raft at this time.

```
Everything looks good! ヽ(‘ー`)ノ
```
(Well, at least everything we've checked so far!) 

## TODO(proofing & discuss stale reads on ?consistent) Future Work
NOTE For review: This version of the results has not taken the behavior talked about in #talk-jepsen where reads are not passed through the consensus module when `?consistent` is enabled

This has been a side project and no additional releases are scheduled yet. However, there is much more we *can* do to more strictly verify Consul and other consensus-backed HashiCorp products, such as Vault and Nomad. There are more [tests](https://github.com/jepsen-io/jepsen/tree/master/jepsen/src/jepsen/tests) that we can implement as additional workloads. For example, append-only set are significantly higher throughput than register tests. Linearizability is NP hard. They are also quick to verify. They may be used to quickly find broad regressions when run often in CI. While we may use more strict tests like [lock](https://github.com/jepsen-io/etcd/blob/master/src/jepsen/etcd/lock.clj) and [watch](https://github.com/jepsen-io/etcd/blob/master/src/jepsen/etcd/watch.clj) to test those specific features in Consul. Finally, there's a wealth of prior work analyzing transaction systems that we can apply, with [bank](https://github.com/jepsen-io/jepsen/blob/master/jepsen/src/jepsen/tests/bank.clj), [cycle](https://github.com/jepsen-io/jepsen/blob/master/jepsen/src/jepsen/tests/cycle.clj), and [causal-reverse](https://github.com/jepsen-io/jepsen/blob/master/jepsen/src/jepsen/tests/causal_reverse.clj) tests each providing specific coverage. Perhaps in the not-so-distant future, HashiCorp can even contribute back to the Jepsen ecosystem with new checkers or variations on established ones.

Alongside new tests, there's additional [nemeses](https://github.com/jepsen-io/etcd/blob/master/src/jepsen/etcd/nemesis.clj) that we can bring in and compose with the network partitioner to apply more rigorous faults. For example, there exist nemeses that can pause, kill, and restart processes, induce membership changes, and alter system clocks.

We may yet find bugs or lesser known edge cases by exploring the large state space of Consul's configuration. Right now, we test Consul under [default parameters](https://github.com/jepsen-io/jepsen/blob/4317df78555c338e9aa0327bdfa9ee7a33fb94db/consul/src/jepsen/consul/db.clj#L26-L40) doing little besides starting an agent as a server. With options for users to adjust timeouts and various other parameters, there's more for the Consul Core team to explore, verify, and document. In the future, we may [construct a config.hcl file from CLI params](https://github.com/jepsen-io/jepsen/blob/4317df78555c338e9aa0327bdfa9ee7a33fb94db/consul/src/jepsen/consul/db.clj#L65) exposing more configuration options to the jepsen test suite.

In addition to enhancements to the test suite itself, there's the possibility to integrate Jepsen tests more closely in Consul's development workflow via our continuous integration (CI) pipeline. Other database vendors run their jepsen suites periodically (weekly, nightly, etc.) to spot regressions in the primary working branch. As we add more workloads of varying complexity and strictness, we can tune how often these run. (Waiting for a full linear test every single commit is not necessarily practical.) Consul is currently expanding our testing practices to test backwards compatability, and with some additional CI infrastructure, we can test multiple builds of Consul with a the same set of jepsen tests.

Internally, we've discussed introducing additional test suites for other consensus-backed HashiCorp products, e.g. Nomad and Vault. [Linearizable systems are not guaranteed to compose](https://aphyr.com/posts/333-serializability-linearizability-and-locality), meaning that using a formally verified consensus system like Raft is not sufficient. We must also test _how_ we use Raft. Jepsen's fault injecting nemeses, suites of well-tested consistency checkers, and variety of supporting tools and abstractions offer an expert set of tools for HashiCorp to verify the software we offer.

## FIXME(proofing, need to discuss stale reads on leader change) Conclusion

NOTE For review blocking publishing: This synopsis is not complete until we've integrated discussion of  the behavior of the `?consistent` read flag

In this article, we learned the importance of rigorously testing the real behavior of distributed systems like Consul. We covered the Consul team's history of electing to subject its Raft-based FSM to Jepsen's array of fault injection techniques. We explored recent efforts to increase the strictness of these tests and roads we've built towards further exploration. With this and prior work verifying the correctness of its consensus system and carefully documenting the real behavior of its systems, Consul has a clear history and ongoing commitment towards the safety of the data entrusted to its clusters. As we continue expanding our verification techniques at HashiCorp with Jepsen and other tools you can expect additional posts examining the technical details of these approaches.

### Additional Resources
- A substantial collection of the store results from the consul 1.6.1 register tests can be downloaded [here](https://consul-jepsen.s3.us-east-2.amazonaws.com/201912/jepsen201912-store.zip). The example above in What is a Register Test can be found in key 7 of test 20200129T194911.000Z: e.g. `20200129T194911.000Z/independent/7/`.

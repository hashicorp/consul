// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: structs.proto

package stream

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/duration"
	github_com_hashicorp_consul_agent_structs "github.com/hashicorp/consul/agent/structs"
	github_com_hashicorp_consul_types "github.com/hashicorp/consul/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Used to return information about a node
type Node struct {
	ID              github_com_hashicorp_consul_types.NodeID `protobuf:"bytes,1,opt,name=ID,proto3,casttype=github.com/hashicorp/consul/types.NodeID" json:"ID,omitempty"`
	Node            string                                   `protobuf:"bytes,2,opt,name=Node,proto3" json:"Node,omitempty"`
	Address         string                                   `protobuf:"bytes,3,opt,name=Address,proto3" json:"Address,omitempty"`
	Datacenter      string                                   `protobuf:"bytes,4,opt,name=Datacenter,proto3" json:"Datacenter,omitempty"`
	TaggedAddresses map[string]string                        `protobuf:"bytes,5,rep,name=TaggedAddresses,proto3" json:"TaggedAddresses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Meta            map[string]string                        `protobuf:"bytes,6,rep,name=Meta,proto3" json:"Meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RaftIndex       `protobuf:"bytes,7,opt,name=RaftIndex,proto3,embedded=RaftIndex" json:"RaftIndex" bexpr:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{0}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

// ServiceDefinition is used to JSON decode the Service definitions. For
// documentation on specific fields see NodeService which is better documented.
type ServiceDefinition struct {
	Kind              github_com_hashicorp_consul_agent_structs.ServiceKind `protobuf:"bytes,1,opt,name=Kind,proto3,casttype=github.com/hashicorp/consul/agent/structs.ServiceKind" json:"Kind,omitempty"`
	ID                string                                                `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Name              string                                                `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Tags              []string                                              `protobuf:"bytes,4,rep,name=Tags,proto3" json:"Tags,omitempty"`
	Address           string                                                `protobuf:"bytes,5,opt,name=Address,proto3" json:"Address,omitempty"`
	TaggedAddresses   map[string]*ServiceAddress                            `protobuf:"bytes,16,rep,name=TaggedAddresses,proto3" json:"TaggedAddresses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Meta              map[string]string                                     `protobuf:"bytes,6,rep,name=Meta,proto3" json:"Meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Port              int                                                   `protobuf:"varint,7,opt,name=Port,proto3,casttype=int" json:"Port,omitempty"`
	Check             CheckType                                             `protobuf:"bytes,8,opt,name=Check,proto3" json:"Check"`
	Checks            []*CheckType                                          `protobuf:"bytes,9,rep,name=Checks,proto3" json:"Checks,omitempty"`
	Weights           *Weights                                              `protobuf:"bytes,10,opt,name=Weights,proto3" json:"Weights,omitempty"`
	Token             string                                                `protobuf:"bytes,11,opt,name=Token,proto3" json:"Token,omitempty"`
	EnableTagOverride bool                                                  `protobuf:"varint,12,opt,name=EnableTagOverride,proto3" json:"EnableTagOverride,omitempty"`
	// DEPRECATED (ProxyDestination) - remove this when removing ProxyDestination
	// ProxyDestination is deprecated in favor of Proxy.DestinationServiceName
	ProxyDestination string `protobuf:"bytes,13,opt,name=ProxyDestination,proto3" json:"ProxyDestination,omitempty"`
	// Proxy is the configuration set for Kind = connect-proxy. It is mandatory in
	// that case and an error to be set for any other kind. This config is part of
	// a proxy service definition and is distinct from but shares some fields with
	// the Connect.Proxy which configures a managed proxy as part of the actual
	// service's definition. This duplication is ugly but seemed better than the
	// alternative which was to re-use the same struct fields for both cases even
	// though the semantics are different and the non-shared fields make no sense
	// in the other case. ProxyConfig may be a more natural name here, but it's
	// confusing for the UX because one of the fields in ConnectProxyConfig is
	// also called just "Config"
	Proxy   *ConnectProxyConfig `protobuf:"bytes,14,opt,name=Proxy,proto3" json:"Proxy,omitempty"`
	Connect *ServiceConnect     `protobuf:"bytes,15,opt,name=Connect,proto3" json:"Connect,omitempty"`
}

func (m *ServiceDefinition) Reset()         { *m = ServiceDefinition{} }
func (m *ServiceDefinition) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinition) ProtoMessage()    {}
func (*ServiceDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{1}
}
func (m *ServiceDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinition.Merge(m, src)
}
func (m *ServiceDefinition) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinition proto.InternalMessageInfo

// Type to hold an address and port of a service
type ServiceAddress struct {
	Address string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	Port    int    `protobuf:"varint,2,opt,name=Port,proto3,casttype=int" json:"Port,omitempty"`
}

func (m *ServiceAddress) Reset()         { *m = ServiceAddress{} }
func (m *ServiceAddress) String() string { return proto.CompactTextString(m) }
func (*ServiceAddress) ProtoMessage()    {}
func (*ServiceAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{2}
}
func (m *ServiceAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceAddress.Merge(m, src)
}
func (m *ServiceAddress) XXX_Size() int {
	return m.Size()
}
func (m *ServiceAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceAddress.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceAddress proto.InternalMessageInfo

// HealthCheck represents a single check on a given node
type HealthCheck struct {
	Node        string                                    `protobuf:"bytes,1,opt,name=Node,proto3" json:"Node,omitempty"`
	CheckID     github_com_hashicorp_consul_types.CheckID `protobuf:"bytes,2,opt,name=CheckID,proto3,casttype=github.com/hashicorp/consul/types.CheckID" json:"CheckID,omitempty"`
	Name        string                                    `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Status      string                                    `protobuf:"bytes,4,opt,name=Status,proto3" json:"Status,omitempty"`
	Notes       string                                    `protobuf:"bytes,5,opt,name=Notes,proto3" json:"Notes,omitempty"`
	Output      string                                    `protobuf:"bytes,6,opt,name=Output,proto3" json:"Output,omitempty"`
	ServiceID   string                                    `protobuf:"bytes,7,opt,name=ServiceID,proto3" json:"ServiceID,omitempty"`
	ServiceName string                                    `protobuf:"bytes,8,opt,name=ServiceName,proto3" json:"ServiceName,omitempty"`
	ServiceTags []string                                  `protobuf:"bytes,9,rep,name=ServiceTags,proto3" json:"ServiceTags,omitempty"`
	Definition  HealthCheckDefinition                     `protobuf:"bytes,10,opt,name=Definition,proto3" json:"Definition" bexpr:"-"`
	RaftIndex   `protobuf:"bytes,11,opt,name=RaftIndex,proto3,embedded=RaftIndex" json:"RaftIndex" bexpr:"-"`
}

func (m *HealthCheck) Reset()         { *m = HealthCheck{} }
func (m *HealthCheck) String() string { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()    {}
func (*HealthCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{3}
}
func (m *HealthCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheck.Merge(m, src)
}
func (m *HealthCheck) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheck.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheck proto.InternalMessageInfo

type HealthCheckDefinition struct {
	HTTP                           string        `protobuf:"bytes,1,opt,name=HTTP,proto3" json:",omitempty"`
	TLSSkipVerify                  bool          `protobuf:"varint,2,opt,name=TLSSkipVerify,proto3" json:",omitempty"`
	Header                         Headers       `protobuf:"bytes,3,opt,name=Header,proto3,customtype=Headers" json:"Header"`
	Method                         string        `protobuf:"bytes,4,opt,name=Method,proto3" json:",omitempty"`
	TCP                            string        `protobuf:"bytes,5,opt,name=TCP,proto3" json:",omitempty"`
	Interval                       time.Duration `protobuf:"bytes,6,opt,name=Interval,proto3,stdduration" json:"Interval"`
	Timeout                        time.Duration `protobuf:"bytes,7,opt,name=Timeout,proto3,stdduration" json:"Timeout"`
	DeregisterCriticalServiceAfter time.Duration `protobuf:"bytes,8,opt,name=DeregisterCriticalServiceAfter,proto3,stdduration" json:"DeregisterCriticalServiceAfter"`
}

func (m *HealthCheckDefinition) Reset()         { *m = HealthCheckDefinition{} }
func (m *HealthCheckDefinition) String() string { return proto.CompactTextString(m) }
func (*HealthCheckDefinition) ProtoMessage()    {}
func (*HealthCheckDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{4}
}
func (m *HealthCheckDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheckDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheckDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheckDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheckDefinition.Merge(m, src)
}
func (m *HealthCheckDefinition) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheckDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheckDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheckDefinition proto.InternalMessageInfo

// CheckServiceNode is used to provide the node, its service
// definition, as well as a HealthCheck that is associated.
type CheckServiceNode struct {
	Node    *Node          `protobuf:"bytes,1,opt,name=Node,proto3" json:"Node,omitempty"`
	Service *NodeService   `protobuf:"bytes,2,opt,name=Service,proto3" json:"Service,omitempty"`
	Checks  []*HealthCheck `protobuf:"bytes,3,rep,name=Checks,proto3" json:"Checks,omitempty"`
}

func (m *CheckServiceNode) Reset()         { *m = CheckServiceNode{} }
func (m *CheckServiceNode) String() string { return proto.CompactTextString(m) }
func (*CheckServiceNode) ProtoMessage()    {}
func (*CheckServiceNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{5}
}
func (m *CheckServiceNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckServiceNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckServiceNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckServiceNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckServiceNode.Merge(m, src)
}
func (m *CheckServiceNode) XXX_Size() int {
	return m.Size()
}
func (m *CheckServiceNode) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckServiceNode.DiscardUnknown(m)
}

var xxx_messageInfo_CheckServiceNode proto.InternalMessageInfo

// NodeService is a service provided by a node
type NodeService struct {
	// Kind is the kind of service this is. Different kinds of services may
	// have differing validation, DNS behavior, etc. An empty kind will default
	// to the Default kind. See ServiceKind for the full list of kinds.
	Kind              github_com_hashicorp_consul_agent_structs.ServiceKind `protobuf:"bytes,1,opt,name=Kind,proto3,casttype=github.com/hashicorp/consul/agent/structs.ServiceKind" json:",omitempty"`
	ID                string                                                `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Service           string                                                `protobuf:"bytes,3,opt,name=Service,proto3" json:"Service,omitempty"`
	Tags              []string                                              `protobuf:"bytes,4,rep,name=Tags,proto3" json:"Tags,omitempty"`
	Address           string                                                `protobuf:"bytes,5,opt,name=Address,proto3" json:"Address,omitempty"`
	TaggedAddresses   map[string]*ServiceAddress                            `protobuf:"bytes,15,rep,name=TaggedAddresses,proto3" json:"TaggedAddresses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Meta              map[string]string                                     `protobuf:"bytes,6,rep,name=Meta,proto3" json:"Meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Port              int                                                   `protobuf:"varint,7,opt,name=Port,proto3,casttype=int" json:"Port,omitempty"`
	Weights           *Weights                                              `protobuf:"bytes,8,opt,name=Weights,proto3" json:"Weights,omitempty"`
	EnableTagOverride bool                                                  `protobuf:"varint,9,opt,name=EnableTagOverride,proto3" json:"EnableTagOverride,omitempty"`
	// ProxyDestination is DEPRECATED in favor of Proxy.DestinationServiceName.
	// It's retained since this struct is used to parse input for
	// /catalog/register but nothing else internal should use it - once
	// request/config definitions are passes all internal uses of NodeService
	// should have this empty and use the Proxy.DestinationServiceNames field
	// below.
	//
	// It used to store the name of the service that this service is a Connect
	// proxy for. This is only valid if Kind is "connect-proxy". The destination
	// may be a service that isn't present in the catalog. This is expected and
	// allowed to allow for proxies to come up earlier than their target services.
	// DEPRECATED (ProxyDestination) - remove this when removing ProxyDestination
	ProxyDestination string `protobuf:"bytes,10,opt,name=ProxyDestination,proto3" json:"" bexpr:"-"`
	// Proxy is the configuration set for Kind = connect-proxy. It is mandatory in
	// that case and an error to be set for any other kind. This config is part of
	// a proxy service definition and is distinct from but shares some fields with
	// the Connect.Proxy which configures a managed proxy as part of the actual
	// service's definition. This duplication is ugly but seemed better than the
	// alternative which was to re-use the same struct fields for both cases even
	// though the semantics are different and the non-shred fields make no sense
	// in the other case. ProxyConfig may be a more natural name here, but it's
	// confusing for the UX because one of the fields in ConnectProxyConfig is
	// also called just "Config"
	Proxy ConnectProxyConfig `protobuf:"bytes,11,opt,name=Proxy,proto3" json:"Proxy"`
	// Connect are the Connect settings for a service. This is purposely NOT
	// a pointer so that we never have to nil-check this.
	Connect ServiceConnect `protobuf:"bytes,12,opt,name=Connect,proto3" json:"Connect"`
	// LocallyRegisteredAsSidecar is private as it is only used by a local agent
	// state to track if the service was registered from a nested sidecar_service
	// block. We need to track that so we can know whether we need to deregister
	// it automatically too if it's removed from the service definition or if the
	// parent service is deregistered. Relying only on ID would cause us to
	// deregister regular services if they happen to be registered using the same
	// ID scheme as our sidecars do by default. We could use meta but that gets
	// unpleasant because we can't use the consul- prefix from an agent (reserved
	// for use internally but in practice that means within the state store or in
	// responses only), and it leaks the detail publicly which people might rely
	// on which is a bit unpleasant for something that is meant to be config-file
	// syntax sugar. Note this is not translated to ServiceNode and friends and
	// may not be set on a NodeService that isn't the one the agent registered and
	// keeps in it's local state. We never want this rendered in JSON as it's
	// internal only. Right now our agent endpoints return api structs which don't
	// include it but this is a safety net incase we change that or there is
	// somewhere this is used in API output.
	LocallyRegisteredAsSidecar bool `protobuf:"varint,13,opt,name=LocallyRegisteredAsSidecar,proto3" json:"LocallyRegisteredAsSidecar,omitempty" bexpr:"-"`
	RaftIndex                  `protobuf:"bytes,14,opt,name=RaftIndex,proto3,embedded=RaftIndex" json:"RaftIndex" bexpr:"-"`
}

func (m *NodeService) Reset()         { *m = NodeService{} }
func (m *NodeService) String() string { return proto.CompactTextString(m) }
func (*NodeService) ProtoMessage()    {}
func (*NodeService) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{6}
}
func (m *NodeService) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeService) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeService.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeService) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeService.Merge(m, src)
}
func (m *NodeService) XXX_Size() int {
	return m.Size()
}
func (m *NodeService) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeService.DiscardUnknown(m)
}

var xxx_messageInfo_NodeService proto.InternalMessageInfo

// ConnectProxyConfig describes the configuration needed for any proxy managed
// or unmanaged. It describes a single logical service's listener and optionally
// upstreams and sidecar-related config for a single instance. To describe a
// centralized proxy that routed traffic for multiple services, a different one
// of these would be needed for each, sharing the same LogicalProxyID.
type ConnectProxyConfig struct {
	// DestinationServiceName is required and is the name of the service to accept
	// traffic for.
	DestinationServiceName string `protobuf:"bytes,1,opt,name=DestinationServiceName,proto3" json:"DestinationServiceName,omitempty"`
	// DestinationServiceID is optional and should only be specified for
	// "side-car" style proxies where the proxy is in front of just a single
	// instance of the service. It should be set to the service ID of the instance
	// being represented which must be registered to the same agent. It's valid to
	// provide a service ID that does not yet exist to avoid timing issues when
	// bootstrapping a service with a proxy.
	DestinationServiceID string `protobuf:"bytes,2,opt,name=DestinationServiceID,proto3" json:"DestinationServiceID,omitempty"`
	// LocalServiceAddress is the address of the local service instance. It is
	// optional and should only be specified for "side-car" style proxies. It will
	// default to 127.0.0.1 if the proxy is a "side-car" (DestinationServiceID is
	// set) but otherwise will be ignored.
	LocalServiceAddress string `protobuf:"bytes,3,opt,name=LocalServiceAddress,proto3" json:"LocalServiceAddress,omitempty"`
	// LocalServicePort is the port of the local service instance. It is optional
	// and should only be specified for "side-car" style proxies. It will default
	// to the registered port for the instance if the proxy is a "side-car"
	// (DestinationServiceID is set) but otherwise will be ignored.
	LocalServicePort int `protobuf:"varint,4,opt,name=LocalServicePort,proto3,casttype=int" json:"LocalServicePort,omitempty"`
	// Config is the arbitrary configuration data provided with the proxy
	// registration.
	Config UntypedMap `protobuf:"bytes,5,opt,name=Config,proto3,customtype=UntypedMap" json:"Config" bexpr:"-"`
	// Upstreams describes any upstream dependencies the proxy instance should
	// setup.
	Upstreams []Upstream `protobuf:"bytes,6,rep,name=Upstreams,proto3" json:"Upstreams"`
	// MeshGateway defines the mesh gateway configuration for this upstream
	MeshGateway *MeshGatewayConfig `protobuf:"bytes,7,opt,name=MeshGateway,proto3" json:"MeshGateway,omitempty"`
}

func (m *ConnectProxyConfig) Reset()         { *m = ConnectProxyConfig{} }
func (m *ConnectProxyConfig) String() string { return proto.CompactTextString(m) }
func (*ConnectProxyConfig) ProtoMessage()    {}
func (*ConnectProxyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{7}
}
func (m *ConnectProxyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectProxyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectProxyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectProxyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectProxyConfig.Merge(m, src)
}
func (m *ConnectProxyConfig) XXX_Size() int {
	return m.Size()
}
func (m *ConnectProxyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectProxyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectProxyConfig proto.InternalMessageInfo

// Upstream represents a single upstream dependency for a service or proxy. It
// describes the mechanism used to discover instances to communicate with (the
// Target) as well as any potential client configuration that may be useful such
// as load balancer options, timeouts etc.
type Upstream struct {
	// Destination fields are the required ones for determining what this upstream
	// points to. Depending on DestinationType some other fields below might
	// further restrict the set of instances allowable.
	//
	// DestinationType would be better as an int constant but even with custom
	// JSON marshallers it causes havoc with all the mapstructure mangling we do
	// on service definitions in various places.
	DestinationType      string `protobuf:"bytes,1,opt,name=DestinationType,proto3" json:"DestinationType,omitempty"`
	DestinationNamespace string `protobuf:"bytes,2,opt,name=DestinationNamespace,proto3" json:"DestinationNamespace,omitempty"`
	DestinationName      string `protobuf:"bytes,3,opt,name=DestinationName,proto3" json:"DestinationName,omitempty"`
	// Datacenter that the service discovery request should be run against. Note
	// for prepared queries, the actual results might be from a different
	// datacenter.
	Datacenter string `protobuf:"bytes,4,opt,name=Datacenter,proto3" json:"Datacenter,omitempty"`
	// LocalBindAddress is the ip address a side-car proxy should listen on for
	// traffic destined for this upstream service. Default if empty is 127.0.0.1.
	LocalBindAddress string `protobuf:"bytes,5,opt,name=LocalBindAddress,proto3" json:"LocalBindAddress,omitempty"`
	// LocalBindPort is the ip address a side-car proxy should listen on for
	// traffic
	// destined for this upstream service. Required.
	LocalBindPort int `protobuf:"varint,6,opt,name=LocalBindPort,proto3,casttype=int" json:"LocalBindPort,omitempty"`
	// Config is an opaque config that is specific to the proxy process being run.
	// It can be used to pass arbitrary configuration for this specific upstream
	// to the proxy.
	Config UntypedMap `protobuf:"bytes,7,opt,name=Config,proto3,customtype=UntypedMap" json:"Config" bexpr:"-"`
	// MeshGateway is the configuration for mesh gateway usage of this upstream
	MeshGateway *MeshGatewayConfig `protobuf:"bytes,8,opt,name=MeshGateway,proto3" json:"MeshGateway,omitempty"`
}

func (m *Upstream) Reset()         { *m = Upstream{} }
func (m *Upstream) String() string { return proto.CompactTextString(m) }
func (*Upstream) ProtoMessage()    {}
func (*Upstream) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{8}
}
func (m *Upstream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Upstream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Upstream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Upstream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Upstream.Merge(m, src)
}
func (m *Upstream) XXX_Size() int {
	return m.Size()
}
func (m *Upstream) XXX_DiscardUnknown() {
	xxx_messageInfo_Upstream.DiscardUnknown(m)
}

var xxx_messageInfo_Upstream proto.InternalMessageInfo

// ServiceConnect are the shared Connect settings between all service
// definitions from the agent to the state store.
type ServiceConnect struct {
	// Native is true when this service can natively understand Connect.
	Native bool `protobuf:"varint,1,opt,name=Native,proto3" json:"Native,omitempty"`
	// Proxy configures a connect proxy instance for the service. This is
	// only used for agent service definitions and is invalid for non-agent
	// (catalog API) definitions.
	Proxy *ServiceDefinitionConnectProxy `protobuf:"bytes,2,opt,name=Proxy,proto3" json:"Proxy,omitempty" bexpr:"-"`
	// SidecarService is a nested Service Definition to register at the same time.
	// It's purely a convenience mechanism to allow specifying a sidecar service
	// along with the application service definition. It's nested nature allows
	// all of the fields to be defaulted which can reduce the amount of
	// boilerplate needed to register a sidecar service separately, but the end
	// result is identical to just making a second service registration via any
	// other means.
	SidecarService *ServiceDefinition `protobuf:"bytes,3,opt,name=SidecarService,proto3" json:"SidecarService,omitempty" bexpr:"-"`
}

func (m *ServiceConnect) Reset()         { *m = ServiceConnect{} }
func (m *ServiceConnect) String() string { return proto.CompactTextString(m) }
func (*ServiceConnect) ProtoMessage()    {}
func (*ServiceConnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{9}
}
func (m *ServiceConnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceConnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceConnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceConnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceConnect.Merge(m, src)
}
func (m *ServiceConnect) XXX_Size() int {
	return m.Size()
}
func (m *ServiceConnect) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceConnect.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceConnect proto.InternalMessageInfo

// ServiceDefinitionConnectProxy is the connect proxy config  within a service
// registration. Note this is duplicated in config.ServiceConnectProxy and needs
// to be kept in sync.
type ServiceDefinitionConnectProxy struct {
	Command   []string   `protobuf:"bytes,1,rep,name=Command,proto3" json:"Command,omitempty"`
	ExecMode  string     `protobuf:"bytes,2,opt,name=ExecMode,proto3" json:"ExecMode,omitempty"`
	Config    UntypedMap `protobuf:"bytes,3,opt,name=Config,proto3,customtype=UntypedMap" json:"Config"`
	Upstreams []Upstream `protobuf:"bytes,4,rep,name=Upstreams,proto3" json:"Upstreams"`
}

func (m *ServiceDefinitionConnectProxy) Reset()         { *m = ServiceDefinitionConnectProxy{} }
func (m *ServiceDefinitionConnectProxy) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinitionConnectProxy) ProtoMessage()    {}
func (*ServiceDefinitionConnectProxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{10}
}
func (m *ServiceDefinitionConnectProxy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinitionConnectProxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinitionConnectProxy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceDefinitionConnectProxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinitionConnectProxy.Merge(m, src)
}
func (m *ServiceDefinitionConnectProxy) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinitionConnectProxy) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinitionConnectProxy.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinitionConnectProxy proto.InternalMessageInfo

// RaftIndex is used to track the index used while creating
// or modifying a given struct type.
type RaftIndex struct {
	CreateIndex uint64 `protobuf:"varint,1,opt,name=CreateIndex,proto3" json:"CreateIndex,omitempty"`
	ModifyIndex uint64 `protobuf:"varint,2,opt,name=ModifyIndex,proto3" json:"ModifyIndex,omitempty"`
}

func (m *RaftIndex) Reset()         { *m = RaftIndex{} }
func (m *RaftIndex) String() string { return proto.CompactTextString(m) }
func (*RaftIndex) ProtoMessage()    {}
func (*RaftIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{11}
}
func (m *RaftIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftIndex.Merge(m, src)
}
func (m *RaftIndex) XXX_Size() int {
	return m.Size()
}
func (m *RaftIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftIndex.DiscardUnknown(m)
}

var xxx_messageInfo_RaftIndex proto.InternalMessageInfo

// Weights represent the weight used by DNS for a given status
type Weights struct {
	Passing int `protobuf:"varint,1,opt,name=Passing,proto3,casttype=int" json:"Passing,omitempty"`
	Warning int `protobuf:"varint,2,opt,name=Warning,proto3,casttype=int" json:"Warning,omitempty"`
}

func (m *Weights) Reset()         { *m = Weights{} }
func (m *Weights) String() string { return proto.CompactTextString(m) }
func (*Weights) ProtoMessage()    {}
func (*Weights) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{12}
}
func (m *Weights) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Weights) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Weights.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Weights) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Weights.Merge(m, src)
}
func (m *Weights) XXX_Size() int {
	return m.Size()
}
func (m *Weights) XXX_DiscardUnknown() {
	xxx_messageInfo_Weights.DiscardUnknown(m)
}

var xxx_messageInfo_Weights proto.InternalMessageInfo

// CheckType is used to create either the CheckMonitor or the CheckTTL.
// The following types are supported: Script, HTTP, TCP, Docker, TTL, GRPC,
// Alias. Script,
// HTTP, Docker, TCP and GRPC all require Interval. Only one of the types may
// to be provided: TTL or Script/Interval or HTTP/Interval or TCP/Interval or
// Docker/Interval or GRPC/Interval or AliasService.
type CheckType struct {
	CheckID           github_com_hashicorp_consul_types.CheckID `protobuf:"bytes,1,opt,name=CheckID,proto3,casttype=github.com/hashicorp/consul/types.CheckID" json:""`
	Name              string                                    `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Status            string                                    `protobuf:"bytes,3,opt,name=Status,proto3" json:"Status,omitempty"`
	Notes             string                                    `protobuf:"bytes,4,opt,name=Notes,proto3" json:"Notes,omitempty"`
	ScriptArgs        []string                                  `protobuf:"bytes,5,rep,name=ScriptArgs,proto3" json:"ScriptArgs,omitempty"`
	HTTP              string                                    `protobuf:"bytes,6,opt,name=HTTP,proto3" json:"HTTP,omitempty"`
	Header            Headers                                   `protobuf:"bytes,20,opt,name=Header,proto3,customtype=Headers" json:"Header"`
	Method            string                                    `protobuf:"bytes,7,opt,name=Method,proto3" json:"Method,omitempty"`
	TCP               string                                    `protobuf:"bytes,8,opt,name=TCP,proto3" json:"TCP,omitempty"`
	Interval          time.Duration                             `protobuf:"bytes,9,opt,name=Interval,proto3,stdduration" json:"Interval"`
	AliasNode         string                                    `protobuf:"bytes,10,opt,name=AliasNode,proto3" json:"AliasNode,omitempty"`
	AliasService      string                                    `protobuf:"bytes,11,opt,name=AliasService,proto3" json:"AliasService,omitempty"`
	DockerContainerID string                                    `protobuf:"bytes,12,opt,name=DockerContainerID,proto3" json:"DockerContainerID,omitempty"`
	Shell             string                                    `protobuf:"bytes,13,opt,name=Shell,proto3" json:"Shell,omitempty"`
	GRPC              string                                    `protobuf:"bytes,14,opt,name=GRPC,proto3" json:"GRPC,omitempty"`
	GRPCUseTLS        bool                                      `protobuf:"varint,15,opt,name=GRPCUseTLS,proto3" json:"GRPCUseTLS,omitempty"`
	TLSSkipVerify     bool                                      `protobuf:"varint,16,opt,name=TLSSkipVerify,proto3" json:"TLSSkipVerify,omitempty"`
	Timeout           time.Duration                             `protobuf:"bytes,17,opt,name=Timeout,proto3,stdduration" json:"Timeout"`
	TTL               time.Duration                             `protobuf:"bytes,18,opt,name=TTL,proto3,stdduration" json:"TTL"`
	// DeregisterCriticalServiceAfter, if >0, will cause the associated
	// service, if any, to be deregistered if this check is critical for
	// longer than this duration.
	DeregisterCriticalServiceAfter time.Duration `protobuf:"bytes,19,opt,name=DeregisterCriticalServiceAfter,proto3,stdduration" json:"DeregisterCriticalServiceAfter"`
}

func (m *CheckType) Reset()         { *m = CheckType{} }
func (m *CheckType) String() string { return proto.CompactTextString(m) }
func (*CheckType) ProtoMessage()    {}
func (*CheckType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{13}
}
func (m *CheckType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckType.Merge(m, src)
}
func (m *CheckType) XXX_Size() int {
	return m.Size()
}
func (m *CheckType) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckType.DiscardUnknown(m)
}

var xxx_messageInfo_CheckType proto.InternalMessageInfo

type MeshGatewayConfig struct {
	Mode github_com_hashicorp_consul_agent_structs.MeshGatewayMode `protobuf:"bytes,1,opt,name=Mode,proto3,casttype=github.com/hashicorp/consul/agent/structs.MeshGatewayMode" json:"Mode,omitempty"`
}

func (m *MeshGatewayConfig) Reset()         { *m = MeshGatewayConfig{} }
func (m *MeshGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*MeshGatewayConfig) ProtoMessage()    {}
func (*MeshGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{14}
}
func (m *MeshGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeshGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeshGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeshGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeshGatewayConfig.Merge(m, src)
}
func (m *MeshGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *MeshGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MeshGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MeshGatewayConfig proto.InternalMessageInfo

type ProtoHeaders struct {
	Headers map[string]*StringList `protobuf:"bytes,1,rep,name=Headers,proto3" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ProtoHeaders) Reset()         { *m = ProtoHeaders{} }
func (m *ProtoHeaders) String() string { return proto.CompactTextString(m) }
func (*ProtoHeaders) ProtoMessage()    {}
func (*ProtoHeaders) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{15}
}
func (m *ProtoHeaders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoHeaders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoHeaders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoHeaders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoHeaders.Merge(m, src)
}
func (m *ProtoHeaders) XXX_Size() int {
	return m.Size()
}
func (m *ProtoHeaders) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoHeaders.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoHeaders proto.InternalMessageInfo

type StringList struct {
	Values []string `protobuf:"bytes,1,rep,name=Values,proto3" json:"Values,omitempty"`
}

func (m *StringList) Reset()         { *m = StringList{} }
func (m *StringList) String() string { return proto.CompactTextString(m) }
func (*StringList) ProtoMessage()    {}
func (*StringList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{16}
}
func (m *StringList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringList.Merge(m, src)
}
func (m *StringList) XXX_Size() int {
	return m.Size()
}
func (m *StringList) XXX_DiscardUnknown() {
	xxx_messageInfo_StringList.DiscardUnknown(m)
}

var xxx_messageInfo_StringList proto.InternalMessageInfo

// These ACL structs are incomplete for now, they're only used internally to
// notify listeners of an ACL update.
type ACLToken struct {
	// This is the UUID used for tracking and management purposes
	AccessorID string `protobuf:"bytes,1,opt,name=AccessorID,proto3" json:"AccessorID,omitempty"`
	// This is the UUID used as the api token by clients
	SecretID string `protobuf:"bytes,2,opt,name=SecretID,proto3" json:"SecretID,omitempty"`
}

func (m *ACLToken) Reset()         { *m = ACLToken{} }
func (m *ACLToken) String() string { return proto.CompactTextString(m) }
func (*ACLToken) ProtoMessage()    {}
func (*ACLToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{17}
}
func (m *ACLToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLToken.Merge(m, src)
}
func (m *ACLToken) XXX_Size() int {
	return m.Size()
}
func (m *ACLToken) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLToken.DiscardUnknown(m)
}

var xxx_messageInfo_ACLToken proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Node)(nil), "stream.Node")
	proto.RegisterMapType((map[string]string)(nil), "stream.Node.MetaEntry")
	proto.RegisterMapType((map[string]string)(nil), "stream.Node.TaggedAddressesEntry")
	proto.RegisterType((*ServiceDefinition)(nil), "stream.ServiceDefinition")
	proto.RegisterMapType((map[string]string)(nil), "stream.ServiceDefinition.MetaEntry")
	proto.RegisterMapType((map[string]*ServiceAddress)(nil), "stream.ServiceDefinition.TaggedAddressesEntry")
	proto.RegisterType((*ServiceAddress)(nil), "stream.ServiceAddress")
	proto.RegisterType((*HealthCheck)(nil), "stream.HealthCheck")
	proto.RegisterType((*HealthCheckDefinition)(nil), "stream.HealthCheckDefinition")
	proto.RegisterType((*CheckServiceNode)(nil), "stream.CheckServiceNode")
	proto.RegisterType((*NodeService)(nil), "stream.NodeService")
	proto.RegisterMapType((map[string]string)(nil), "stream.NodeService.MetaEntry")
	proto.RegisterMapType((map[string]*ServiceAddress)(nil), "stream.NodeService.TaggedAddressesEntry")
	proto.RegisterType((*ConnectProxyConfig)(nil), "stream.ConnectProxyConfig")
	proto.RegisterType((*Upstream)(nil), "stream.Upstream")
	proto.RegisterType((*ServiceConnect)(nil), "stream.ServiceConnect")
	proto.RegisterType((*ServiceDefinitionConnectProxy)(nil), "stream.ServiceDefinitionConnectProxy")
	proto.RegisterType((*RaftIndex)(nil), "stream.RaftIndex")
	proto.RegisterType((*Weights)(nil), "stream.Weights")
	proto.RegisterType((*CheckType)(nil), "stream.CheckType")
	proto.RegisterType((*MeshGatewayConfig)(nil), "stream.MeshGatewayConfig")
	proto.RegisterType((*ProtoHeaders)(nil), "stream.ProtoHeaders")
	proto.RegisterMapType((map[string]*StringList)(nil), "stream.ProtoHeaders.HeadersEntry")
	proto.RegisterType((*StringList)(nil), "stream.StringList")
	proto.RegisterType((*ACLToken)(nil), "stream.ACLToken")
}

func init() { proto.RegisterFile("structs.proto", fileDescriptor_e774e8f5f348d14d) }

var fileDescriptor_e774e8f5f348d14d = []byte{
	// 1906 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcb, 0x73, 0x1b, 0x49,
	0x19, 0xb7, 0x2c, 0x59, 0x8f, 0x4f, 0x7e, 0x76, 0xb2, 0xae, 0x41, 0x6c, 0x24, 0xed, 0xb0, 0x80,
	0x13, 0x62, 0x39, 0xeb, 0xdd, 0x4d, 0xd8, 0x5d, 0x52, 0x94, 0x25, 0x65, 0x1d, 0x13, 0x2b, 0x11,
	0x23, 0x65, 0x97, 0x82, 0x53, 0x7b, 0xd4, 0x96, 0xa6, 0x2c, 0xcf, 0xa8, 0x66, 0x5a, 0x26, 0x3a,
	0xf3, 0x0f, 0x6c, 0x15, 0x97, 0x2d, 0x38, 0xf3, 0x37, 0x70, 0xe5, 0x44, 0xe5, 0x18, 0x38, 0x51,
	0x1c, 0x04, 0x24, 0xb7, 0x1c, 0x39, 0xfa, 0x44, 0xf5, 0x6b, 0xd4, 0xa3, 0x51, 0x6c, 0x39, 0xe4,
	0xb0, 0x17, 0x7b, 0xbe, 0xa7, 0x7a, 0xfa, 0x7b, 0xfd, 0xbe, 0x81, 0x95, 0x80, 0xfa, 0x43, 0x9b,
	0x06, 0x95, 0x81, 0xef, 0x51, 0x0f, 0xa5, 0x03, 0xea, 0x13, 0x7c, 0x5a, 0x28, 0x76, 0x3d, 0xaf,
	0xdb, 0x27, 0x3b, 0x9c, 0x7b, 0x34, 0x3c, 0xde, 0xe9, 0x0c, 0x7d, 0x4c, 0x1d, 0xcf, 0x15, 0x7a,
	0x85, 0xed, 0xae, 0x43, 0x7b, 0xc3, 0xa3, 0x8a, 0xed, 0x9d, 0xee, 0x74, 0xbd, 0xae, 0x37, 0x51,
	0x64, 0x14, 0x27, 0xf8, 0x93, 0x50, 0x37, 0x5f, 0x24, 0x21, 0xf5, 0xd8, 0xeb, 0x10, 0xf4, 0x33,
	0x58, 0x3c, 0xa8, 0x1b, 0x89, 0x72, 0x62, 0x2b, 0x57, 0xbd, 0x7d, 0x3e, 0x2e, 0x6d, 0x69, 0x7e,
	0x7a, 0x38, 0xe8, 0x39, 0xb6, 0xe7, 0x0f, 0x76, 0x6c, 0xcf, 0x0d, 0x86, 0xfd, 0x1d, 0x3a, 0x1a,
	0x90, 0xa0, 0xc2, 0xec, 0x0e, 0xea, 0xd6, 0xe2, 0x41, 0x1d, 0x21, 0xe1, 0xc5, 0x58, 0x64, 0xf6,
	0x96, 0xf0, 0x68, 0x40, 0x66, 0xaf, 0xd3, 0xf1, 0x49, 0x10, 0x18, 0x49, 0xce, 0x56, 0x24, 0x2a,
	0x02, 0xd4, 0x31, 0xc5, 0x36, 0x71, 0x29, 0xf1, 0x8d, 0x14, 0x17, 0x6a, 0x1c, 0xf4, 0x08, 0xd6,
	0xda, 0xb8, 0xdb, 0x25, 0x1d, 0x69, 0x40, 0x02, 0x63, 0xa9, 0x9c, 0xdc, 0xca, 0xef, 0x7e, 0x50,
	0x11, 0xb7, 0xc0, 0x7f, 0xba, 0x32, 0xa5, 0xf3, 0xc0, 0xa5, 0xfe, 0xc8, 0x9a, 0xb6, 0x44, 0xb7,
	0x20, 0xd5, 0x20, 0x14, 0x1b, 0x69, 0xee, 0x61, 0x33, 0xe2, 0x81, 0x09, 0x84, 0x19, 0xd7, 0x41,
	0x5f, 0x42, 0xce, 0xc2, 0xc7, 0xf4, 0xc0, 0xed, 0x90, 0x67, 0x46, 0xa6, 0x9c, 0xd8, 0xca, 0xef,
	0x6e, 0x28, 0x83, 0x50, 0x50, 0x7d, 0xef, 0xf9, 0xb8, 0xb4, 0xf0, 0x62, 0x5c, 0x4a, 0xfc, 0x77,
	0x5c, 0xca, 0x1d, 0x91, 0x67, 0x03, 0xff, 0x73, 0x73, 0xdb, 0xb4, 0x26, 0xa6, 0x85, 0x2a, 0x5c,
	0x9f, 0x75, 0x38, 0xb4, 0x0e, 0xc9, 0x13, 0x32, 0x12, 0xb7, 0x6c, 0xb1, 0x47, 0x74, 0x1d, 0x96,
	0xce, 0x70, 0x7f, 0xa8, 0x6e, 0x4e, 0x10, 0x9f, 0x2f, 0xfe, 0x34, 0x51, 0xb8, 0x07, 0xb9, 0xf0,
	0x78, 0x57, 0x31, 0x34, 0xff, 0x9e, 0x86, 0x8d, 0x16, 0xf1, 0xcf, 0x1c, 0x9b, 0xd4, 0xc9, 0xb1,
	0xe3, 0x3a, 0x2c, 0x3b, 0x50, 0x03, 0x52, 0x8f, 0x1c, 0xb7, 0x23, 0x23, 0xfc, 0xd9, 0xf9, 0xb8,
	0xf4, 0xe9, 0x45, 0x11, 0xc6, 0x5d, 0xe2, 0xd2, 0x1d, 0x95, 0x82, 0xd2, 0x1d, 0x73, 0x60, 0x71,
	0x37, 0x68, 0x95, 0xa7, 0x8b, 0xf8, 0x6d, 0x95, 0x00, 0xf8, 0x94, 0xc8, 0x48, 0xf3, 0x67, 0xc6,
	0x6b, 0xe3, 0x6e, 0x60, 0xa4, 0xca, 0x49, 0xc6, 0x63, 0xcf, 0x7a, 0x52, 0x2c, 0x45, 0x93, 0xe2,
	0x57, 0xf1, 0xa0, 0xaf, 0xf3, 0x90, 0x55, 0x54, 0x04, 0x62, 0x2f, 0x35, 0x67, 0x06, 0xdc, 0x8b,
	0x64, 0xc0, 0x0f, 0xde, 0xec, 0x6e, 0x3a, 0x1d, 0xbe, 0x0f, 0xa9, 0xa6, 0xe7, 0x53, 0x9e, 0x09,
	0x4b, 0xd5, 0xcc, 0xf9, 0xb8, 0x94, 0x74, 0x5c, 0x6a, 0x71, 0x26, 0xda, 0x86, 0xa5, 0x5a, 0x8f,
	0xd8, 0x27, 0x46, 0x36, 0x9a, 0x27, 0x9c, 0xd9, 0x1e, 0x0d, 0x48, 0x35, 0xc5, 0xf2, 0xc4, 0x12,
	0x5a, 0xe8, 0x26, 0xa4, 0xf9, 0x43, 0x60, 0xe4, 0xf8, 0x31, 0xe2, 0xfa, 0x96, 0x54, 0x40, 0x37,
	0x21, 0xf3, 0x35, 0x71, 0xba, 0x3d, 0x1a, 0x18, 0xc0, 0x7d, 0xaf, 0x29, 0x5d, 0xc9, 0xb6, 0x94,
	0x9c, 0x65, 0x41, 0xdb, 0x3b, 0x21, 0xae, 0x91, 0x17, 0x59, 0xc0, 0x09, 0x74, 0x1b, 0x36, 0x1e,
	0xb8, 0xf8, 0xa8, 0x4f, 0xda, 0xb8, 0xfb, 0xe4, 0x8c, 0xf8, 0xbe, 0xd3, 0x21, 0xc6, 0x72, 0x39,
	0xb1, 0x95, 0xb5, 0xe2, 0x02, 0x74, 0x0b, 0xd6, 0x9b, 0xbe, 0xf7, 0x6c, 0x54, 0x27, 0x01, 0x75,
	0x5c, 0xde, 0x4b, 0x8c, 0x15, 0xee, 0x2e, 0xc6, 0x47, 0x77, 0x60, 0x89, 0xf3, 0x8c, 0x55, 0x7e,
	0xb0, 0x42, 0xf8, 0x12, 0x9e, 0xeb, 0x12, 0x9b, 0x72, 0x59, 0xcd, 0x73, 0x8f, 0x9d, 0xae, 0x25,
	0x14, 0xd1, 0x1d, 0xc8, 0x48, 0xa1, 0xb1, 0xc6, 0x6d, 0x36, 0xa7, 0xee, 0x5f, 0x4a, 0x2d, 0xa5,
	0x56, 0xf8, 0xf5, 0xdc, 0xc5, 0x73, 0x5b, 0xaf, 0x81, 0xb8, 0x67, 0x69, 0xff, 0x4e, 0x8a, 0x6a,
	0x1f, 0x56, 0xa3, 0x5e, 0xf5, 0x4c, 0x4e, 0x44, 0x33, 0x59, 0xa5, 0xcd, 0xe2, 0x8c, 0xb4, 0x31,
	0xff, 0x92, 0x84, 0xfc, 0x43, 0x82, 0xfb, 0xb4, 0x27, 0xf2, 0x42, 0x75, 0xce, 0x84, 0xd6, 0x39,
	0xf7, 0x21, 0xc3, 0x85, 0xaa, 0xc2, 0xaa, 0xdb, 0xe7, 0xe3, 0xd2, 0xcd, 0xcb, 0x1b, 0xb2, 0x34,
	0xb2, 0x94, 0xf5, 0xcc, 0xaa, 0xdc, 0x84, 0x74, 0x8b, 0x62, 0x3a, 0x0c, 0x64, 0xe3, 0x95, 0x14,
	0x7b, 0xf7, 0xc7, 0x1e, 0x25, 0xaa, 0x2e, 0x05, 0xc1, 0xb4, 0x9f, 0x0c, 0xe9, 0x60, 0x48, 0x8d,
	0xb4, 0xd0, 0x16, 0x14, 0x7a, 0x1f, 0x72, 0xf2, 0x3e, 0x0e, 0xea, 0xbc, 0x3e, 0x72, 0xd6, 0x84,
	0x81, 0xca, 0x90, 0x97, 0x04, 0xff, 0xf9, 0x2c, 0x97, 0xeb, 0x2c, 0x4d, 0x83, 0xb7, 0x88, 0x1c,
	0x6f, 0x11, 0x3a, 0x0b, 0x35, 0x01, 0x26, 0xa5, 0x29, 0x0b, 0xe1, 0x86, 0x8a, 0xb0, 0x76, 0x83,
	0x13, 0xa5, 0xea, 0x06, 0x2b, 0xb8, 0x68, 0x53, 0xd6, 0x7c, 0x44, 0xbb, 0x7b, 0xfe, 0xad, 0xbb,
	0xbb, 0xf9, 0xb7, 0x24, 0xbc, 0x37, 0xf3, 0x00, 0xc8, 0x84, 0xd4, 0xc3, 0x76, 0xbb, 0x29, 0x9b,
	0xec, 0xea, 0xeb, 0x71, 0x09, 0x6e, 0x7b, 0xa7, 0x0e, 0x25, 0xa7, 0x03, 0x3a, 0xb2, 0xb8, 0x0c,
	0x7d, 0x02, 0x2b, 0xed, 0xc3, 0x56, 0xeb, 0xc4, 0x19, 0x7c, 0x45, 0x7c, 0xe7, 0x78, 0xc4, 0x43,
	0x9c, 0x8d, 0x29, 0x47, 0x95, 0xd0, 0x8f, 0x21, 0xfd, 0x90, 0xe0, 0x0e, 0xf1, 0x79, 0x2c, 0x97,
	0xab, 0x6b, 0xec, 0x94, 0xff, 0x1c, 0x97, 0x32, 0x82, 0x1b, 0x58, 0x52, 0x8c, 0x7e, 0x04, 0xe9,
	0x06, 0xa1, 0x3d, 0xaf, 0x23, 0xc2, 0x1b, 0xf3, 0x2b, 0xa5, 0xa8, 0x0c, 0xc9, 0x76, 0xad, 0x29,
	0x82, 0x1d, 0x53, 0x62, 0x22, 0xf4, 0x73, 0xc8, 0x1e, 0xb0, 0x71, 0x7c, 0x86, 0xfb, 0x3c, 0xf8,
	0xf9, 0xdd, 0xef, 0x55, 0x04, 0xf8, 0xa8, 0x28, 0x4c, 0x51, 0xa9, 0x4b, 0xf0, 0x51, 0xcd, 0xb2,
	0xf3, 0x7c, 0xfb, 0xaf, 0x52, 0xc2, 0x0a, 0x8d, 0xd0, 0x7d, 0xc8, 0xb4, 0x9d, 0x53, 0xe2, 0x0d,
	0xa9, 0x9c, 0xa5, 0x73, 0xd9, 0x2b, 0x1b, 0x74, 0x02, 0xc5, 0x3a, 0xf1, 0x49, 0xd7, 0x09, 0x28,
	0xf1, 0x6b, 0xbe, 0x43, 0x1d, 0x1b, 0xf7, 0x55, 0x11, 0x1e, 0x33, 0xe4, 0x90, 0x9d, 0xdf, 0xeb,
	0x25, 0xae, 0xcc, 0x6f, 0x12, 0xb0, 0xce, 0xa3, 0xa9, 0x92, 0x94, 0xd5, 0x61, 0x59, 0xab, 0xcd,
	0xfc, 0xee, 0xb2, 0x0e, 0x1d, 0x64, 0xa5, 0x6e, 0x43, 0x46, 0x1a, 0xc8, 0x1e, 0x74, 0x4d, 0x57,
	0x92, 0x22, 0x4b, 0xe9, 0xa0, 0x9f, 0x84, 0x43, 0x20, 0xc9, 0x87, 0xc0, 0xb5, 0x19, 0xf9, 0xac,
	0xc6, 0x80, 0xf9, 0x87, 0x0c, 0xe4, 0x35, 0x2f, 0xe8, 0x37, 0x91, 0x09, 0xbe, 0x1f, 0x0d, 0xd9,
	0xbb, 0x9e, 0xe7, 0xc6, 0xe4, 0xc5, 0x24, 0x78, 0x53, 0xc7, 0xb8, 0xda, 0x54, 0xb7, 0xe2, 0x53,
	0x7d, 0x8d, 0xbf, 0xfa, 0xd6, 0x8c, 0x8b, 0x9a, 0x73, 0x9e, 0x7f, 0x14, 0x99, 0xe7, 0x37, 0x66,
	0x39, 0xba, 0xd2, 0x24, 0xd7, 0xe6, 0x6d, 0xf6, 0x92, 0x79, 0x3b, 0x73, 0xb2, 0xe6, 0xde, 0x34,
	0x59, 0xef, 0xcf, 0x98, 0xac, 0xc0, 0xa3, 0xb7, 0xf1, 0x3a, 0xd6, 0xa9, 0xe2, 0xc3, 0xf6, 0xae,
	0x1a, 0xb6, 0xf9, 0xcb, 0x86, 0xad, 0x82, 0x1a, 0x62, 0xe4, 0xde, 0x9d, 0x8c, 0xdc, 0xe5, 0x8b,
	0x46, 0xae, 0xb4, 0x52, 0xca, 0xa8, 0x01, 0x85, 0x43, 0xcf, 0xc6, 0xfd, 0xfe, 0xc8, 0x92, 0xa5,
	0x42, 0x3a, 0x7b, 0x41, 0xcb, 0xe9, 0x10, 0x1b, 0xfb, 0x1c, 0x12, 0x64, 0xab, 0x2b, 0xd1, 0x43,
	0x5f, 0x60, 0x10, 0x6d, 0xb7, 0xab, 0x6f, 0x0f, 0xa6, 0xbf, 0x93, 0x78, 0xe0, 0xf7, 0x49, 0x40,
	0xf1, 0x38, 0xa0, 0xbb, 0xb0, 0xa9, 0x45, 0x50, 0x9f, 0x81, 0xc2, 0xeb, 0x1b, 0xa4, 0x68, 0x17,
	0xae, 0xc7, 0x25, 0x61, 0x41, 0xce, 0x94, 0xa1, 0x3b, 0x70, 0x8d, 0xdf, 0x7e, 0xf4, 0xed, 0x64,
	0xb9, 0xce, 0x12, 0xa1, 0x8f, 0x61, 0x5d, 0x67, 0xf3, 0x8a, 0x48, 0x45, 0x2b, 0x22, 0xa6, 0x80,
	0xee, 0x41, 0x5a, 0xbc, 0x1c, 0x2f, 0xed, 0xe5, 0x6a, 0x49, 0x4e, 0x1e, 0x78, 0xea, 0x32, 0xd4,
	0xd1, 0x69, 0xe0, 0x41, 0x34, 0x74, 0x52, 0x1d, 0x7d, 0x02, 0xb9, 0xa7, 0x03, 0x11, 0x81, 0x40,
	0xd6, 0xea, 0xba, 0x8a, 0x88, 0x12, 0xc8, 0x14, 0x9c, 0x28, 0xa2, 0x2f, 0x20, 0xdf, 0x20, 0x41,
	0x6f, 0x1f, 0x53, 0xf2, 0x5b, 0x3c, 0x0a, 0x07, 0x87, 0xb4, 0xd3, 0x44, 0x12, 0x66, 0xea, 0xda,
	0xe6, 0xef, 0x92, 0x90, 0x55, 0xae, 0xd0, 0x16, 0xac, 0x69, 0xf7, 0xc6, 0x10, 0xb6, 0x0c, 0xc2,
	0x34, 0x7b, 0xea, 0xf6, 0x59, 0x40, 0x82, 0x01, 0xb6, 0xc9, 0x8c, 0xdb, 0x0f, 0x65, 0x53, 0xde,
	0x35, 0x94, 0x35, 0xcd, 0xbe, 0x74, 0xdb, 0xbd, 0x25, 0xa3, 0x52, 0x75, 0xdc, 0x4e, 0xb4, 0x8b,
	0xc6, 0xf8, 0x68, 0x1b, 0x56, 0x42, 0x1e, 0x0f, 0x5f, 0x3a, 0x1a, 0xbe, 0xa8, 0x54, 0x8b, 0x5d,
	0xe6, 0x6a, 0xb1, 0x9b, 0x8a, 0x42, 0xf6, 0x4a, 0x51, 0xf8, 0x6b, 0x22, 0x04, 0xcb, 0xaa, 0xb5,
	0x6c, 0x42, 0xfa, 0x31, 0xa6, 0xce, 0x99, 0x08, 0x41, 0xd6, 0x92, 0x14, 0xfa, 0x85, 0x6a, 0x71,
	0xa2, 0x62, 0x7f, 0xf8, 0xc6, 0xdd, 0x4c, 0xaf, 0xb5, 0xe9, 0x26, 0x24, 0xdb, 0x5e, 0x13, 0x56,
	0x65, 0xeb, 0xd1, 0x27, 0x97, 0x76, 0xec, 0x98, 0xd3, 0x69, 0x47, 0x53, 0xf6, 0xe6, 0x9f, 0x13,
	0x70, 0xe3, 0xc2, 0x93, 0xb0, 0xc1, 0x57, 0xf3, 0x4e, 0x4f, 0x31, 0x1f, 0xcb, 0x6c, 0x1e, 0x2a,
	0x12, 0x15, 0x20, 0xfb, 0xe0, 0x19, 0xb1, 0x1b, 0x93, 0xaf, 0x22, 0x21, 0x8d, 0x6e, 0x85, 0x61,
	0x11, 0x60, 0x0e, 0xc5, 0xc3, 0x32, 0xbb, 0x8a, 0x52, 0x73, 0x56, 0x91, 0xf9, 0x44, 0xeb, 0xbd,
	0x0c, 0x6b, 0xd7, 0x7c, 0x82, 0x29, 0x11, 0xad, 0x98, 0x45, 0x20, 0x65, 0xe9, 0x2c, 0xa6, 0xd1,
	0xf0, 0x3a, 0xce, 0xf1, 0x48, 0x68, 0x2c, 0x0a, 0x0d, 0x8d, 0x65, 0x3e, 0x09, 0x67, 0x24, 0xfa,
	0x00, 0x32, 0x4d, 0x1c, 0x04, 0x8e, 0xdb, 0xe5, 0xae, 0xb4, 0xec, 0x53, 0x7c, 0xa6, 0xf2, 0x35,
	0xf6, 0x5d, 0xa6, 0x32, 0xb5, 0x04, 0x29, 0xbe, 0xf9, 0xa7, 0x34, 0xe4, 0xc2, 0xd5, 0x17, 0x3d,
	0x9a, 0x6c, 0x3c, 0x02, 0xde, 0x7c, 0xc4, 0x06, 0xe4, 0xff, 0xb9, 0xf5, 0x2c, 0xce, 0xdc, 0x7a,
	0x92, 0xb3, 0xb7, 0x9e, 0x94, 0xbe, 0xf5, 0x14, 0x01, 0x5a, 0xb6, 0xef, 0x0c, 0xe8, 0x9e, 0xdf,
	0x15, 0xdf, 0x9e, 0x72, 0x96, 0xc6, 0x61, 0xbf, 0xc0, 0x71, 0xbe, 0xd8, 0x89, 0x04, 0xae, 0x9f,
	0x20, 0xf4, 0xeb, 0x17, 0x23, 0xf4, 0xcd, 0x10, 0xa1, 0x8b, 0xbd, 0x49, 0x21, 0xf2, 0x75, 0x81,
	0xc8, 0xc5, 0xb2, 0x14, 0x43, 0xe0, 0xb9, 0xb7, 0x41, 0xe0, 0xef, 0x43, 0x6e, 0xaf, 0xef, 0xe0,
	0x80, 0xa3, 0x58, 0x10, 0x5b, 0x5a, 0xc8, 0x40, 0x26, 0x2c, 0x73, 0x42, 0x95, 0x8b, 0xf8, 0x86,
	0x10, 0xe1, 0x31, 0xc0, 0x53, 0xf7, 0xec, 0x13, 0xe2, 0xd7, 0x3c, 0x97, 0x62, 0xc7, 0x25, 0xfe,
	0x41, 0x9d, 0xa3, 0x8a, 0x9c, 0x15, 0x17, 0xb0, 0xdb, 0x6c, 0xf5, 0x48, 0xbf, 0x2f, 0xbf, 0x1f,
	0x08, 0x82, 0xdd, 0xd6, 0xbe, 0xd5, 0xac, 0x71, 0x0c, 0x90, 0xb3, 0xf8, 0x33, 0xbb, 0x61, 0xf6,
	0xff, 0x69, 0x40, 0xda, 0x87, 0x2d, 0xfe, 0x65, 0x20, 0x6b, 0x69, 0x1c, 0xf4, 0xe1, 0xf4, 0x96,
	0xb4, 0xce, 0x55, 0xa6, 0xb6, 0x22, 0x6d, 0xc3, 0xd8, 0x78, 0x8b, 0x0d, 0xe3, 0x53, 0x48, 0xb6,
	0xdb, 0x87, 0x06, 0x9a, 0xdf, 0x94, 0xe9, 0xcf, 0xb1, 0x98, 0x5c, 0x7b, 0x77, 0x8b, 0xc9, 0x31,
	0x6c, 0xc4, 0xda, 0x2d, 0xfa, 0x25, 0xa4, 0x1a, 0xe1, 0x47, 0x83, 0xea, 0xfd, 0xf3, 0x71, 0xe9,
	0xb3, 0xf9, 0xc1, 0xbf, 0xe6, 0xae, 0xc1, 0x37, 0x19, 0xf6, 0xd7, 0xfc, 0x63, 0x02, 0x96, 0x9b,
	0xec, 0x9c, 0x32, 0x5d, 0xd1, 0x17, 0xa0, 0x32, 0x97, 0xb7, 0x36, 0xed, 0xe3, 0xab, 0xae, 0x56,
	0x91, 0xff, 0x05, 0xd8, 0x56, 0x16, 0x85, 0xc7, 0xb0, 0xac, 0x0b, 0x66, 0x40, 0xab, 0xad, 0x28,
	0x56, 0x43, 0x61, 0x93, 0xa6, 0xbe, 0xe3, 0x76, 0x0f, 0x9d, 0x80, 0xea, 0x70, 0xeb, 0x43, 0x80,
	0x89, 0x80, 0x55, 0xd0, 0x57, 0x4c, 0x14, 0xc8, 0xa6, 0x2b, 0x29, 0xf3, 0x4b, 0xc8, 0xee, 0xd5,
	0x0e, 0xc5, 0x37, 0xb0, 0x22, 0xc0, 0x9e, 0x6d, 0x93, 0x20, 0xf0, 0x7c, 0xd5, 0x54, 0x2c, 0x8d,
	0xc3, 0xfa, 0x73, 0x8b, 0xd8, 0x3e, 0xa1, 0x21, 0xca, 0x0a, 0xe9, 0x6a, 0xf9, 0xf9, 0x7f, 0x8a,
	0x0b, 0xcf, 0x5f, 0x16, 0x13, 0x2f, 0x5e, 0x16, 0x13, 0xff, 0x7e, 0x59, 0x4c, 0x7c, 0xf3, 0xaa,
	0xb8, 0xf0, 0xed, 0xab, 0xe2, 0xc2, 0x8b, 0x57, 0xc5, 0x85, 0x7f, 0xbc, 0x2a, 0x2e, 0x1c, 0xa5,
	0x79, 0x48, 0x3f, 0xfe, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1e, 0xdd, 0x3a, 0xe2, 0xa5, 0x17,
	0x00, 0x00,
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RaftIndex.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.Meta) > 0 {
		for k := range m.Meta {
			v := m.Meta[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStructs(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TaggedAddresses) > 0 {
		for k := range m.TaggedAddresses {
			v := m.TaggedAddresses[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStructs(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Datacenter) > 0 {
		i -= len(m.Datacenter)
		copy(dAtA[i:], m.Datacenter)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Datacenter)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TaggedAddresses) > 0 {
		for k := range m.TaggedAddresses {
			v := m.TaggedAddresses[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintStructs(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStructs(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Connect != nil {
		{
			size, err := m.Connect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Proxy != nil {
		{
			size, err := m.Proxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.ProxyDestination) > 0 {
		i -= len(m.ProxyDestination)
		copy(dAtA[i:], m.ProxyDestination)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ProxyDestination)))
		i--
		dAtA[i] = 0x6a
	}
	if m.EnableTagOverride {
		i--
		if m.EnableTagOverride {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Weights != nil {
		{
			size, err := m.Weights.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Checks) > 0 {
		for iNdEx := len(m.Checks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Checks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStructs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.Check.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.Port != 0 {
		i = encodeVarintStructs(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Meta) > 0 {
		for k := range m.Meta {
			v := m.Meta[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStructs(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintStructs(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintStructs(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RaftIndex.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.Definition.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.ServiceTags) > 0 {
		for iNdEx := len(m.ServiceTags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ServiceTags[iNdEx])
			copy(dAtA[i:], m.ServiceTags[iNdEx])
			i = encodeVarintStructs(dAtA, i, uint64(len(m.ServiceTags[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ServiceID) > 0 {
		i -= len(m.ServiceID)
		copy(dAtA[i:], m.ServiceID)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ServiceID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Output) > 0 {
		i -= len(m.Output)
		copy(dAtA[i:], m.Output)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Output)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CheckID) > 0 {
		i -= len(m.CheckID)
		copy(dAtA[i:], m.CheckID)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.CheckID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HealthCheckDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheckDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n9, err9 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.DeregisterCriticalServiceAfter, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintStructs(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x42
	n10, err10 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Timeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintStructs(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x3a
	n11, err11 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Interval, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintStructs(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x32
	if len(m.TCP) > 0 {
		i -= len(m.TCP)
		copy(dAtA[i:], m.TCP)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.TCP)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Header.Size()
		i -= size
		if _, err := m.Header.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.TLSSkipVerify {
		i--
		if m.TLSSkipVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.HTTP) > 0 {
		i -= len(m.HTTP)
		copy(dAtA[i:], m.HTTP)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.HTTP)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckServiceNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckServiceNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckServiceNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Checks) > 0 {
		for iNdEx := len(m.Checks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Checks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStructs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TaggedAddresses) > 0 {
		for k := range m.TaggedAddresses {
			v := m.TaggedAddresses[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintStructs(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStructs(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7a
		}
	}
	{
		size, err := m.RaftIndex.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	if m.LocallyRegisteredAsSidecar {
		i--
		if m.LocallyRegisteredAsSidecar {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	{
		size, err := m.Connect.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.Proxy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if len(m.ProxyDestination) > 0 {
		i -= len(m.ProxyDestination)
		copy(dAtA[i:], m.ProxyDestination)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ProxyDestination)))
		i--
		dAtA[i] = 0x52
	}
	if m.EnableTagOverride {
		i--
		if m.EnableTagOverride {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Weights != nil {
		{
			size, err := m.Weights.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Port != 0 {
		i = encodeVarintStructs(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Meta) > 0 {
		for k := range m.Meta {
			v := m.Meta[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStructs(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintStructs(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Service) > 0 {
		i -= len(m.Service)
		copy(dAtA[i:], m.Service)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Service)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConnectProxyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectProxyConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectProxyConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MeshGateway != nil {
		{
			size, err := m.MeshGateway.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Upstreams) > 0 {
		for iNdEx := len(m.Upstreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Upstreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStructs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size := m.Config.Size()
		i -= size
		if _, err := m.Config.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.LocalServicePort != 0 {
		i = encodeVarintStructs(dAtA, i, uint64(m.LocalServicePort))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LocalServiceAddress) > 0 {
		i -= len(m.LocalServiceAddress)
		copy(dAtA[i:], m.LocalServiceAddress)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.LocalServiceAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DestinationServiceID) > 0 {
		i -= len(m.DestinationServiceID)
		copy(dAtA[i:], m.DestinationServiceID)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationServiceID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DestinationServiceName) > 0 {
		i -= len(m.DestinationServiceName)
		copy(dAtA[i:], m.DestinationServiceName)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationServiceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Upstream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Upstream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Upstream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MeshGateway != nil {
		{
			size, err := m.MeshGateway.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.Config.Size()
		i -= size
		if _, err := m.Config.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.LocalBindPort != 0 {
		i = encodeVarintStructs(dAtA, i, uint64(m.LocalBindPort))
		i--
		dAtA[i] = 0x30
	}
	if len(m.LocalBindAddress) > 0 {
		i -= len(m.LocalBindAddress)
		copy(dAtA[i:], m.LocalBindAddress)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.LocalBindAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Datacenter) > 0 {
		i -= len(m.Datacenter)
		copy(dAtA[i:], m.Datacenter)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Datacenter)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DestinationName) > 0 {
		i -= len(m.DestinationName)
		copy(dAtA[i:], m.DestinationName)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DestinationNamespace) > 0 {
		i -= len(m.DestinationNamespace)
		copy(dAtA[i:], m.DestinationNamespace)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationNamespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DestinationType) > 0 {
		i -= len(m.DestinationType)
		copy(dAtA[i:], m.DestinationType)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceConnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceConnect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceConnect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SidecarService != nil {
		{
			size, err := m.SidecarService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Proxy != nil {
		{
			size, err := m.Proxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Native {
		i--
		if m.Native {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceDefinitionConnectProxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinitionConnectProxy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceDefinitionConnectProxy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Upstreams) > 0 {
		for iNdEx := len(m.Upstreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Upstreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStructs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size := m.Config.Size()
		i -= size
		if _, err := m.Config.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ExecMode) > 0 {
		i -= len(m.ExecMode)
		copy(dAtA[i:], m.ExecMode)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ExecMode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintStructs(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RaftIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModifyIndex != 0 {
		i = encodeVarintStructs(dAtA, i, uint64(m.ModifyIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.CreateIndex != 0 {
		i = encodeVarintStructs(dAtA, i, uint64(m.CreateIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Weights) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Weights) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Weights) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Warning != 0 {
		i = encodeVarintStructs(dAtA, i, uint64(m.Warning))
		i--
		dAtA[i] = 0x10
	}
	if m.Passing != 0 {
		i = encodeVarintStructs(dAtA, i, uint64(m.Passing))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Header.Size()
		i -= size
		if _, err := m.Header.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStructs(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	n23, err23 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.DeregisterCriticalServiceAfter, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter):])
	if err23 != nil {
		return 0, err23
	}
	i -= n23
	i = encodeVarintStructs(dAtA, i, uint64(n23))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	n24, err24 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TTL, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.TTL):])
	if err24 != nil {
		return 0, err24
	}
	i -= n24
	i = encodeVarintStructs(dAtA, i, uint64(n24))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	n25, err25 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Timeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout):])
	if err25 != nil {
		return 0, err25
	}
	i -= n25
	i = encodeVarintStructs(dAtA, i, uint64(n25))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.TLSSkipVerify {
		i--
		if m.TLSSkipVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.GRPCUseTLS {
		i--
		if m.GRPCUseTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.GRPC) > 0 {
		i -= len(m.GRPC)
		copy(dAtA[i:], m.GRPC)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.GRPC)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Shell) > 0 {
		i -= len(m.Shell)
		copy(dAtA[i:], m.Shell)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Shell)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.DockerContainerID) > 0 {
		i -= len(m.DockerContainerID)
		copy(dAtA[i:], m.DockerContainerID)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DockerContainerID)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.AliasService) > 0 {
		i -= len(m.AliasService)
		copy(dAtA[i:], m.AliasService)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.AliasService)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.AliasNode) > 0 {
		i -= len(m.AliasNode)
		copy(dAtA[i:], m.AliasNode)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.AliasNode)))
		i--
		dAtA[i] = 0x52
	}
	n26, err26 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Interval, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval):])
	if err26 != nil {
		return 0, err26
	}
	i -= n26
	i = encodeVarintStructs(dAtA, i, uint64(n26))
	i--
	dAtA[i] = 0x4a
	if len(m.TCP) > 0 {
		i -= len(m.TCP)
		copy(dAtA[i:], m.TCP)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.TCP)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.HTTP) > 0 {
		i -= len(m.HTTP)
		copy(dAtA[i:], m.HTTP)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.HTTP)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ScriptArgs) > 0 {
		for iNdEx := len(m.ScriptArgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ScriptArgs[iNdEx])
			copy(dAtA[i:], m.ScriptArgs[iNdEx])
			i = encodeVarintStructs(dAtA, i, uint64(len(m.ScriptArgs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CheckID) > 0 {
		i -= len(m.CheckID)
		copy(dAtA[i:], m.CheckID)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.CheckID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MeshGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeshGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeshGatewayConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtoHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoHeaders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoHeaders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for k := range m.Headers {
			v := m.Headers[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintStructs(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStructs(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintStructs(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ACLToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ACLToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SecretID) > 0 {
		i -= len(m.SecretID)
		copy(dAtA[i:], m.SecretID)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.SecretID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccessorID) > 0 {
		i -= len(m.AccessorID)
		copy(dAtA[i:], m.AccessorID)
		i = encodeVarintStructs(dAtA, i, uint64(len(m.AccessorID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintStructs(dAtA []byte, offset int, v uint64) int {
	offset -= sovStructs(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.TaggedAddresses) > 0 {
		for k, v := range m.TaggedAddresses {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	l = m.RaftIndex.Size()
	n += 1 + l + sovStructs(uint64(l))
	return n
}

func (m *ServiceDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	if m.Port != 0 {
		n += 1 + sovStructs(uint64(m.Port))
	}
	l = m.Check.Size()
	n += 1 + l + sovStructs(uint64(l))
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	if m.Weights != nil {
		l = m.Weights.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.EnableTagOverride {
		n += 2
	}
	l = len(m.ProxyDestination)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.Proxy != nil {
		l = m.Proxy.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.Connect != nil {
		l = m.Connect.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.TaggedAddresses) > 0 {
		for k, v := range m.TaggedAddresses {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStructs(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovStructs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ServiceAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovStructs(uint64(m.Port))
	}
	return n
}

func (m *HealthCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.CheckID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ServiceID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.ServiceTags) > 0 {
		for _, s := range m.ServiceTags {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = m.Definition.Size()
	n += 1 + l + sovStructs(uint64(l))
	l = m.RaftIndex.Size()
	n += 1 + l + sovStructs(uint64(l))
	return n
}

func (m *HealthCheckDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HTTP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.TLSSkipVerify {
		n += 2
	}
	l = m.Header.Size()
	n += 1 + l + sovStructs(uint64(l))
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.TCP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval)
	n += 1 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)
	n += 1 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter)
	n += 1 + l + sovStructs(uint64(l))
	return n
}

func (m *CheckServiceNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	return n
}

func (m *NodeService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	if m.Port != 0 {
		n += 1 + sovStructs(uint64(m.Port))
	}
	if m.Weights != nil {
		l = m.Weights.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.EnableTagOverride {
		n += 2
	}
	l = len(m.ProxyDestination)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = m.Proxy.Size()
	n += 1 + l + sovStructs(uint64(l))
	l = m.Connect.Size()
	n += 1 + l + sovStructs(uint64(l))
	if m.LocallyRegisteredAsSidecar {
		n += 2
	}
	l = m.RaftIndex.Size()
	n += 1 + l + sovStructs(uint64(l))
	if len(m.TaggedAddresses) > 0 {
		for k, v := range m.TaggedAddresses {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStructs(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ConnectProxyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DestinationServiceName)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DestinationServiceID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.LocalServiceAddress)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.LocalServicePort != 0 {
		n += 1 + sovStructs(uint64(m.LocalServicePort))
	}
	l = m.Config.Size()
	n += 1 + l + sovStructs(uint64(l))
	if len(m.Upstreams) > 0 {
		for _, e := range m.Upstreams {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	if m.MeshGateway != nil {
		l = m.MeshGateway.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *Upstream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DestinationType)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DestinationNamespace)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DestinationName)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.LocalBindAddress)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.LocalBindPort != 0 {
		n += 1 + sovStructs(uint64(m.LocalBindPort))
	}
	l = m.Config.Size()
	n += 1 + l + sovStructs(uint64(l))
	if m.MeshGateway != nil {
		l = m.MeshGateway.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *ServiceConnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Native {
		n += 2
	}
	if m.Proxy != nil {
		l = m.Proxy.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.SidecarService != nil {
		l = m.SidecarService.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *ServiceDefinitionConnectProxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.ExecMode)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = m.Config.Size()
	n += 1 + l + sovStructs(uint64(l))
	if len(m.Upstreams) > 0 {
		for _, e := range m.Upstreams {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	return n
}

func (m *RaftIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateIndex != 0 {
		n += 1 + sovStructs(uint64(m.CreateIndex))
	}
	if m.ModifyIndex != 0 {
		n += 1 + sovStructs(uint64(m.ModifyIndex))
	}
	return n
}

func (m *Weights) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Passing != 0 {
		n += 1 + sovStructs(uint64(m.Passing))
	}
	if m.Warning != 0 {
		n += 1 + sovStructs(uint64(m.Warning))
	}
	return n
}

func (m *CheckType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CheckID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.ScriptArgs) > 0 {
		for _, s := range m.ScriptArgs {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.HTTP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.TCP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval)
	n += 1 + l + sovStructs(uint64(l))
	l = len(m.AliasNode)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.AliasService)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DockerContainerID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Shell)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.GRPC)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.GRPCUseTLS {
		n += 2
	}
	if m.TLSSkipVerify {
		n += 3
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)
	n += 2 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TTL)
	n += 2 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter)
	n += 2 + l + sovStructs(uint64(l))
	l = m.Header.Size()
	n += 2 + l + sovStructs(uint64(l))
	return n
}

func (m *MeshGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *ProtoHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStructs(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *StringList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	return n
}

func (m *ACLToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessorID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.SecretID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func sovStructs(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStructs(x uint64) (n int) {
	return sovStructs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = github_com_hashicorp_consul_types.NodeID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaggedAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaggedAddresses == nil {
				m.TaggedAddresses = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TaggedAddresses[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = github_com_hashicorp_consul_agent_structs.ServiceKind(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Check.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &CheckType{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weights == nil {
				m.Weights = &Weights{}
			}
			if err := m.Weights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTagOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableTagOverride = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyDestination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyDestination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proxy == nil {
				m.Proxy = &ConnectProxyConfig{}
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connect == nil {
				m.Connect = &ServiceConnect{}
			}
			if err := m.Connect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaggedAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaggedAddresses == nil {
				m.TaggedAddresses = make(map[string]*ServiceAddress)
			}
			var mapkey string
			var mapvalue *ServiceAddress
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStructs
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStructs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ServiceAddress{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TaggedAddresses[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckID = github_com_hashicorp_consul_types.CheckID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceTags = append(m.ServiceTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSSkipVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLSSkipVerify = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Interval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeregisterCriticalServiceAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.DeregisterCriticalServiceAfter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckServiceNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckServiceNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckServiceNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &Node{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &NodeService{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &HealthCheck{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeService) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = github_com_hashicorp_consul_agent_structs.ServiceKind(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weights == nil {
				m.Weights = &Weights{}
			}
			if err := m.Weights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTagOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableTagOverride = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyDestination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyDestination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Connect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocallyRegisteredAsSidecar", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocallyRegisteredAsSidecar = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaggedAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaggedAddresses == nil {
				m.TaggedAddresses = make(map[string]*ServiceAddress)
			}
			var mapkey string
			var mapvalue *ServiceAddress
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStructs
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStructs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ServiceAddress{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TaggedAddresses[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectProxyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectProxyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectProxyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationServiceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationServiceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalServiceAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalServiceAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalServicePort", wireType)
			}
			m.LocalServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalServicePort |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Upstreams = append(m.Upstreams, Upstream{})
			if err := m.Upstreams[len(m.Upstreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeshGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeshGateway == nil {
				m.MeshGateway = &MeshGatewayConfig{}
			}
			if err := m.MeshGateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Upstream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Upstream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Upstream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalBindAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalBindAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalBindPort", wireType)
			}
			m.LocalBindPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalBindPort |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeshGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeshGateway == nil {
				m.MeshGateway = &MeshGatewayConfig{}
			}
			if err := m.MeshGateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceConnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceConnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceConnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Native", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Native = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proxy == nil {
				m.Proxy = &ServiceDefinitionConnectProxy{}
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SidecarService == nil {
				m.SidecarService = &ServiceDefinition{}
			}
			if err := m.SidecarService.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinitionConnectProxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceDefinitionConnectProxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceDefinitionConnectProxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Upstreams = append(m.Upstreams, Upstream{})
			if err := m.Upstreams[len(m.Upstreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateIndex", wireType)
			}
			m.CreateIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifyIndex", wireType)
			}
			m.ModifyIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifyIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Weights) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Weights: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Weights: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passing", wireType)
			}
			m.Passing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Passing |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warning", wireType)
			}
			m.Warning = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Warning |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckID = github_com_hashicorp_consul_types.CheckID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptArgs = append(m.ScriptArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Interval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerContainerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerContainerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shell", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shell = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GRPC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPCUseTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GRPCUseTLS = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSSkipVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLSSkipVerify = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeregisterCriticalServiceAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.DeregisterCriticalServiceAfter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeshGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeshGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeshGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = github_com_hashicorp_consul_agent_structs.MeshGatewayMode(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoHeaders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoHeaders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoHeaders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]*StringList)
			}
			var mapkey string
			var mapvalue *StringList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStructs
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStructs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StringList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACLToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACLToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStructs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStructs
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthStructs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStructs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthStructs
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStructs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStructs   = fmt.Errorf("proto: integer overflow")
)

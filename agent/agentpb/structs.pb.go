// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: structs.proto

package agentpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	github_com_hashicorp_consul_agent_structs "github.com/hashicorp/consul/agent/structs"
	github_com_hashicorp_consul_types "github.com/hashicorp/consul/types"
	io "io"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Used to return information about a node
type Node struct {
	ID              github_com_hashicorp_consul_types.NodeID `protobuf:"bytes,1,opt,name=ID,proto3,casttype=github.com/hashicorp/consul/types.NodeID" json:"ID,omitempty"`
	Node            string                                   `protobuf:"bytes,2,opt,name=Node,proto3" json:"Node,omitempty"`
	Address         string                                   `protobuf:"bytes,3,opt,name=Address,proto3" json:"Address,omitempty"`
	Datacenter      string                                   `protobuf:"bytes,4,opt,name=Datacenter,proto3" json:"Datacenter,omitempty"`
	TaggedAddresses map[string]string                        `protobuf:"bytes,5,rep,name=TaggedAddresses,proto3" json:"TaggedAddresses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Meta            map[string]string                        `protobuf:"bytes,6,rep,name=Meta,proto3" json:"Meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RaftIndex       `protobuf:"bytes,7,opt,name=RaftIndex,proto3,embedded=RaftIndex" json:"RaftIndex" bexpr:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{0}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

// ServiceDefinition is used to JSON decode the Service definitions. For
// documentation on specific fields see NodeService which is better documented.
type ServiceDefinition struct {
	Kind              github_com_hashicorp_consul_agent_structs.ServiceKind `protobuf:"bytes,1,opt,name=Kind,proto3,casttype=github.com/hashicorp/consul/agent/structs.ServiceKind" json:"Kind,omitempty"`
	ID                string                                                `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Name              string                                                `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Tags              []string                                              `protobuf:"bytes,4,rep,name=Tags,proto3" json:"Tags,omitempty"`
	Address           string                                                `protobuf:"bytes,5,opt,name=Address,proto3" json:"Address,omitempty"`
	TaggedAddresses   map[string]*ServiceAddress                            `protobuf:"bytes,16,rep,name=TaggedAddresses,proto3" json:"TaggedAddresses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Meta              map[string]string                                     `protobuf:"bytes,6,rep,name=Meta,proto3" json:"Meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Port              int                                                   `protobuf:"varint,7,opt,name=Port,proto3,casttype=int" json:"Port,omitempty"`
	Check             CheckType                                             `protobuf:"bytes,8,opt,name=Check,proto3" json:"Check"`
	Checks            []*CheckType                                          `protobuf:"bytes,9,rep,name=Checks,proto3" json:"Checks,omitempty"`
	Weights           *Weights                                              `protobuf:"bytes,10,opt,name=Weights,proto3" json:"Weights,omitempty"`
	Token             string                                                `protobuf:"bytes,11,opt,name=Token,proto3" json:"Token,omitempty"`
	EnableTagOverride bool                                                  `protobuf:"varint,12,opt,name=EnableTagOverride,proto3" json:"EnableTagOverride,omitempty"`
	// Proxy is the configuration set for Kind = connect-proxy. It is mandatory in
	// that case and an error to be set for any other kind. This config is part of
	// a proxy service definition and is distinct from but shares some fields with
	// the Connect.Proxy which configures a managed proxy as part of the actual
	// service's definition. This duplication is ugly but seemed better than the
	// alternative which was to re-use the same struct fields for both cases even
	// though the semantics are different and the non-shared fields make no sense
	// in the other case. ProxyConfig may be a more natural name here, but it's
	// confusing for the UX because one of the fields in ConnectProxyConfig is
	// also called just "Config"
	Proxy          *ConnectProxyConfig `protobuf:"bytes,14,opt,name=Proxy,proto3" json:"Proxy,omitempty"`
	EnterpriseMeta *EnterpriseMeta     `protobuf:"bytes,17,opt,name=EnterpriseMeta,proto3" json:"EnterpriseMeta,omitempty"`
	Connect        *ServiceConnect     `protobuf:"bytes,15,opt,name=Connect,proto3" json:"Connect,omitempty"`
}

func (m *ServiceDefinition) Reset()         { *m = ServiceDefinition{} }
func (m *ServiceDefinition) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinition) ProtoMessage()    {}
func (*ServiceDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{1}
}
func (m *ServiceDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinition.Merge(m, src)
}
func (m *ServiceDefinition) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinition proto.InternalMessageInfo

// Type to hold an address and port of a service
type ServiceAddress struct {
	Address string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	Port    int    `protobuf:"varint,2,opt,name=Port,proto3,casttype=int" json:"Port,omitempty"`
}

func (m *ServiceAddress) Reset()         { *m = ServiceAddress{} }
func (m *ServiceAddress) String() string { return proto.CompactTextString(m) }
func (*ServiceAddress) ProtoMessage()    {}
func (*ServiceAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{2}
}
func (m *ServiceAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceAddress.Merge(m, src)
}
func (m *ServiceAddress) XXX_Size() int {
	return m.Size()
}
func (m *ServiceAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceAddress.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceAddress proto.InternalMessageInfo

// HealthCheck represents a single check on a given node
type HealthCheck struct {
	Node           string                                    `protobuf:"bytes,1,opt,name=Node,proto3" json:"Node,omitempty"`
	CheckID        github_com_hashicorp_consul_types.CheckID `protobuf:"bytes,2,opt,name=CheckID,proto3,casttype=github.com/hashicorp/consul/types.CheckID" json:"CheckID,omitempty"`
	Name           string                                    `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Status         string                                    `protobuf:"bytes,4,opt,name=Status,proto3" json:"Status,omitempty"`
	Notes          string                                    `protobuf:"bytes,5,opt,name=Notes,proto3" json:"Notes,omitempty"`
	Output         string                                    `protobuf:"bytes,6,opt,name=Output,proto3" json:"Output,omitempty"`
	ServiceID      string                                    `protobuf:"bytes,7,opt,name=ServiceID,proto3" json:"ServiceID,omitempty"`
	ServiceName    string                                    `protobuf:"bytes,8,opt,name=ServiceName,proto3" json:"ServiceName,omitempty"`
	ServiceTags    []string                                  `protobuf:"bytes,9,rep,name=ServiceTags,proto3" json:"ServiceTags,omitempty"`
	Type           string                                    `protobuf:"bytes,12,opt,name=Type,proto3" json:"Type,omitempty"`
	Definition     HealthCheckDefinition                     `protobuf:"bytes,10,opt,name=Definition,proto3" json:"Definition" bexpr:"-"`
	EnterpriseMeta *EnterpriseMeta                           `protobuf:"bytes,13,opt,name=EnterpriseMeta,proto3" json:"EnterpriseMeta,omitempty"`
	RaftIndex      `protobuf:"bytes,11,opt,name=RaftIndex,proto3,embedded=RaftIndex" json:"RaftIndex" bexpr:"-"`
}

func (m *HealthCheck) Reset()         { *m = HealthCheck{} }
func (m *HealthCheck) String() string { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()    {}
func (*HealthCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{3}
}
func (m *HealthCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheck.Merge(m, src)
}
func (m *HealthCheck) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheck.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheck proto.InternalMessageInfo

type HeaderValue struct {
	Value []string `protobuf:"bytes,1,rep,name=Value,proto3" json:"Value,omitempty"`
}

func (m *HeaderValue) Reset()         { *m = HeaderValue{} }
func (m *HeaderValue) String() string { return proto.CompactTextString(m) }
func (*HeaderValue) ProtoMessage()    {}
func (*HeaderValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{4}
}
func (m *HeaderValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeaderValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeaderValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderValue.Merge(m, src)
}
func (m *HeaderValue) XXX_Size() int {
	return m.Size()
}
func (m *HeaderValue) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderValue.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderValue proto.InternalMessageInfo

type HealthCheckDefinition struct {
	HTTP                           string                 `protobuf:"bytes,1,opt,name=HTTP,proto3" json:",omitempty"`
	TLSSkipVerify                  bool                   `protobuf:"varint,2,opt,name=TLSSkipVerify,proto3" json:",omitempty"`
	Header                         map[string]HeaderValue `protobuf:"bytes,3,rep,name=Header,proto3" json:"Header" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Method                         string                 `protobuf:"bytes,4,opt,name=Method,proto3" json:",omitempty"`
	Body                           string                 `protobuf:"bytes,18,opt,name=Body,proto3" json:",omitempty"`
	TCP                            string                 `protobuf:"bytes,5,opt,name=TCP,proto3" json:",omitempty"`
	Interval                       time.Duration          `protobuf:"bytes,6,opt,name=Interval,proto3,stdduration" json:"Interval"`
	OutputMaxSize                  uint32                 `protobuf:"varint,9,opt,name=OutputMaxSize,proto3" json:"OutputMaxSize,omitempty"`
	Timeout                        time.Duration          `protobuf:"bytes,7,opt,name=Timeout,proto3,stdduration" json:"Timeout"`
	DeregisterCriticalServiceAfter time.Duration          `protobuf:"bytes,8,opt,name=DeregisterCriticalServiceAfter,proto3,stdduration" json:"DeregisterCriticalServiceAfter"`
	ScriptArgs                     []string               `protobuf:"bytes,10,rep,name=ScriptArgs,proto3" json:"ScriptArgs,omitempty"`
	DockerContainerID              string                 `protobuf:"bytes,11,opt,name=DockerContainerID,proto3" json:"DockerContainerID,omitempty"`
	Shell                          string                 `protobuf:"bytes,12,opt,name=Shell,proto3" json:"Shell,omitempty"`
	GRPC                           string                 `protobuf:"bytes,13,opt,name=GRPC,proto3" json:"GRPC,omitempty"`
	GRPCUseTLS                     bool                   `protobuf:"varint,14,opt,name=GRPCUseTLS,proto3" json:"GRPCUseTLS,omitempty"`
	AliasNode                      string                 `protobuf:"bytes,15,opt,name=AliasNode,proto3" json:"AliasNode,omitempty"`
	AliasService                   string                 `protobuf:"bytes,16,opt,name=AliasService,proto3" json:"AliasService,omitempty"`
	TTL                            time.Duration          `protobuf:"bytes,17,opt,name=TTL,proto3,stdduration" json:"TTL"`
}

func (m *HealthCheckDefinition) Reset()         { *m = HealthCheckDefinition{} }
func (m *HealthCheckDefinition) String() string { return proto.CompactTextString(m) }
func (*HealthCheckDefinition) ProtoMessage()    {}
func (*HealthCheckDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{5}
}
func (m *HealthCheckDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheckDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheckDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheckDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheckDefinition.Merge(m, src)
}
func (m *HealthCheckDefinition) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheckDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheckDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheckDefinition proto.InternalMessageInfo

// CheckServiceNode is used to provide the node, its service
// definition, as well as a HealthCheck that is associated.
type CheckServiceNode struct {
	Node    *Node          `protobuf:"bytes,1,opt,name=Node,proto3" json:"Node,omitempty"`
	Service *NodeService   `protobuf:"bytes,2,opt,name=Service,proto3" json:"Service,omitempty"`
	Checks  []*HealthCheck `protobuf:"bytes,3,rep,name=Checks,proto3" json:"Checks,omitempty"`
}

func (m *CheckServiceNode) Reset()         { *m = CheckServiceNode{} }
func (m *CheckServiceNode) String() string { return proto.CompactTextString(m) }
func (*CheckServiceNode) ProtoMessage()    {}
func (*CheckServiceNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{6}
}
func (m *CheckServiceNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckServiceNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckServiceNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckServiceNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckServiceNode.Merge(m, src)
}
func (m *CheckServiceNode) XXX_Size() int {
	return m.Size()
}
func (m *CheckServiceNode) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckServiceNode.DiscardUnknown(m)
}

var xxx_messageInfo_CheckServiceNode proto.InternalMessageInfo

// NodeService is a service provided by a node
type NodeService struct {
	// Kind is the kind of service this is. Different kinds of services may
	// have differing validation, DNS behavior, etc. An empty kind will default
	// to the Default kind. See ServiceKind for the full list of kinds.
	Kind              github_com_hashicorp_consul_agent_structs.ServiceKind `protobuf:"bytes,1,opt,name=Kind,proto3,casttype=github.com/hashicorp/consul/agent/structs.ServiceKind" json:",omitempty"`
	ID                string                                                `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Service           string                                                `protobuf:"bytes,3,opt,name=Service,proto3" json:"Service,omitempty"`
	Tags              []string                                              `protobuf:"bytes,4,rep,name=Tags,proto3" json:"Tags,omitempty"`
	Address           string                                                `protobuf:"bytes,5,opt,name=Address,proto3" json:"Address,omitempty"`
	TaggedAddresses   map[string]*ServiceAddress                            `protobuf:"bytes,15,rep,name=TaggedAddresses,proto3" json:"TaggedAddresses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Meta              map[string]string                                     `protobuf:"bytes,6,rep,name=Meta,proto3" json:"Meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Port              int                                                   `protobuf:"varint,7,opt,name=Port,proto3,casttype=int" json:"Port,omitempty"`
	Weights           *Weights                                              `protobuf:"bytes,8,opt,name=Weights,proto3" json:"Weights,omitempty"`
	EnableTagOverride bool                                                  `protobuf:"varint,9,opt,name=EnableTagOverride,proto3" json:"EnableTagOverride,omitempty"`
	// Proxy is the configuration set for Kind = connect-proxy. It is mandatory in
	// that case and an error to be set for any other kind. This config is part of
	// a proxy service definition and is distinct from but shares some fields with
	// the Connect.Proxy which configures a managed proxy as part of the actual
	// service's definition. This duplication is ugly but seemed better than the
	// alternative which was to re-use the same struct fields for both cases even
	// though the semantics are different and the non-shred fields make no sense
	// in the other case. ProxyConfig may be a more natural name here, but it's
	// confusing for the UX because one of the fields in ConnectProxyConfig is
	// also called just "Config"
	Proxy ConnectProxyConfig `protobuf:"bytes,11,opt,name=Proxy,proto3" json:"Proxy"`
	// Connect are the Connect settings for a service. This is purposely NOT
	// a pointer so that we never have to nil-check this.
	Connect ServiceConnect `protobuf:"bytes,12,opt,name=Connect,proto3" json:"Connect"`
	// LocallyRegisteredAsSidecar is private as it is only used by a local agent
	// state to track if the service was registered from a nested sidecar_service
	// block. We need to track that so we can know whether we need to deregister
	// it automatically too if it's removed from the service definition or if the
	// parent service is deregistered. Relying only on ID would cause us to
	// deregister regular services if they happen to be registered using the same
	// ID scheme as our sidecars do by default. We could use meta but that gets
	// unpleasant because we can't use the consul- prefix from an agent (reserved
	// for use internally but in practice that means within the state store or in
	// responses only), and it leaks the detail publicly which people might rely
	// on which is a bit unpleasant for something that is meant to be config-file
	// syntax sugar. Note this is not translated to ServiceNode and friends and
	// may not be set on a NodeService that isn't the one the agent registered and
	// keeps in it's local state. We never want this rendered in JSON as it's
	// internal only. Right now our agent endpoints return api structs which don't
	// include it but this is a safety net incase we change that or there is
	// somewhere this is used in API output.
	LocallyRegisteredAsSidecar bool            `protobuf:"varint,13,opt,name=LocallyRegisteredAsSidecar,proto3" json:"LocallyRegisteredAsSidecar,omitempty" bexpr:"-"`
	EnterpriseMeta             *EnterpriseMeta `protobuf:"bytes,16,opt,name=EnterpriseMeta,proto3" json:"EnterpriseMeta,omitempty"`
	RaftIndex                  `protobuf:"bytes,14,opt,name=RaftIndex,proto3,embedded=RaftIndex" json:"RaftIndex" bexpr:"-"`
}

func (m *NodeService) Reset()         { *m = NodeService{} }
func (m *NodeService) String() string { return proto.CompactTextString(m) }
func (*NodeService) ProtoMessage()    {}
func (*NodeService) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{7}
}
func (m *NodeService) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeService) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeService.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeService) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeService.Merge(m, src)
}
func (m *NodeService) XXX_Size() int {
	return m.Size()
}
func (m *NodeService) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeService.DiscardUnknown(m)
}

var xxx_messageInfo_NodeService proto.InternalMessageInfo

// ConnectProxyConfig describes the configuration needed for any proxy managed
// or unmanaged. It describes a single logical service's listener and optionally
// upstreams and sidecar-related config for a single instance. To describe a
// centralized proxy that routed traffic for multiple services, a different one
// of these would be needed for each, sharing the same LogicalProxyID.
type ConnectProxyConfig struct {
	// DestinationServiceName is required and is the name of the service to accept
	// traffic for.
	DestinationServiceName string `protobuf:"bytes,1,opt,name=DestinationServiceName,proto3" json:"DestinationServiceName,omitempty"`
	// DestinationServiceID is optional and should only be specified for
	// "side-car" style proxies where the proxy is in front of just a single
	// instance of the service. It should be set to the service ID of the instance
	// being represented which must be registered to the same agent. It's valid to
	// provide a service ID that does not yet exist to avoid timing issues when
	// bootstrapping a service with a proxy.
	DestinationServiceID string `protobuf:"bytes,2,opt,name=DestinationServiceID,proto3" json:"DestinationServiceID,omitempty"`
	// LocalServiceAddress is the address of the local service instance. It is
	// optional and should only be specified for "side-car" style proxies. It will
	// default to 127.0.0.1 if the proxy is a "side-car" (DestinationServiceID is
	// set) but otherwise will be ignored.
	LocalServiceAddress string `protobuf:"bytes,3,opt,name=LocalServiceAddress,proto3" json:"LocalServiceAddress,omitempty"`
	// LocalServicePort is the port of the local service instance. It is optional
	// and should only be specified for "side-car" style proxies. It will default
	// to the registered port for the instance if the proxy is a "side-car"
	// (DestinationServiceID is set) but otherwise will be ignored.
	LocalServicePort int `protobuf:"varint,4,opt,name=LocalServicePort,proto3,casttype=int" json:"LocalServicePort,omitempty"`
	// Config is the arbitrary configuration data provided with the proxy
	// registration.
	Config *types.Struct `protobuf:"bytes,5,opt,name=Config,proto3" json:"Config,omitempty" bexpr:"-"`
	// Upstreams describes any upstream dependencies the proxy instance should
	// setup.
	Upstreams []Upstream `protobuf:"bytes,6,rep,name=Upstreams,proto3" json:"Upstreams"`
	// MeshGateway defines the mesh gateway configuration for this upstream
	MeshGateway *MeshGatewayConfig `protobuf:"bytes,7,opt,name=MeshGateway,proto3" json:"MeshGateway,omitempty"`
	// Expose defines whether checks or paths are exposed through the proxy
	Expose *ExposeConfig `protobuf:"bytes,8,opt,name=Expose,proto3" json:"Expose,omitempty"`
}

func (m *ConnectProxyConfig) Reset()         { *m = ConnectProxyConfig{} }
func (m *ConnectProxyConfig) String() string { return proto.CompactTextString(m) }
func (*ConnectProxyConfig) ProtoMessage()    {}
func (*ConnectProxyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{8}
}
func (m *ConnectProxyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectProxyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectProxyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectProxyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectProxyConfig.Merge(m, src)
}
func (m *ConnectProxyConfig) XXX_Size() int {
	return m.Size()
}
func (m *ConnectProxyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectProxyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectProxyConfig proto.InternalMessageInfo

// Upstream represents a single upstream dependency for a service or proxy. It
// describes the mechanism used to discover instances to communicate with (the
// Target) as well as any potential client configuration that may be useful such
// as load balancer options, timeouts etc.
type Upstream struct {
	// Destination fields are the required ones for determining what this upstream
	// points to. Depending on DestinationType some other fields below might
	// further restrict the set of instances allowable.
	//
	// DestinationType would be better as an int constant but even with custom
	// JSON marshallers it causes havoc with all the mapstructure mangling we do
	// on service definitions in various places.
	DestinationType      string `protobuf:"bytes,1,opt,name=DestinationType,proto3" json:"DestinationType,omitempty"`
	DestinationNamespace string `protobuf:"bytes,2,opt,name=DestinationNamespace,proto3" json:"DestinationNamespace,omitempty"`
	DestinationName      string `protobuf:"bytes,3,opt,name=DestinationName,proto3" json:"DestinationName,omitempty"`
	// Datacenter that the service discovery request should be run against. Note
	// for prepared queries, the actual results might be from a different
	// datacenter.
	Datacenter string `protobuf:"bytes,4,opt,name=Datacenter,proto3" json:"Datacenter,omitempty"`
	// LocalBindAddress is the ip address a side-car proxy should listen on for
	// traffic destined for this upstream service. Default if empty is 127.0.0.1.
	LocalBindAddress string `protobuf:"bytes,5,opt,name=LocalBindAddress,proto3" json:"LocalBindAddress,omitempty"`
	// LocalBindPort is the ip address a side-car proxy should listen on for
	// traffic
	// destined for this upstream service. Required.
	LocalBindPort int `protobuf:"varint,6,opt,name=LocalBindPort,proto3,casttype=int" json:"LocalBindPort,omitempty"`
	// Config is an opaque config that is specific to the proxy process being run.
	// It can be used to pass arbitrary configuration for this specific upstream
	// to the proxy.
	Config *types.Struct `protobuf:"bytes,7,opt,name=Config,proto3" json:"Config,omitempty" bexpr:"-"`
	// MeshGateway is the configuration for mesh gateway usage of this upstream
	MeshGateway *MeshGatewayConfig `protobuf:"bytes,8,opt,name=MeshGateway,proto3" json:"MeshGateway,omitempty"`
}

func (m *Upstream) Reset()         { *m = Upstream{} }
func (m *Upstream) String() string { return proto.CompactTextString(m) }
func (*Upstream) ProtoMessage()    {}
func (*Upstream) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{9}
}
func (m *Upstream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Upstream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Upstream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Upstream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Upstream.Merge(m, src)
}
func (m *Upstream) XXX_Size() int {
	return m.Size()
}
func (m *Upstream) XXX_DiscardUnknown() {
	xxx_messageInfo_Upstream.DiscardUnknown(m)
}

var xxx_messageInfo_Upstream proto.InternalMessageInfo

// ServiceConnect are the shared Connect settings between all service
// definitions from the agent to the state store.
type ServiceConnect struct {
	// Native is true when this service can natively understand Connect.
	Native bool `protobuf:"varint,1,opt,name=Native,proto3" json:"Native,omitempty"`
	// SidecarService is a nested Service Definition to register at the same time.
	// It's purely a convenience mechanism to allow specifying a sidecar service
	// along with the application service definition. It's nested nature allows
	// all of the fields to be defaulted which can reduce the amount of
	// boilerplate needed to register a sidecar service separately, but the end
	// result is identical to just making a second service registration via any
	// other means.
	SidecarService *ServiceDefinition `protobuf:"bytes,3,opt,name=SidecarService,proto3" json:"SidecarService,omitempty" bexpr:"-"`
}

func (m *ServiceConnect) Reset()         { *m = ServiceConnect{} }
func (m *ServiceConnect) String() string { return proto.CompactTextString(m) }
func (*ServiceConnect) ProtoMessage()    {}
func (*ServiceConnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{10}
}
func (m *ServiceConnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceConnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceConnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceConnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceConnect.Merge(m, src)
}
func (m *ServiceConnect) XXX_Size() int {
	return m.Size()
}
func (m *ServiceConnect) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceConnect.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceConnect proto.InternalMessageInfo

// Weights represent the weight used by DNS for a given status
type Weights struct {
	Passing int `protobuf:"varint,1,opt,name=Passing,proto3,casttype=int" json:"Passing,omitempty"`
	Warning int `protobuf:"varint,2,opt,name=Warning,proto3,casttype=int" json:"Warning,omitempty"`
}

func (m *Weights) Reset()         { *m = Weights{} }
func (m *Weights) String() string { return proto.CompactTextString(m) }
func (*Weights) ProtoMessage()    {}
func (*Weights) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{11}
}
func (m *Weights) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Weights) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Weights.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Weights) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Weights.Merge(m, src)
}
func (m *Weights) XXX_Size() int {
	return m.Size()
}
func (m *Weights) XXX_DiscardUnknown() {
	xxx_messageInfo_Weights.DiscardUnknown(m)
}

var xxx_messageInfo_Weights proto.InternalMessageInfo

// ExposeConfig describes HTTP paths to expose through Envoy outside of Connect.
// Users can expose individual paths and/or all HTTP/GRPC paths for checks.
type ExposeConfig struct {
	// Checks defines whether paths associated with Consul checks will be exposed.
	// This flag triggers exposing all HTTP and GRPC check paths registered for the service.
	Checks bool `protobuf:"varint,1,opt,name=Checks,proto3" json:"Checks,omitempty"`
	// Paths is the list of paths exposed through the proxy.
	Paths []*ExposePath `protobuf:"bytes,2,rep,name=Paths,proto3" json:"Paths,omitempty"`
}

func (m *ExposeConfig) Reset()         { *m = ExposeConfig{} }
func (m *ExposeConfig) String() string { return proto.CompactTextString(m) }
func (*ExposeConfig) ProtoMessage()    {}
func (*ExposeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{12}
}
func (m *ExposeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExposeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExposeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExposeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExposeConfig.Merge(m, src)
}
func (m *ExposeConfig) XXX_Size() int {
	return m.Size()
}
func (m *ExposeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ExposeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ExposeConfig proto.InternalMessageInfo

type ExposePath struct {
	// ListenerPort defines the port of the proxy's listener for exposed paths.
	ListenerPort int32 `protobuf:"varint,1,opt,name=ListenerPort,proto3" json:"ListenerPort,omitempty"`
	// ExposePath is the path to expose through the proxy, ie. "/metrics."
	Path string `protobuf:"bytes,2,opt,name=Path,proto3" json:"Path,omitempty"`
	// LocalPathPort is the port that the service is listening on for the given path.
	LocalPathPort int32 `protobuf:"varint,3,opt,name=LocalPathPort,proto3" json:"LocalPathPort,omitempty"`
	// Protocol describes the upstream's service protocol.
	// Valid values are "http" and "http2", defaults to "http"
	Protocol string `protobuf:"bytes,4,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	// ParsedFromCheck is set if this path was parsed from a registered check
	ParsedFromCheck bool `protobuf:"varint,5,opt,name=ParsedFromCheck,proto3" json:"ParsedFromCheck,omitempty"`
}

func (m *ExposePath) Reset()         { *m = ExposePath{} }
func (m *ExposePath) String() string { return proto.CompactTextString(m) }
func (*ExposePath) ProtoMessage()    {}
func (*ExposePath) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{13}
}
func (m *ExposePath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExposePath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExposePath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExposePath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExposePath.Merge(m, src)
}
func (m *ExposePath) XXX_Size() int {
	return m.Size()
}
func (m *ExposePath) XXX_DiscardUnknown() {
	xxx_messageInfo_ExposePath.DiscardUnknown(m)
}

var xxx_messageInfo_ExposePath proto.InternalMessageInfo

// CheckType is used to create either the CheckMonitor or the CheckTTL.
// The following types are supported: Script, HTTP, TCP, Docker, TTL, GRPC,
// Alias. Script,
// HTTP, Docker, TCP and GRPC all require Interval. Only one of the types may
// to be provided: TTL or Script/Interval or HTTP/Interval or TCP/Interval or
// Docker/Interval or GRPC/Interval or AliasService.
type CheckType struct {
	CheckID                github_com_hashicorp_consul_types.CheckID `protobuf:"bytes,1,opt,name=CheckID,proto3,casttype=github.com/hashicorp/consul/types.CheckID" json:""`
	Name                   string                                    `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Status                 string                                    `protobuf:"bytes,3,opt,name=Status,proto3" json:"Status,omitempty"`
	Notes                  string                                    `protobuf:"bytes,4,opt,name=Notes,proto3" json:"Notes,omitempty"`
	ScriptArgs             []string                                  `protobuf:"bytes,5,rep,name=ScriptArgs,proto3" json:"ScriptArgs,omitempty"`
	HTTP                   string                                    `protobuf:"bytes,6,opt,name=HTTP,proto3" json:"HTTP,omitempty"`
	Header                 map[string]HeaderValue                    `protobuf:"bytes,20,rep,name=Header,proto3" json:"Header" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Method                 string                                    `protobuf:"bytes,7,opt,name=Method,proto3" json:"Method,omitempty"`
	Body                   string                                    `protobuf:"bytes,26,opt,name=Body,proto3" json:"Body,omitempty"`
	TCP                    string                                    `protobuf:"bytes,8,opt,name=TCP,proto3" json:"TCP,omitempty"`
	Interval               time.Duration                             `protobuf:"bytes,9,opt,name=Interval,proto3,stdduration" json:"Interval"`
	AliasNode              string                                    `protobuf:"bytes,10,opt,name=AliasNode,proto3" json:"AliasNode,omitempty"`
	AliasService           string                                    `protobuf:"bytes,11,opt,name=AliasService,proto3" json:"AliasService,omitempty"`
	DockerContainerID      string                                    `protobuf:"bytes,12,opt,name=DockerContainerID,proto3" json:"DockerContainerID,omitempty"`
	Shell                  string                                    `protobuf:"bytes,13,opt,name=Shell,proto3" json:"Shell,omitempty"`
	GRPC                   string                                    `protobuf:"bytes,14,opt,name=GRPC,proto3" json:"GRPC,omitempty"`
	GRPCUseTLS             bool                                      `protobuf:"varint,15,opt,name=GRPCUseTLS,proto3" json:"GRPCUseTLS,omitempty"`
	TLSSkipVerify          bool                                      `protobuf:"varint,16,opt,name=TLSSkipVerify,proto3" json:"TLSSkipVerify,omitempty"`
	Timeout                time.Duration                             `protobuf:"bytes,17,opt,name=Timeout,proto3,stdduration" json:"Timeout"`
	TTL                    time.Duration                             `protobuf:"bytes,18,opt,name=TTL,proto3,stdduration" json:"TTL"`
	SuccessBeforePassing   int32                                     `protobuf:"varint,21,opt,name=SuccessBeforePassing,proto3" json:"SuccessBeforePassing,omitempty"`
	FailuresBeforeCritical int32                                     `protobuf:"varint,22,opt,name=FailuresBeforeCritical,proto3" json:"FailuresBeforeCritical,omitempty"`
	// Definition fields used when exposing checks through a proxy
	ProxyHTTP string `protobuf:"bytes,23,opt,name=ProxyHTTP,proto3" json:"ProxyHTTP,omitempty"`
	ProxyGRPC string `protobuf:"bytes,24,opt,name=ProxyGRPC,proto3" json:"ProxyGRPC,omitempty"`
	// DeregisterCriticalServiceAfter, if >0, will cause the associated
	// service, if any, to be deregistered if this check is critical for
	// longer than this duration.
	DeregisterCriticalServiceAfter time.Duration `protobuf:"bytes,19,opt,name=DeregisterCriticalServiceAfter,proto3,stdduration" json:"DeregisterCriticalServiceAfter"`
	OutputMaxSize                  int32         `protobuf:"varint,25,opt,name=OutputMaxSize,proto3" json:"OutputMaxSize,omitempty"`
}

func (m *CheckType) Reset()         { *m = CheckType{} }
func (m *CheckType) String() string { return proto.CompactTextString(m) }
func (*CheckType) ProtoMessage()    {}
func (*CheckType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{14}
}
func (m *CheckType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckType.Merge(m, src)
}
func (m *CheckType) XXX_Size() int {
	return m.Size()
}
func (m *CheckType) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckType.DiscardUnknown(m)
}

var xxx_messageInfo_CheckType proto.InternalMessageInfo

type MeshGatewayConfig struct {
	Mode github_com_hashicorp_consul_agent_structs.MeshGatewayMode `protobuf:"bytes,1,opt,name=Mode,proto3,casttype=github.com/hashicorp/consul/agent/structs.MeshGatewayMode" json:"Mode,omitempty"`
}

func (m *MeshGatewayConfig) Reset()         { *m = MeshGatewayConfig{} }
func (m *MeshGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*MeshGatewayConfig) ProtoMessage()    {}
func (*MeshGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{15}
}
func (m *MeshGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeshGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeshGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeshGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeshGatewayConfig.Merge(m, src)
}
func (m *MeshGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *MeshGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MeshGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MeshGatewayConfig proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Node)(nil), "agentpb.Node")
	proto.RegisterMapType((map[string]string)(nil), "agentpb.Node.MetaEntry")
	proto.RegisterMapType((map[string]string)(nil), "agentpb.Node.TaggedAddressesEntry")
	proto.RegisterType((*ServiceDefinition)(nil), "agentpb.ServiceDefinition")
	proto.RegisterMapType((map[string]string)(nil), "agentpb.ServiceDefinition.MetaEntry")
	proto.RegisterMapType((map[string]*ServiceAddress)(nil), "agentpb.ServiceDefinition.TaggedAddressesEntry")
	proto.RegisterType((*ServiceAddress)(nil), "agentpb.ServiceAddress")
	proto.RegisterType((*HealthCheck)(nil), "agentpb.HealthCheck")
	proto.RegisterType((*HeaderValue)(nil), "agentpb.HeaderValue")
	proto.RegisterType((*HealthCheckDefinition)(nil), "agentpb.HealthCheckDefinition")
	proto.RegisterMapType((map[string]HeaderValue)(nil), "agentpb.HealthCheckDefinition.HeaderEntry")
	proto.RegisterType((*CheckServiceNode)(nil), "agentpb.CheckServiceNode")
	proto.RegisterType((*NodeService)(nil), "agentpb.NodeService")
	proto.RegisterMapType((map[string]string)(nil), "agentpb.NodeService.MetaEntry")
	proto.RegisterMapType((map[string]*ServiceAddress)(nil), "agentpb.NodeService.TaggedAddressesEntry")
	proto.RegisterType((*ConnectProxyConfig)(nil), "agentpb.ConnectProxyConfig")
	proto.RegisterType((*Upstream)(nil), "agentpb.Upstream")
	proto.RegisterType((*ServiceConnect)(nil), "agentpb.ServiceConnect")
	proto.RegisterType((*Weights)(nil), "agentpb.Weights")
	proto.RegisterType((*ExposeConfig)(nil), "agentpb.ExposeConfig")
	proto.RegisterType((*ExposePath)(nil), "agentpb.ExposePath")
	proto.RegisterType((*CheckType)(nil), "agentpb.CheckType")
	proto.RegisterMapType((map[string]HeaderValue)(nil), "agentpb.CheckType.HeaderEntry")
	proto.RegisterType((*MeshGatewayConfig)(nil), "agentpb.MeshGatewayConfig")
}

func init() { proto.RegisterFile("structs.proto", fileDescriptor_e774e8f5f348d14d) }

var fileDescriptor_e774e8f5f348d14d = []byte{
	// 2057 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcb, 0x6f, 0x1b, 0xc7,
	0x19, 0x17, 0xc5, 0xf7, 0x47, 0x51, 0xa2, 0xc6, 0xb2, 0xb3, 0x61, 0x02, 0x92, 0x61, 0x8d, 0x42,
	0x56, 0x2d, 0xaa, 0x56, 0xea, 0x3a, 0x09, 0x1c, 0x04, 0xa6, 0xe8, 0xc8, 0x42, 0x24, 0x9b, 0x5e,
	0x32, 0x09, 0x8a, 0x1c, 0x8a, 0xd5, 0x72, 0x44, 0x2e, 0x44, 0xee, 0x12, 0xbb, 0x43, 0x55, 0x6c,
	0xff, 0x88, 0x16, 0xe8, 0xa1, 0x39, 0xf5, 0xd2, 0x7f, 0xa0, 0x7f, 0x86, 0x6f, 0x35, 0xd0, 0x4b,
	0x4f, 0x6c, 0x6b, 0xdf, 0x02, 0x14, 0x05, 0x7a, 0xd4, 0xa9, 0x98, 0x6f, 0x66, 0x97, 0xfb, 0xd2,
	0xcb, 0xf6, 0x21, 0x17, 0x69, 0xe7, 0x7b, 0xed, 0xce, 0x7c, 0x8f, 0xf9, 0xfd, 0x08, 0x45, 0x87,
	0xd9, 0x13, 0x9d, 0x39, 0x8d, 0xb1, 0x6d, 0x31, 0x8b, 0x64, 0xb5, 0x3e, 0x35, 0xd9, 0xf8, 0xb0,
	0x5c, 0xe9, 0x5b, 0x56, 0x7f, 0x48, 0xb7, 0x50, 0x7c, 0x38, 0x39, 0xda, 0xea, 0x4d, 0x6c, 0x8d,
	0x19, 0x96, 0x29, 0x0c, 0xcb, 0x1f, 0x86, 0xf5, 0x22, 0x8e, 0xd4, 0x2e, 0xe9, 0xd6, 0x68, 0xe4,
	0xd9, 0x96, 0xc4, 0xea, 0xd7, 0x96, 0x23, 0x5f, 0x53, 0x5e, 0xeb, 0x5b, 0x7d, 0x0b, 0x1f, 0xb7,
	0xf8, 0x93, 0x90, 0xd6, 0xff, 0x9e, 0x84, 0xd4, 0x53, 0xab, 0x47, 0xc9, 0x43, 0x58, 0xdc, 0x6b,
	0x29, 0x89, 0x5a, 0x62, 0x3d, 0xdf, 0xbc, 0x7b, 0x36, 0xab, 0xae, 0xf7, 0x0d, 0x36, 0x98, 0x1c,
	0x36, 0x74, 0x6b, 0xb4, 0x35, 0xd0, 0x9c, 0x81, 0xa1, 0x5b, 0xf6, 0x78, 0x4b, 0xb7, 0x4c, 0x67,
	0x32, 0xdc, 0x62, 0xd3, 0x31, 0x75, 0x1a, 0xdc, 0x6f, 0xaf, 0xa5, 0x2e, 0xee, 0xb5, 0x08, 0x11,
	0x51, 0x94, 0x45, 0xee, 0xaf, 0x8a, 0x88, 0x0a, 0x64, 0x1f, 0xf5, 0x7a, 0x36, 0x75, 0x1c, 0x25,
	0x89, 0x62, 0x77, 0x49, 0x2a, 0x00, 0x2d, 0x8d, 0x69, 0x3a, 0x35, 0x19, 0xb5, 0x95, 0x14, 0x2a,
	0x7d, 0x12, 0xb2, 0x0f, 0x2b, 0x5d, 0xad, 0xdf, 0xa7, 0x3d, 0xe9, 0x40, 0x1d, 0x25, 0x5d, 0x4b,
	0xae, 0x17, 0xb6, 0xeb, 0x0d, 0x79, 0x56, 0xf8, 0xee, 0x46, 0xc8, 0xe8, 0xb1, 0xc9, 0xec, 0xa9,
	0x1a, 0x76, 0x25, 0x3f, 0x83, 0xd4, 0x01, 0x65, 0x9a, 0x92, 0xc1, 0x10, 0xef, 0x05, 0x43, 0x70,
	0x8d, 0xf0, 0x43, 0x23, 0xb2, 0x0b, 0x79, 0x55, 0x3b, 0x62, 0x7b, 0x66, 0x8f, 0x9e, 0x2a, 0xd9,
	0x5a, 0x62, 0xbd, 0xb0, 0x4d, 0x3c, 0x0f, 0x4f, 0xd3, 0xbc, 0xf9, 0x62, 0x56, 0x5d, 0x78, 0x39,
	0xab, 0x26, 0xfe, 0x37, 0xab, 0xe6, 0x0f, 0xe9, 0xe9, 0xd8, 0xfe, 0xac, 0xbe, 0x59, 0x57, 0xe7,
	0xbe, 0xe5, 0x26, 0xac, 0xc5, 0x7d, 0x1e, 0x29, 0x41, 0xf2, 0x98, 0x4e, 0xc5, 0x41, 0xab, 0xfc,
	0x91, 0xac, 0x41, 0xfa, 0x44, 0x1b, 0x4e, 0xdc, 0xc3, 0x13, 0x8b, 0xcf, 0x16, 0x3f, 0x49, 0x94,
	0x1f, 0x40, 0xde, 0xfb, 0xbe, 0xeb, 0x38, 0xd6, 0xff, 0x9b, 0x81, 0xd5, 0x0e, 0xb5, 0x4f, 0x0c,
	0x9d, 0xb6, 0xe8, 0x91, 0x61, 0x1a, 0xbc, 0x8a, 0xc8, 0x01, 0xa4, 0xbe, 0x32, 0xcc, 0x9e, 0x4c,
	0xf2, 0xa7, 0x67, 0xb3, 0xea, 0xfd, 0x8b, 0x92, 0x8c, 0xbb, 0xde, 0x72, 0x6b, 0x55, 0x86, 0xe3,
	0x01, 0x54, 0x0c, 0x43, 0x96, 0xb1, 0x62, 0xc4, 0xbb, 0xdd, 0x1a, 0xd0, 0x46, 0x54, 0x26, 0x1b,
	0x9f, 0xb9, 0xac, 0xab, 0xf5, 0x1d, 0x25, 0x55, 0x4b, 0x72, 0x19, 0x7f, 0xf6, 0xd7, 0x45, 0x3a,
	0x58, 0x17, 0xbf, 0x8a, 0xe6, 0xbd, 0x84, 0x49, 0xdb, 0xf2, 0x52, 0x10, 0xd9, 0xd5, 0x15, 0x8b,
	0xe0, 0x93, 0x40, 0x11, 0xdc, 0xbe, 0x20, 0x5e, 0xb8, 0x22, 0x3e, 0x80, 0x54, 0xdb, 0xb2, 0x19,
	0x16, 0x43, 0xba, 0x99, 0x3d, 0x9b, 0x55, 0x93, 0x86, 0xc9, 0x54, 0x14, 0x92, 0x06, 0xa4, 0x77,
	0x06, 0x54, 0x3f, 0x56, 0x72, 0xa1, 0x52, 0x41, 0x69, 0x77, 0x3a, 0xa6, 0xcd, 0x14, 0x2f, 0x15,
	0x55, 0x98, 0x91, 0x0d, 0xc8, 0xe0, 0x83, 0xa3, 0xe4, 0xf1, 0x43, 0x62, 0x1c, 0x54, 0x69, 0x41,
	0x36, 0x20, 0xfb, 0x2d, 0x35, 0xfa, 0x03, 0xe6, 0x28, 0x80, 0xd1, 0x4b, 0x9e, 0xb1, 0x94, 0xab,
	0xae, 0x01, 0x2f, 0x85, 0xae, 0x75, 0x4c, 0x4d, 0xa5, 0x20, 0x4a, 0x01, 0x17, 0xe4, 0x2e, 0xac,
	0x3e, 0x36, 0xb5, 0xc3, 0x21, 0xed, 0x6a, 0xfd, 0x67, 0x27, 0xd4, 0xb6, 0x8d, 0x1e, 0x55, 0x96,
	0x6a, 0x89, 0xf5, 0x9c, 0x1a, 0x55, 0x90, 0x7b, 0x90, 0x6e, 0xdb, 0xd6, 0xe9, 0x54, 0x59, 0xc6,
	0xb7, 0x7d, 0x30, 0xff, 0x34, 0xcb, 0x34, 0xa9, 0xce, 0x50, 0xb9, 0x63, 0x99, 0x47, 0x46, 0x5f,
	0x15, 0x96, 0xe4, 0x0b, 0x58, 0x7e, 0xcc, 0x3b, 0x76, 0x6c, 0x1b, 0x0e, 0xc5, 0xf3, 0x5d, 0x45,
	0xdf, 0x79, 0x93, 0x05, 0xd5, 0x6a, 0xc8, 0x9c, 0xdc, 0x83, 0xac, 0x8c, 0xae, 0xac, 0x84, 0x3c,
	0x65, 0x66, 0xa4, 0x5a, 0x75, 0xed, 0xca, 0xdf, 0x5d, 0xb9, 0xb1, 0x36, 0xfd, 0xfd, 0x11, 0x13,
	0x5a, 0x06, 0x78, 0x27, 0x1d, 0xb7, 0x0b, 0xcb, 0xc1, 0xa8, 0xfe, 0x32, 0x4f, 0x04, 0xcb, 0xdc,
	0xad, 0xa8, 0xc5, 0x98, 0x8a, 0xaa, 0xff, 0x29, 0x05, 0x85, 0x27, 0x54, 0x1b, 0xb2, 0x81, 0xa8,
	0x18, 0x77, 0xb2, 0x26, 0x7c, 0x93, 0x75, 0x17, 0xb2, 0xa8, 0x74, 0xdb, 0xaf, 0xb9, 0x79, 0x36,
	0xab, 0xde, 0xb9, 0x7c, 0x60, 0x4b, 0x27, 0xd5, 0xf5, 0x8e, 0x6d, 0xd9, 0x5b, 0x90, 0xe9, 0x30,
	0x8d, 0x4d, 0x1c, 0x39, 0x98, 0xe5, 0x8a, 0xef, 0xfd, 0xa9, 0xc5, 0xa8, 0xdb, 0xb4, 0x62, 0xc1,
	0xad, 0x9f, 0x4d, 0xd8, 0x78, 0xc2, 0x94, 0x8c, 0xb0, 0x16, 0x2b, 0xf2, 0x21, 0xe4, 0xe5, 0x79,
	0xec, 0xb5, 0xb0, 0x75, 0xf2, 0xea, 0x5c, 0x40, 0x6a, 0x50, 0x90, 0x0b, 0x7c, 0x7d, 0x0e, 0xf5,
	0x7e, 0x91, 0xcf, 0x02, 0xe7, 0x47, 0x1e, 0xe7, 0x87, 0x5f, 0x84, 0xa3, 0x65, 0x3a, 0x16, 0xf5,
	0xcc, 0x47, 0xcb, 0x74, 0x4c, 0xc9, 0x73, 0x80, 0x79, 0x27, 0xcb, 0xae, 0xa9, 0x78, 0x69, 0xf7,
	0x1d, 0xeb, 0xdc, 0xaa, 0xb9, 0xca, 0xfb, 0x33, 0x38, 0xc6, 0x7d, 0x41, 0x62, 0x4a, 0xbc, 0x78,
	0xbd, 0x12, 0x0f, 0xdc, 0x28, 0x85, 0x37, 0xbf, 0x51, 0xea, 0x3f, 0xc1, 0xc2, 0xe8, 0x51, 0xfb,
	0x1b, 0x5e, 0x75, 0x3c, 0x1f, 0xf8, 0xa0, 0x24, 0xf0, 0x6c, 0xc4, 0xa2, 0xfe, 0xe7, 0x2c, 0xdc,
	0x8c, 0xdd, 0x27, 0xa9, 0x43, 0xea, 0x49, 0xb7, 0xdb, 0x96, 0xd3, 0x7f, 0xf9, 0x87, 0x59, 0x15,
	0xee, 0x5a, 0x23, 0x83, 0xd1, 0xd1, 0x98, 0x4d, 0x55, 0xd4, 0x91, 0x5f, 0x40, 0xb1, 0xbb, 0xdf,
	0xe9, 0x1c, 0x1b, 0xe3, 0x6f, 0xa8, 0x6d, 0x1c, 0x4d, 0xb1, 0xbc, 0x72, 0x11, 0xe3, 0xa0, 0x11,
	0x79, 0x02, 0x19, 0xf1, 0x61, 0x4a, 0x12, 0x87, 0xda, 0xc6, 0xc5, 0x27, 0xde, 0x10, 0xc6, 0xd8,
	0x63, 0x72, 0x3a, 0x4a, 0x7f, 0xf2, 0x53, 0xc8, 0x1c, 0x50, 0x36, 0xb0, 0x7a, 0xa2, 0xf6, 0x22,
	0x2f, 0x96, 0x5a, 0xbe, 0x97, 0xa6, 0xd5, 0x9b, 0x2a, 0x24, 0x7e, 0x2f, 0x5c, 0x47, 0x6a, 0x90,
	0xec, 0xee, 0xb4, 0x45, 0xb5, 0x46, 0x4c, 0xb8, 0x8a, 0x7c, 0x01, 0xb9, 0x3d, 0x9e, 0xab, 0x13,
	0x6d, 0x88, 0xd5, 0x5b, 0xd8, 0x7e, 0xbf, 0x21, 0x20, 0x56, 0xc3, 0x85, 0x58, 0x8d, 0x96, 0x84,
	0x60, 0xcd, 0x1c, 0xff, 0xd0, 0xef, 0xff, 0x59, 0x4d, 0xa8, 0x9e, 0x13, 0xb9, 0x0d, 0x45, 0x51,
	0xee, 0x07, 0xda, 0x69, 0xc7, 0xf8, 0x2d, 0x55, 0xf2, 0xb5, 0xc4, 0x7a, 0x51, 0x0d, 0x0a, 0xc9,
	0xe7, 0x90, 0xed, 0x1a, 0x23, 0x6a, 0x4d, 0x98, 0x04, 0x14, 0x57, 0x7a, 0x8b, 0xeb, 0x43, 0x8e,
	0xa1, 0xd2, 0xa2, 0x36, 0xed, 0x1b, 0x0e, 0xa3, 0xf6, 0x8e, 0x6d, 0x30, 0x43, 0xd7, 0x86, 0xee,
	0xac, 0x39, 0xe2, 0x00, 0x2a, 0x77, 0xf5, 0xa8, 0x97, 0x84, 0xe2, 0xc8, 0xac, 0xa3, 0xdb, 0xc6,
	0x98, 0x3d, 0xb2, 0xfb, 0xfc, 0xda, 0xe1, 0x95, 0xe5, 0x93, 0xf0, 0x1b, 0xa5, 0x65, 0xe9, 0xc7,
	0xd4, 0xde, 0xb1, 0x4c, 0xa6, 0x19, 0x26, 0xb5, 0xf7, 0x5a, 0xf2, 0xce, 0x89, 0x2a, 0x78, 0x89,
	0x76, 0x06, 0x74, 0x38, 0x94, 0x3d, 0x2a, 0x16, 0xbc, 0x71, 0x77, 0xd5, 0xf6, 0x0e, 0xf6, 0x51,
	0x5e, 0xc5, 0x67, 0xfe, 0x5e, 0xfe, 0xff, 0x6b, 0x87, 0x76, 0xf7, 0x3b, 0x78, 0x01, 0xe5, 0x54,
	0x9f, 0x84, 0x8f, 0x93, 0x47, 0x43, 0x43, 0x73, 0x70, 0x14, 0xae, 0x88, 0x71, 0xe2, 0x09, 0x48,
	0x1d, 0x96, 0x70, 0x21, 0xb7, 0xa2, 0x94, 0xd0, 0x20, 0x20, 0x23, 0xf7, 0x21, 0xd9, 0xed, 0xee,
	0xcb, 0xfb, 0xe9, 0x4a, 0x67, 0xc5, 0xed, 0xcb, 0xcf, 0xdc, 0xa6, 0x3b, 0xef, 0x4a, 0xd8, 0x08,
	0x5e, 0x32, 0x6b, 0xfe, 0xda, 0x77, 0x7b, 0xd5, 0x7f, 0x51, 0xfc, 0x31, 0x01, 0x25, 0x6c, 0x08,
	0x77, 0xda, 0xf1, 0x0d, 0x7c, 0xe4, 0x1b, 0xf2, 0x85, 0xed, 0x62, 0x00, 0xa2, 0xca, 0x99, 0xdf,
	0x80, 0xac, 0xbb, 0xbd, 0xf0, 0x9b, 0xb8, 0x5e, 0xea, 0x54, 0xd7, 0x88, 0xdc, 0xf5, 0x90, 0x86,
	0x68, 0xca, 0xb5, 0xb8, 0xa6, 0x74, 0xb1, 0x46, 0xfd, 0x2f, 0x59, 0x28, 0xf8, 0xc2, 0x90, 0xef,
	0x02, 0x50, 0x71, 0x37, 0xd8, 0x3d, 0xef, 0x1a, 0x38, 0x2a, 0xf3, 0xad, 0x49, 0xa2, 0xe0, 0x7e,
	0xc6, 0xf5, 0xe0, 0x63, 0x27, 0x0a, 0x1f, 0x57, 0x70, 0xef, 0x77, 0xe2, 0x8e, 0xea, 0x8a, 0xc0,
	0x71, 0x3b, 0x00, 0x1c, 0x2b, 0xb1, 0x91, 0xae, 0x05, 0x19, 0x7d, 0xb0, 0x2e, 0x77, 0x19, 0xac,
	0x8b, 0x05, 0x70, 0xf9, 0xf3, 0x00, 0xdc, 0x03, 0x17, 0xc0, 0x15, 0x2e, 0x05, 0x70, 0x2e, 0x2a,
	0x15, 0x30, 0xee, 0xc1, 0x1c, 0x85, 0x2d, 0x5d, 0x88, 0xc2, 0xa4, 0x9b, 0x6b, 0x4d, 0x0e, 0xa0,
	0xbc, 0x6f, 0xe9, 0xda, 0x70, 0x38, 0x55, 0xe5, 0x54, 0xa1, 0xbd, 0x47, 0x4e, 0xc7, 0xe8, 0x51,
	0x5d, 0xb3, 0xb1, 0xc1, 0x73, 0xcd, 0x62, 0xf0, 0x42, 0xbb, 0xc0, 0x21, 0xe6, 0xae, 0x2d, 0xbd,
	0xc5, 0x5d, 0xbb, 0xfc, 0x16, 0xec, 0xed, 0xc7, 0x09, 0x32, 0xff, 0x96, 0x04, 0x12, 0xcd, 0x25,
	0xf9, 0x25, 0xdc, 0x6a, 0x51, 0x87, 0x19, 0x26, 0x4e, 0x30, 0x3f, 0xb0, 0x12, 0x51, 0xcf, 0xd1,
	0x92, 0x6d, 0x58, 0x8b, 0x6a, 0xbc, 0xce, 0x8c, 0xd5, 0x91, 0x9f, 0xc3, 0x0d, 0x4c, 0x60, 0x70,
	0x77, 0xb2, 0x6f, 0xe3, 0x54, 0xe4, 0x63, 0x28, 0xf9, 0xc5, 0xd8, 0x18, 0xa9, 0x60, 0x63, 0x44,
	0x0c, 0x48, 0x13, 0x32, 0x62, 0x73, 0xd8, 0xe3, 0xfc, 0x58, 0xc3, 0x03, 0xbb, 0x83, 0xe3, 0x05,
	0xd1, 0x5b, 0x28, 0x8d, 0xd2, 0x93, 0xdc, 0x87, 0xfc, 0xd7, 0x63, 0x87, 0xd9, 0x54, 0x1b, 0x39,
	0xb2, 0x7d, 0x57, 0xbd, 0xec, 0xb8, 0x1a, 0x59, 0xd1, 0x73, 0x4b, 0xf2, 0x10, 0x0a, 0x07, 0xd4,
	0x19, 0xec, 0x6a, 0x8c, 0xfe, 0x46, 0x9b, 0xca, 0x2b, 0xbb, 0xec, 0x39, 0xfa, 0x74, 0x92, 0x0b,
	0xf9, 0xcd, 0xc9, 0x26, 0x64, 0x1e, 0x9f, 0x8e, 0x2d, 0x87, 0xca, 0xe6, 0xbe, 0x39, 0x2f, 0x5d,
	0x14, 0x4b, 0x1f, 0x69, 0x54, 0xff, 0x7d, 0x12, 0x72, 0xee, 0xab, 0xc9, 0x3a, 0xac, 0xf8, 0xce,
	0x1c, 0xc1, 0xad, 0x48, 0x60, 0x58, 0x1c, 0xca, 0x1c, 0x4f, 0xa6, 0x33, 0xd6, 0x74, 0x1a, 0x93,
	0x39, 0x4f, 0x17, 0x8a, 0xee, 0x83, 0xfd, 0x61, 0xf1, 0xa5, 0x3f, 0xcf, 0x6c, 0xc8, 0x8c, 0x36,
	0x0d, 0xb3, 0x17, 0x1c, 0xc5, 0x11, 0x39, 0xd9, 0x84, 0xa2, 0x27, 0xc3, 0xd4, 0x67, 0x82, 0xa9,
	0x0f, 0x6a, 0x7d, 0x79, 0xcf, 0xbe, 0x71, 0xde, 0x43, 0x09, 0xcc, 0x5d, 0x2b, 0x81, 0xf5, 0xdf,
	0x79, 0x44, 0xce, 0x1d, 0x72, 0xb7, 0x20, 0xf3, 0x54, 0x63, 0xc6, 0x89, 0xc8, 0x46, 0x4e, 0x95,
	0x2b, 0xf2, 0x1c, 0x96, 0xe5, 0xe0, 0xf2, 0xdf, 0x5e, 0xfe, 0x57, 0x45, 0x7e, 0x5c, 0x08, 0x0f,
	0xc3, 0x50, 0x80, 0xfa, 0x33, 0xef, 0x6e, 0x20, 0x1f, 0x41, 0xb6, 0xad, 0x39, 0x8e, 0x61, 0xf6,
	0xf1, 0xb5, 0xbe, 0x23, 0x73, 0xe5, 0xdc, 0xe4, 0x5b, 0xcd, 0x36, 0xb9, 0x49, 0x88, 0x4a, 0xba,
	0xf2, 0xfa, 0x73, 0x58, 0xf2, 0xd7, 0x1d, 0xdf, 0x8b, 0x44, 0x05, 0x72, 0x2f, 0xf2, 0xb7, 0x86,
	0x3b, 0x90, 0x6e, 0x6b, 0x6c, 0xe0, 0x28, 0x8b, 0xd8, 0x27, 0x37, 0x42, 0x55, 0xcb, 0x75, 0xaa,
	0xb0, 0xa8, 0xff, 0x35, 0x01, 0x30, 0x97, 0x72, 0xec, 0xb5, 0xcf, 0x07, 0xb9, 0x49, 0x6d, 0xcc,
	0x2f, 0x7e, 0xac, 0x1a, 0x90, 0xf1, 0x6b, 0x9c, 0xdb, 0xba, 0xbf, 0x0e, 0xa2, 0xdf, 0x6d, 0x59,
	0x18, 0x7c, 0x81, 0x8e, 0x49, 0x74, 0x0c, 0x0a, 0x49, 0x19, 0x72, 0x6d, 0x9e, 0x79, 0xdd, 0x1a,
	0xca, 0x42, 0xf4, 0xd6, 0xbc, 0xa0, 0xdb, 0x9a, 0xed, 0xd0, 0xde, 0x97, 0xb6, 0x35, 0x12, 0xbf,
	0xc2, 0xa4, 0x71, 0x53, 0x61, 0x71, 0xfd, 0x3f, 0x39, 0xc8, 0x7b, 0xbf, 0xaf, 0x90, 0xaf, 0xe6,
	0xec, 0x59, 0xc0, 0x9b, 0x7b, 0x3f, 0xcc, 0xaa, 0x0b, 0x6f, 0xc9, 0xa0, 0x17, 0x63, 0x19, 0x74,
	0x32, 0x9e, 0x41, 0xa7, 0xfc, 0x0c, 0x3a, 0x08, 0xb9, 0xd3, 0x11, 0xc8, 0x4d, 0x24, 0x6f, 0x13,
	0xfc, 0x5a, 0xf0, 0xb4, 0x87, 0x1e, 0xe3, 0x5a, 0x0b, 0xc1, 0x12, 0x6f, 0x9b, 0x17, 0xb0, 0xac,
	0x5b, 0x1e, 0xcb, 0x12, 0xc4, 0xdc, 0x65, 0x55, 0x44, 0xb2, 0xaa, 0xb2, 0x78, 0x13, 0xb2, 0xa8,
	0x92, 0x60, 0x51, 0x82, 0xa1, 0x47, 0x58, 0x53, 0xfe, 0x4d, 0x58, 0x53, 0x00, 0xcb, 0xc3, 0x65,
	0x58, 0xbe, 0x10, 0x83, 0xe5, 0x63, 0x59, 0xc8, 0xd2, 0xa5, 0x2c, 0xa4, 0x18, 0xc7, 0x42, 0x96,
	0xcf, 0x65, 0x21, 0x2b, 0x11, 0x16, 0x72, 0x3b, 0x4c, 0x8f, 0x4b, 0x68, 0x12, 0xa2, 0xc3, 0x3e,
	0xbe, 0xb7, 0xfa, 0x06, 0x7c, 0x4f, 0x12, 0x15, 0x72, 0x3d, 0xa2, 0xc2, 0xaf, 0x84, 0xce, 0x44,
	0xd7, 0xa9, 0xe3, 0x34, 0xe9, 0x91, 0x65, 0x53, 0x77, 0x78, 0xdc, 0xc4, 0xb6, 0x8a, 0xd5, 0x71,
	0xe0, 0xf0, 0xa5, 0x66, 0x0c, 0x27, 0x36, 0x95, 0x0a, 0x97, 0x13, 0x2a, 0xb7, 0xd0, 0xeb, 0x1c,
	0x2d, 0xcf, 0x20, 0xe2, 0x0f, 0xac, 0xcb, 0xf7, 0x44, 0x06, 0x3d, 0x81, 0xa7, 0xc5, 0xe3, 0x55,
	0x7c, 0x5a, 0x3c, 0xe3, 0xcb, 0xe9, 0xec, 0x8d, 0x77, 0x47, 0x67, 0x23, 0x04, 0xfd, 0x7d, 0x31,
	0x64, 0x02, 0xc2, 0x77, 0xcf, 0xf1, 0x8e, 0x60, 0x35, 0x72, 0xcb, 0x90, 0xe7, 0x90, 0x3a, 0xf0,
	0x7e, 0xc8, 0x6b, 0x7e, 0x7e, 0x36, 0xab, 0x7e, 0x7a, 0x75, 0x12, 0xe5, 0x0b, 0x77, 0x80, 0x9c,
	0x90, 0xff, 0x6d, 0xd6, 0x5e, 0xfc, 0xbb, 0xb2, 0xf0, 0xe2, 0x55, 0x25, 0xf1, 0xf2, 0x55, 0x25,
	0xf1, 0xaf, 0x57, 0x95, 0xc4, 0x1f, 0x5e, 0x57, 0x16, 0xbe, 0x7f, 0x5d, 0x59, 0x78, 0xf9, 0xba,
	0xb2, 0xf0, 0x8f, 0xd7, 0x95, 0x85, 0xc3, 0x0c, 0x9e, 0xde, 0xc7, 0xff, 0x0f, 0x00, 0x00, 0xff,
	0xff, 0xed, 0x62, 0xf9, 0xab, 0x73, 0x1a, 0x00, 0x00,
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Node) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Datacenter) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Datacenter)))
		i += copy(dAtA[i:], m.Datacenter)
	}
	if len(m.TaggedAddresses) > 0 {
		for k, _ := range m.TaggedAddresses {
			dAtA[i] = 0x2a
			i++
			v := m.TaggedAddresses[k]
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Meta) > 0 {
		for k, _ := range m.Meta {
			dAtA[i] = 0x32
			i++
			v := m.Meta[k]
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.RaftIndex.Size()))
	n1, err := m.RaftIndex.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	return i, nil
}

func (m *ServiceDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Meta) > 0 {
		for k, _ := range m.Meta {
			dAtA[i] = 0x32
			i++
			v := m.Meta[k]
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Port != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Port))
	}
	dAtA[i] = 0x42
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Check.Size()))
	n2, err := m.Check.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.Checks) > 0 {
		for _, msg := range m.Checks {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintStructs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Weights != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Weights.Size()))
		n3, err := m.Weights.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.EnableTagOverride {
		dAtA[i] = 0x60
		i++
		if m.EnableTagOverride {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Proxy != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Proxy.Size()))
		n4, err := m.Proxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Connect != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Connect.Size()))
		n5, err := m.Connect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.TaggedAddresses) > 0 {
		for k, _ := range m.TaggedAddresses {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			v := m.TaggedAddresses[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovStructs(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + msgSize
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintStructs(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if m.EnterpriseMeta != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.EnterpriseMeta.Size()))
		n7, err := m.EnterpriseMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *ServiceAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Port))
	}
	return i, nil
}

func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Node) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	if len(m.CheckID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.CheckID)))
		i += copy(dAtA[i:], m.CheckID)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Notes) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Notes)))
		i += copy(dAtA[i:], m.Notes)
	}
	if len(m.Output) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Output)))
		i += copy(dAtA[i:], m.Output)
	}
	if len(m.ServiceID) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ServiceID)))
		i += copy(dAtA[i:], m.ServiceID)
	}
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	if len(m.ServiceTags) > 0 {
		for _, s := range m.ServiceTags {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Definition.Size()))
	n8, err := m.Definition.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x5a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.RaftIndex.Size()))
	n9, err := m.RaftIndex.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.Type) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.EnterpriseMeta != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.EnterpriseMeta.Size()))
		n10, err := m.EnterpriseMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *HeaderValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *HealthCheckDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HTTP) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.HTTP)))
		i += copy(dAtA[i:], m.HTTP)
	}
	if m.TLSSkipVerify {
		dAtA[i] = 0x10
		i++
		if m.TLSSkipVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Header) > 0 {
		for k, _ := range m.Header {
			dAtA[i] = 0x1a
			i++
			v := m.Header[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovStructs(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + msgSize
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64((&v).Size()))
			n11, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n11
		}
	}
	if len(m.Method) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.TCP) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.TCP)))
		i += copy(dAtA[i:], m.TCP)
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval)))
	n12, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Interval, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x3a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)))
	n13, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Timeout, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x42
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter)))
	n14, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.DeregisterCriticalServiceAfter, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if m.OutputMaxSize != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.OutputMaxSize))
	}
	if len(m.ScriptArgs) > 0 {
		for _, s := range m.ScriptArgs {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DockerContainerID) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DockerContainerID)))
		i += copy(dAtA[i:], m.DockerContainerID)
	}
	if len(m.Shell) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Shell)))
		i += copy(dAtA[i:], m.Shell)
	}
	if len(m.GRPC) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.GRPC)))
		i += copy(dAtA[i:], m.GRPC)
	}
	if m.GRPCUseTLS {
		dAtA[i] = 0x70
		i++
		if m.GRPCUseTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AliasNode) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.AliasNode)))
		i += copy(dAtA[i:], m.AliasNode)
	}
	if len(m.AliasService) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.AliasService)))
		i += copy(dAtA[i:], m.AliasService)
	}
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.TTL)))
	n15, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TTL, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if len(m.Body) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	return i, nil
}

func (m *CheckServiceNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckServiceNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Node != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Node.Size()))
		n16, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Service != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Service.Size()))
		n17, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Checks) > 0 {
		for _, msg := range m.Checks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStructs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NodeService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeService) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Service) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Service)))
		i += copy(dAtA[i:], m.Service)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Meta) > 0 {
		for k, _ := range m.Meta {
			dAtA[i] = 0x32
			i++
			v := m.Meta[k]
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Port != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Port))
	}
	if m.Weights != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Weights.Size()))
		n18, err := m.Weights.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.EnableTagOverride {
		dAtA[i] = 0x48
		i++
		if m.EnableTagOverride {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Proxy.Size()))
	n19, err := m.Proxy.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x62
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Connect.Size()))
	n20, err := m.Connect.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if m.LocallyRegisteredAsSidecar {
		dAtA[i] = 0x68
		i++
		if m.LocallyRegisteredAsSidecar {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x72
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.RaftIndex.Size()))
	n21, err := m.RaftIndex.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	if len(m.TaggedAddresses) > 0 {
		for k, _ := range m.TaggedAddresses {
			dAtA[i] = 0x7a
			i++
			v := m.TaggedAddresses[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovStructs(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + msgSize
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintStructs(dAtA, i, uint64(v.Size()))
				n22, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n22
			}
		}
	}
	if m.EnterpriseMeta != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.EnterpriseMeta.Size()))
		n23, err := m.EnterpriseMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *ConnectProxyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectProxyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DestinationServiceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationServiceName)))
		i += copy(dAtA[i:], m.DestinationServiceName)
	}
	if len(m.DestinationServiceID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationServiceID)))
		i += copy(dAtA[i:], m.DestinationServiceID)
	}
	if len(m.LocalServiceAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.LocalServiceAddress)))
		i += copy(dAtA[i:], m.LocalServiceAddress)
	}
	if m.LocalServicePort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.LocalServicePort))
	}
	if m.Config != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Config.Size()))
		n24, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.Upstreams) > 0 {
		for _, msg := range m.Upstreams {
			dAtA[i] = 0x32
			i++
			i = encodeVarintStructs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MeshGateway != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.MeshGateway.Size()))
		n25, err := m.MeshGateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Expose != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Expose.Size()))
		n26, err := m.Expose.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *Upstream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Upstream) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DestinationType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationType)))
		i += copy(dAtA[i:], m.DestinationType)
	}
	if len(m.DestinationNamespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationNamespace)))
		i += copy(dAtA[i:], m.DestinationNamespace)
	}
	if len(m.DestinationName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationName)))
		i += copy(dAtA[i:], m.DestinationName)
	}
	if len(m.Datacenter) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Datacenter)))
		i += copy(dAtA[i:], m.Datacenter)
	}
	if len(m.LocalBindAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.LocalBindAddress)))
		i += copy(dAtA[i:], m.LocalBindAddress)
	}
	if m.LocalBindPort != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.LocalBindPort))
	}
	if m.Config != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Config.Size()))
		n27, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.MeshGateway != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.MeshGateway.Size()))
		n28, err := m.MeshGateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *ServiceConnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceConnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Native {
		dAtA[i] = 0x8
		i++
		if m.Native {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SidecarService != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.SidecarService.Size()))
		n29, err := m.SidecarService.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *Weights) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Weights) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Passing != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Passing))
	}
	if m.Warning != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Warning))
	}
	return i, nil
}

func (m *ExposeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExposeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Checks {
		dAtA[i] = 0x8
		i++
		if m.Checks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Paths) > 0 {
		for _, msg := range m.Paths {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExposePath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExposePath) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ListenerPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.ListenerPort))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.LocalPathPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.LocalPathPort))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.ParsedFromCheck {
		dAtA[i] = 0x28
		i++
		if m.ParsedFromCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CheckType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CheckID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.CheckID)))
		i += copy(dAtA[i:], m.CheckID)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Notes) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Notes)))
		i += copy(dAtA[i:], m.Notes)
	}
	if len(m.ScriptArgs) > 0 {
		for _, s := range m.ScriptArgs {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.HTTP) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.HTTP)))
		i += copy(dAtA[i:], m.HTTP)
	}
	if len(m.Method) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.TCP) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.TCP)))
		i += copy(dAtA[i:], m.TCP)
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval)))
	n30, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Interval, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n30
	if len(m.AliasNode) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.AliasNode)))
		i += copy(dAtA[i:], m.AliasNode)
	}
	if len(m.AliasService) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.AliasService)))
		i += copy(dAtA[i:], m.AliasService)
	}
	if len(m.DockerContainerID) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DockerContainerID)))
		i += copy(dAtA[i:], m.DockerContainerID)
	}
	if len(m.Shell) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Shell)))
		i += copy(dAtA[i:], m.Shell)
	}
	if len(m.GRPC) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.GRPC)))
		i += copy(dAtA[i:], m.GRPC)
	}
	if m.GRPCUseTLS {
		dAtA[i] = 0x78
		i++
		if m.GRPCUseTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TLSSkipVerify {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.TLSSkipVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)))
	n31, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Timeout, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.TTL)))
	n32, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TTL, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter)))
	n33, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.DeregisterCriticalServiceAfter, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n33
	if len(m.Header) > 0 {
		for k, _ := range m.Header {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Header[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovStructs(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + msgSize
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64((&v).Size()))
			n34, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n34
		}
	}
	if m.SuccessBeforePassing != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.SuccessBeforePassing))
	}
	if m.FailuresBeforeCritical != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.FailuresBeforeCritical))
	}
	if len(m.ProxyHTTP) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ProxyHTTP)))
		i += copy(dAtA[i:], m.ProxyHTTP)
	}
	if len(m.ProxyGRPC) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ProxyGRPC)))
		i += copy(dAtA[i:], m.ProxyGRPC)
	}
	if m.OutputMaxSize != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.OutputMaxSize))
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	return i, nil
}

func (m *MeshGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeshGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	return i, nil
}

func encodeVarintStructs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.TaggedAddresses) > 0 {
		for k, v := range m.TaggedAddresses {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	l = m.RaftIndex.Size()
	n += 1 + l + sovStructs(uint64(l))
	return n
}

func (m *ServiceDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	if m.Port != 0 {
		n += 1 + sovStructs(uint64(m.Port))
	}
	l = m.Check.Size()
	n += 1 + l + sovStructs(uint64(l))
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	if m.Weights != nil {
		l = m.Weights.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.EnableTagOverride {
		n += 2
	}
	if m.Proxy != nil {
		l = m.Proxy.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.Connect != nil {
		l = m.Connect.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.TaggedAddresses) > 0 {
		for k, v := range m.TaggedAddresses {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStructs(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovStructs(uint64(mapEntrySize))
		}
	}
	if m.EnterpriseMeta != nil {
		l = m.EnterpriseMeta.Size()
		n += 2 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *ServiceAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovStructs(uint64(m.Port))
	}
	return n
}

func (m *HealthCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.CheckID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ServiceID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.ServiceTags) > 0 {
		for _, s := range m.ServiceTags {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = m.Definition.Size()
	n += 1 + l + sovStructs(uint64(l))
	l = m.RaftIndex.Size()
	n += 1 + l + sovStructs(uint64(l))
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.EnterpriseMeta != nil {
		l = m.EnterpriseMeta.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *HeaderValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	return n
}

func (m *HealthCheckDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HTTP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.TLSSkipVerify {
		n += 2
	}
	if len(m.Header) > 0 {
		for k, v := range m.Header {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + l + sovStructs(uint64(l))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.TCP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval)
	n += 1 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)
	n += 1 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter)
	n += 1 + l + sovStructs(uint64(l))
	if m.OutputMaxSize != 0 {
		n += 1 + sovStructs(uint64(m.OutputMaxSize))
	}
	if len(m.ScriptArgs) > 0 {
		for _, s := range m.ScriptArgs {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.DockerContainerID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Shell)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.GRPC)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.GRPCUseTLS {
		n += 2
	}
	l = len(m.AliasNode)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.AliasService)
	if l > 0 {
		n += 2 + l + sovStructs(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TTL)
	n += 2 + l + sovStructs(uint64(l))
	l = len(m.Body)
	if l > 0 {
		n += 2 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *CheckServiceNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	return n
}

func (m *NodeService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	if m.Port != 0 {
		n += 1 + sovStructs(uint64(m.Port))
	}
	if m.Weights != nil {
		l = m.Weights.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.EnableTagOverride {
		n += 2
	}
	l = m.Proxy.Size()
	n += 1 + l + sovStructs(uint64(l))
	l = m.Connect.Size()
	n += 1 + l + sovStructs(uint64(l))
	if m.LocallyRegisteredAsSidecar {
		n += 2
	}
	l = m.RaftIndex.Size()
	n += 1 + l + sovStructs(uint64(l))
	if len(m.TaggedAddresses) > 0 {
		for k, v := range m.TaggedAddresses {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStructs(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	if m.EnterpriseMeta != nil {
		l = m.EnterpriseMeta.Size()
		n += 2 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *ConnectProxyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DestinationServiceName)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DestinationServiceID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.LocalServiceAddress)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.LocalServicePort != 0 {
		n += 1 + sovStructs(uint64(m.LocalServicePort))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Upstreams) > 0 {
		for _, e := range m.Upstreams {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	if m.MeshGateway != nil {
		l = m.MeshGateway.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.Expose != nil {
		l = m.Expose.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *Upstream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DestinationType)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DestinationNamespace)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DestinationName)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.LocalBindAddress)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.LocalBindPort != 0 {
		n += 1 + sovStructs(uint64(m.LocalBindPort))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.MeshGateway != nil {
		l = m.MeshGateway.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *ServiceConnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Native {
		n += 2
	}
	if m.SidecarService != nil {
		l = m.SidecarService.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *Weights) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Passing != 0 {
		n += 1 + sovStructs(uint64(m.Passing))
	}
	if m.Warning != 0 {
		n += 1 + sovStructs(uint64(m.Warning))
	}
	return n
}

func (m *ExposeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Checks {
		n += 2
	}
	if len(m.Paths) > 0 {
		for _, e := range m.Paths {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	return n
}

func (m *ExposePath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ListenerPort != 0 {
		n += 1 + sovStructs(uint64(m.ListenerPort))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.LocalPathPort != 0 {
		n += 1 + sovStructs(uint64(m.LocalPathPort))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.ParsedFromCheck {
		n += 2
	}
	return n
}

func (m *CheckType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CheckID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.ScriptArgs) > 0 {
		for _, s := range m.ScriptArgs {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.HTTP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.TCP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval)
	n += 1 + l + sovStructs(uint64(l))
	l = len(m.AliasNode)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.AliasService)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DockerContainerID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Shell)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.GRPC)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.GRPCUseTLS {
		n += 2
	}
	if m.TLSSkipVerify {
		n += 3
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)
	n += 2 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TTL)
	n += 2 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter)
	n += 2 + l + sovStructs(uint64(l))
	if len(m.Header) > 0 {
		for k, v := range m.Header {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + l + sovStructs(uint64(l))
			n += mapEntrySize + 2 + sovStructs(uint64(mapEntrySize))
		}
	}
	if m.SuccessBeforePassing != 0 {
		n += 2 + sovStructs(uint64(m.SuccessBeforePassing))
	}
	if m.FailuresBeforeCritical != 0 {
		n += 2 + sovStructs(uint64(m.FailuresBeforeCritical))
	}
	l = len(m.ProxyHTTP)
	if l > 0 {
		n += 2 + l + sovStructs(uint64(l))
	}
	l = len(m.ProxyGRPC)
	if l > 0 {
		n += 2 + l + sovStructs(uint64(l))
	}
	if m.OutputMaxSize != 0 {
		n += 2 + sovStructs(uint64(m.OutputMaxSize))
	}
	l = len(m.Body)
	if l > 0 {
		n += 2 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *MeshGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func sovStructs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStructs(x uint64) (n int) {
	return sovStructs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = github_com_hashicorp_consul_types.NodeID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaggedAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaggedAddresses == nil {
				m.TaggedAddresses = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TaggedAddresses[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = github_com_hashicorp_consul_agent_structs.ServiceKind(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Check.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &CheckType{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weights == nil {
				m.Weights = &Weights{}
			}
			if err := m.Weights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTagOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableTagOverride = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proxy == nil {
				m.Proxy = &ConnectProxyConfig{}
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connect == nil {
				m.Connect = &ServiceConnect{}
			}
			if err := m.Connect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaggedAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaggedAddresses == nil {
				m.TaggedAddresses = make(map[string]*ServiceAddress)
			}
			var mapkey string
			var mapvalue *ServiceAddress
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStructs
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStructs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ServiceAddress{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TaggedAddresses[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterpriseMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnterpriseMeta == nil {
				m.EnterpriseMeta = &EnterpriseMeta{}
			}
			if err := m.EnterpriseMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckID = github_com_hashicorp_consul_types.CheckID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceTags = append(m.ServiceTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterpriseMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnterpriseMeta == nil {
				m.EnterpriseMeta = &EnterpriseMeta{}
			}
			if err := m.EnterpriseMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSSkipVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLSSkipVerify = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = make(map[string]HeaderValue)
			}
			var mapkey string
			mapvalue := &HeaderValue{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStructs
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStructs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HeaderValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Header[mapkey] = *mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Interval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeregisterCriticalServiceAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.DeregisterCriticalServiceAfter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMaxSize", wireType)
			}
			m.OutputMaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputMaxSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptArgs = append(m.ScriptArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerContainerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerContainerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shell", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shell = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GRPC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPCUseTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GRPCUseTLS = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckServiceNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckServiceNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckServiceNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &Node{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &NodeService{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &HealthCheck{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeService) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = github_com_hashicorp_consul_agent_structs.ServiceKind(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weights == nil {
				m.Weights = &Weights{}
			}
			if err := m.Weights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTagOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableTagOverride = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Connect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocallyRegisteredAsSidecar", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocallyRegisteredAsSidecar = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaggedAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaggedAddresses == nil {
				m.TaggedAddresses = make(map[string]*ServiceAddress)
			}
			var mapkey string
			var mapvalue *ServiceAddress
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStructs
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStructs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ServiceAddress{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TaggedAddresses[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterpriseMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnterpriseMeta == nil {
				m.EnterpriseMeta = &EnterpriseMeta{}
			}
			if err := m.EnterpriseMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectProxyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectProxyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectProxyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationServiceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationServiceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalServiceAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalServiceAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalServicePort", wireType)
			}
			m.LocalServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalServicePort |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &types.Struct{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Upstreams = append(m.Upstreams, Upstream{})
			if err := m.Upstreams[len(m.Upstreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeshGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeshGateway == nil {
				m.MeshGateway = &MeshGatewayConfig{}
			}
			if err := m.MeshGateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expose == nil {
				m.Expose = &ExposeConfig{}
			}
			if err := m.Expose.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Upstream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Upstream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Upstream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalBindAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalBindAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalBindPort", wireType)
			}
			m.LocalBindPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalBindPort |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &types.Struct{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeshGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeshGateway == nil {
				m.MeshGateway = &MeshGatewayConfig{}
			}
			if err := m.MeshGateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceConnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceConnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceConnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Native", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Native = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SidecarService == nil {
				m.SidecarService = &ServiceDefinition{}
			}
			if err := m.SidecarService.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Weights) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Weights: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Weights: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passing", wireType)
			}
			m.Passing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Passing |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warning", wireType)
			}
			m.Warning = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Warning |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExposeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExposeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExposeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checks = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, &ExposePath{})
			if err := m.Paths[len(m.Paths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExposePath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExposePath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExposePath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenerPort", wireType)
			}
			m.ListenerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ListenerPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPathPort", wireType)
			}
			m.LocalPathPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalPathPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParsedFromCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ParsedFromCheck = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckID = github_com_hashicorp_consul_types.CheckID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptArgs = append(m.ScriptArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Interval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerContainerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerContainerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shell", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shell = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GRPC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPCUseTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GRPCUseTLS = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSSkipVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLSSkipVerify = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeregisterCriticalServiceAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.DeregisterCriticalServiceAfter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = make(map[string]HeaderValue)
			}
			var mapkey string
			mapvalue := &HeaderValue{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStructs
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStructs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HeaderValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Header[mapkey] = *mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessBeforePassing", wireType)
			}
			m.SuccessBeforePassing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessBeforePassing |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailuresBeforeCritical", wireType)
			}
			m.FailuresBeforeCritical = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailuresBeforeCritical |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyHTTP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyHTTP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyGRPC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyGRPC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMaxSize", wireType)
			}
			m.OutputMaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputMaxSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeshGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeshGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeshGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = github_com_hashicorp_consul_agent_structs.MeshGatewayMode(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStructs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStructs
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthStructs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStructs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthStructs
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStructs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStructs   = fmt.Errorf("proto: integer overflow")
)

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: google/cloud/dialogflow/v2beta1/session.proto

package dialogflow

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf4 "github.com/golang/protobuf/ptypes/struct"
import google_rpc "google.golang.org/genproto/googleapis/rpc/status"
import google_type "google.golang.org/genproto/googleapis/type/latlng"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Audio encoding of the audio content sent in the conversational query request.
// Refer to the [Cloud Speech API documentation](/speech/docs/basics) for more
// details.
type AudioEncoding int32

const (
	// Not specified.
	AudioEncoding_AUDIO_ENCODING_UNSPECIFIED AudioEncoding = 0
	// Uncompressed 16-bit signed little-endian samples (Linear PCM).
	AudioEncoding_AUDIO_ENCODING_LINEAR_16 AudioEncoding = 1
	// [`FLAC`](https://xiph.org/flac/documentation.html) (Free Lossless Audio
	// Codec) is the recommended encoding because it is lossless (therefore
	// recognition is not compromised) and requires only about half the
	// bandwidth of `LINEAR16`. `FLAC` stream encoding supports 16-bit and
	// 24-bit samples, however, not all fields in `STREAMINFO` are supported.
	AudioEncoding_AUDIO_ENCODING_FLAC AudioEncoding = 2
	// 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
	AudioEncoding_AUDIO_ENCODING_MULAW AudioEncoding = 3
	// Adaptive Multi-Rate Narrowband codec. `sample_rate_hertz` must be 8000.
	AudioEncoding_AUDIO_ENCODING_AMR AudioEncoding = 4
	// Adaptive Multi-Rate Wideband codec. `sample_rate_hertz` must be 16000.
	AudioEncoding_AUDIO_ENCODING_AMR_WB AudioEncoding = 5
	// Opus encoded audio frames in Ogg container
	// ([OggOpus](https://wiki.xiph.org/OggOpus)).
	// `sample_rate_hertz` must be 16000.
	AudioEncoding_AUDIO_ENCODING_OGG_OPUS AudioEncoding = 6
	// Although the use of lossy encodings is not recommended, if a very low
	// bitrate encoding is required, `OGG_OPUS` is highly preferred over
	// Speex encoding. The [Speex](https://speex.org/) encoding supported by
	// Dialogflow API has a header byte in each block, as in MIME type
	// `audio/x-speex-with-header-byte`.
	// It is a variant of the RTP Speex encoding defined in
	// [RFC 5574](https://tools.ietf.org/html/rfc5574).
	// The stream is a sequence of blocks, one block per RTP packet. Each block
	// starts with a byte containing the length of the block, in bytes, followed
	// by one or more frames of Speex data, padded to an integral number of
	// bytes (octets) as specified in RFC 5574. In other words, each RTP header
	// is replaced with a single byte containing the block length. Only Speex
	// wideband is supported. `sample_rate_hertz` must be 16000.
	AudioEncoding_AUDIO_ENCODING_SPEEX_WITH_HEADER_BYTE AudioEncoding = 7
)

var AudioEncoding_name = map[int32]string{
	0: "AUDIO_ENCODING_UNSPECIFIED",
	1: "AUDIO_ENCODING_LINEAR_16",
	2: "AUDIO_ENCODING_FLAC",
	3: "AUDIO_ENCODING_MULAW",
	4: "AUDIO_ENCODING_AMR",
	5: "AUDIO_ENCODING_AMR_WB",
	6: "AUDIO_ENCODING_OGG_OPUS",
	7: "AUDIO_ENCODING_SPEEX_WITH_HEADER_BYTE",
}
var AudioEncoding_value = map[string]int32{
	"AUDIO_ENCODING_UNSPECIFIED":            0,
	"AUDIO_ENCODING_LINEAR_16":              1,
	"AUDIO_ENCODING_FLAC":                   2,
	"AUDIO_ENCODING_MULAW":                  3,
	"AUDIO_ENCODING_AMR":                    4,
	"AUDIO_ENCODING_AMR_WB":                 5,
	"AUDIO_ENCODING_OGG_OPUS":               6,
	"AUDIO_ENCODING_SPEEX_WITH_HEADER_BYTE": 7,
}

func (x AudioEncoding) String() string {
	return proto.EnumName(AudioEncoding_name, int32(x))
}
func (AudioEncoding) EnumDescriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

// Type of the response message.
type StreamingRecognitionResult_MessageType int32

const (
	// Not specified. Should never be used.
	StreamingRecognitionResult_MESSAGE_TYPE_UNSPECIFIED StreamingRecognitionResult_MessageType = 0
	// Message contains a (possibly partial) transcript.
	StreamingRecognitionResult_TRANSCRIPT StreamingRecognitionResult_MessageType = 1
	// Event indicates that the server has detected the end of the user's speech
	// utterance and expects no additional speech. Therefore, the server will
	// not process additional audio (although it may subsequently return
	// additional results). The client should stop sending additional audio
	// data, half-close the gRPC connection, and wait for any additional results
	// until the server closes the gRPC connection. This message is only sent if
	// `single_utterance` was set to `true`, and is not used otherwise.
	StreamingRecognitionResult_END_OF_SINGLE_UTTERANCE StreamingRecognitionResult_MessageType = 2
)

var StreamingRecognitionResult_MessageType_name = map[int32]string{
	0: "MESSAGE_TYPE_UNSPECIFIED",
	1: "TRANSCRIPT",
	2: "END_OF_SINGLE_UTTERANCE",
}
var StreamingRecognitionResult_MessageType_value = map[string]int32{
	"MESSAGE_TYPE_UNSPECIFIED": 0,
	"TRANSCRIPT":               1,
	"END_OF_SINGLE_UTTERANCE":  2,
}

func (x StreamingRecognitionResult_MessageType) String() string {
	return proto.EnumName(StreamingRecognitionResult_MessageType_name, int32(x))
}
func (StreamingRecognitionResult_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor4, []int{7, 0}
}

// The request to detect user's intent.
type DetectIntentRequest struct {
	// Required. The name of the session this query is sent to. Format:
	// `projects/<Project ID>/agent/sessions/<Session ID>`.
	// It's up to the API caller to choose an appropriate session ID. It can be
	// a random number or some type of user identifier (preferably hashed).
	// The length of the session ID must not exceed 36 bytes.
	Session string `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	// Optional. The parameters of this query.
	QueryParams *QueryParameters `protobuf:"bytes,2,opt,name=query_params,json=queryParams" json:"query_params,omitempty"`
	// Required. The input specification. It can be set to:
	//
	// 1.  an audio config
	//     which instructs the speech recognizer how to process the speech audio,
	//
	// 2.  a conversational query in the form of text, or
	//
	// 3.  an event that specifies which intent to trigger.
	QueryInput *QueryInput `protobuf:"bytes,3,opt,name=query_input,json=queryInput" json:"query_input,omitempty"`
	// Optional. The natural language speech audio to be processed. This field
	// should be populated iff `query_input` is set to an input audio config.
	// A single request can contain up to 1 minute of speech audio data.
	InputAudio []byte `protobuf:"bytes,5,opt,name=input_audio,json=inputAudio,proto3" json:"input_audio,omitempty"`
}

func (m *DetectIntentRequest) Reset()                    { *m = DetectIntentRequest{} }
func (m *DetectIntentRequest) String() string            { return proto.CompactTextString(m) }
func (*DetectIntentRequest) ProtoMessage()               {}
func (*DetectIntentRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

func (m *DetectIntentRequest) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

func (m *DetectIntentRequest) GetQueryParams() *QueryParameters {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *DetectIntentRequest) GetQueryInput() *QueryInput {
	if m != nil {
		return m.QueryInput
	}
	return nil
}

func (m *DetectIntentRequest) GetInputAudio() []byte {
	if m != nil {
		return m.InputAudio
	}
	return nil
}

// The message returned from the DetectIntent method.
type DetectIntentResponse struct {
	// The unique identifier of the response. It can be used to
	// locate a response in the training example set or for reporting issues.
	ResponseId string `protobuf:"bytes,1,opt,name=response_id,json=responseId" json:"response_id,omitempty"`
	// The results of the conversational query or event processing.
	QueryResult *QueryResult `protobuf:"bytes,2,opt,name=query_result,json=queryResult" json:"query_result,omitempty"`
	// Specifies the status of the webhook request. `webhook_status`
	// is never populated in webhook requests.
	WebhookStatus *google_rpc.Status `protobuf:"bytes,3,opt,name=webhook_status,json=webhookStatus" json:"webhook_status,omitempty"`
}

func (m *DetectIntentResponse) Reset()                    { *m = DetectIntentResponse{} }
func (m *DetectIntentResponse) String() string            { return proto.CompactTextString(m) }
func (*DetectIntentResponse) ProtoMessage()               {}
func (*DetectIntentResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

func (m *DetectIntentResponse) GetResponseId() string {
	if m != nil {
		return m.ResponseId
	}
	return ""
}

func (m *DetectIntentResponse) GetQueryResult() *QueryResult {
	if m != nil {
		return m.QueryResult
	}
	return nil
}

func (m *DetectIntentResponse) GetWebhookStatus() *google_rpc.Status {
	if m != nil {
		return m.WebhookStatus
	}
	return nil
}

// Represents the parameters of the conversational query.
type QueryParameters struct {
	// Optional. The time zone of this conversational query from the
	// [time zone database](https://www.iana.org/time-zones), e.g.,
	// America/New_York, Europe/Paris. If not provided, the time zone specified in
	// agent settings is used.
	TimeZone string `protobuf:"bytes,1,opt,name=time_zone,json=timeZone" json:"time_zone,omitempty"`
	// Optional. The geo location of this conversational query.
	GeoLocation *google_type.LatLng `protobuf:"bytes,2,opt,name=geo_location,json=geoLocation" json:"geo_location,omitempty"`
	// Optional. The collection of contexts to be activated before this query is
	// executed.
	Contexts []*Context `protobuf:"bytes,3,rep,name=contexts" json:"contexts,omitempty"`
	// Optional. Specifies whether to delete all contexts in the current session
	// before the new ones are activated.
	ResetContexts bool `protobuf:"varint,4,opt,name=reset_contexts,json=resetContexts" json:"reset_contexts,omitempty"`
	// Optional. The collection of session entity types to replace or extend
	// developer entities with for this query only. The entity synonyms apply
	// to all languages.
	SessionEntityTypes []*SessionEntityType `protobuf:"bytes,5,rep,name=session_entity_types,json=sessionEntityTypes" json:"session_entity_types,omitempty"`
	// Optional. This field can be used to pass custom data into the webhook
	// associated with the agent. Arbitrary JSON objects are supported.
	Payload *google_protobuf4.Struct `protobuf:"bytes,6,opt,name=payload" json:"payload,omitempty"`
}

func (m *QueryParameters) Reset()                    { *m = QueryParameters{} }
func (m *QueryParameters) String() string            { return proto.CompactTextString(m) }
func (*QueryParameters) ProtoMessage()               {}
func (*QueryParameters) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{2} }

func (m *QueryParameters) GetTimeZone() string {
	if m != nil {
		return m.TimeZone
	}
	return ""
}

func (m *QueryParameters) GetGeoLocation() *google_type.LatLng {
	if m != nil {
		return m.GeoLocation
	}
	return nil
}

func (m *QueryParameters) GetContexts() []*Context {
	if m != nil {
		return m.Contexts
	}
	return nil
}

func (m *QueryParameters) GetResetContexts() bool {
	if m != nil {
		return m.ResetContexts
	}
	return false
}

func (m *QueryParameters) GetSessionEntityTypes() []*SessionEntityType {
	if m != nil {
		return m.SessionEntityTypes
	}
	return nil
}

func (m *QueryParameters) GetPayload() *google_protobuf4.Struct {
	if m != nil {
		return m.Payload
	}
	return nil
}

// Represents the query input. It can contain either:
//
// 1.  An audio config which
//     instructs the speech recognizer how to process the speech audio.
//
// 2.  A conversational query in the form of text,.
//
// 3.  An event that specifies which intent to trigger.
type QueryInput struct {
	// Required. The input specification.
	//
	// Types that are valid to be assigned to Input:
	//	*QueryInput_AudioConfig
	//	*QueryInput_Text
	//	*QueryInput_Event
	Input isQueryInput_Input `protobuf_oneof:"input"`
}

func (m *QueryInput) Reset()                    { *m = QueryInput{} }
func (m *QueryInput) String() string            { return proto.CompactTextString(m) }
func (*QueryInput) ProtoMessage()               {}
func (*QueryInput) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{3} }

type isQueryInput_Input interface {
	isQueryInput_Input()
}

type QueryInput_AudioConfig struct {
	AudioConfig *InputAudioConfig `protobuf:"bytes,1,opt,name=audio_config,json=audioConfig,oneof"`
}
type QueryInput_Text struct {
	Text *TextInput `protobuf:"bytes,2,opt,name=text,oneof"`
}
type QueryInput_Event struct {
	Event *EventInput `protobuf:"bytes,3,opt,name=event,oneof"`
}

func (*QueryInput_AudioConfig) isQueryInput_Input() {}
func (*QueryInput_Text) isQueryInput_Input()        {}
func (*QueryInput_Event) isQueryInput_Input()       {}

func (m *QueryInput) GetInput() isQueryInput_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *QueryInput) GetAudioConfig() *InputAudioConfig {
	if x, ok := m.GetInput().(*QueryInput_AudioConfig); ok {
		return x.AudioConfig
	}
	return nil
}

func (m *QueryInput) GetText() *TextInput {
	if x, ok := m.GetInput().(*QueryInput_Text); ok {
		return x.Text
	}
	return nil
}

func (m *QueryInput) GetEvent() *EventInput {
	if x, ok := m.GetInput().(*QueryInput_Event); ok {
		return x.Event
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QueryInput) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QueryInput_OneofMarshaler, _QueryInput_OneofUnmarshaler, _QueryInput_OneofSizer, []interface{}{
		(*QueryInput_AudioConfig)(nil),
		(*QueryInput_Text)(nil),
		(*QueryInput_Event)(nil),
	}
}

func _QueryInput_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QueryInput)
	// input
	switch x := m.Input.(type) {
	case *QueryInput_AudioConfig:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AudioConfig); err != nil {
			return err
		}
	case *QueryInput_Text:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Text); err != nil {
			return err
		}
	case *QueryInput_Event:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Event); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QueryInput.Input has unexpected type %T", x)
	}
	return nil
}

func _QueryInput_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QueryInput)
	switch tag {
	case 1: // input.audio_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InputAudioConfig)
		err := b.DecodeMessage(msg)
		m.Input = &QueryInput_AudioConfig{msg}
		return true, err
	case 2: // input.text
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextInput)
		err := b.DecodeMessage(msg)
		m.Input = &QueryInput_Text{msg}
		return true, err
	case 3: // input.event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EventInput)
		err := b.DecodeMessage(msg)
		m.Input = &QueryInput_Event{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QueryInput_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QueryInput)
	// input
	switch x := m.Input.(type) {
	case *QueryInput_AudioConfig:
		s := proto.Size(x.AudioConfig)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryInput_Text:
		s := proto.Size(x.Text)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryInput_Event:
		s := proto.Size(x.Event)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Represents the result of conversational query or event processing.
type QueryResult struct {
	// The original conversational query text:
	// - If natural language text was provided as input, `query_text` contains
	//   a copy of the input.
	// - If natural language speech audio was provided as input, `query_text`
	//   contains the speech recognition result. If speech recognizer produced
	//   multiple alternatives, a particular one is picked.
	// - If an event was provided as input, `query_text` is not set.
	QueryText string `protobuf:"bytes,1,opt,name=query_text,json=queryText" json:"query_text,omitempty"`
	// The language that was triggered during intent detection.
	// See [Language Support](https://dialogflow.com/docs/reference/language)
	// for a list of the currently supported language codes.
	LanguageCode string `protobuf:"bytes,15,opt,name=language_code,json=languageCode" json:"language_code,omitempty"`
	// The Speech recognition confidence between 0.0 and 1.0. A higher number
	// indicates an estimated greater likelihood that the recognized words are
	// correct. The default of 0.0 is a sentinel value indicating that confidence
	// was not set.
	//
	// You should not rely on this field as it isn't guaranteed to be accurate, or
	// even set. In particular this field isn't set in Webhook calls and for
	// StreamingDetectIntent since the streaming endpoint has separate confidence
	// estimates per portion of the audio in StreamingRecognitionResult.
	SpeechRecognitionConfidence float32 `protobuf:"fixed32,2,opt,name=speech_recognition_confidence,json=speechRecognitionConfidence" json:"speech_recognition_confidence,omitempty"`
	// The action name from the matched intent.
	Action string `protobuf:"bytes,3,opt,name=action" json:"action,omitempty"`
	// The collection of extracted parameters.
	Parameters *google_protobuf4.Struct `protobuf:"bytes,4,opt,name=parameters" json:"parameters,omitempty"`
	// This field is set to:
	// - `false` if the matched intent has required parameters and not all of
	//    the required parameter values have been collected.
	// - `true` if all required parameter values have been collected, or if the
	//    matched intent doesn't contain any required parameters.
	AllRequiredParamsPresent bool `protobuf:"varint,5,opt,name=all_required_params_present,json=allRequiredParamsPresent" json:"all_required_params_present,omitempty"`
	// The text to be pronounced to the user or shown on the screen.
	FulfillmentText string `protobuf:"bytes,6,opt,name=fulfillment_text,json=fulfillmentText" json:"fulfillment_text,omitempty"`
	// The collection of rich messages to present to the user.
	FulfillmentMessages []*Intent_Message `protobuf:"bytes,7,rep,name=fulfillment_messages,json=fulfillmentMessages" json:"fulfillment_messages,omitempty"`
	// If the query was fulfilled by a webhook call, this field is set to the
	// value of the `source` field returned in the webhook response.
	WebhookSource string `protobuf:"bytes,8,opt,name=webhook_source,json=webhookSource" json:"webhook_source,omitempty"`
	// If the query was fulfilled by a webhook call, this field is set to the
	// value of the `payload` field returned in the webhook response.
	WebhookPayload *google_protobuf4.Struct `protobuf:"bytes,9,opt,name=webhook_payload,json=webhookPayload" json:"webhook_payload,omitempty"`
	// The collection of output contexts. If applicable,
	// `output_contexts.parameters` contains entries with name
	// `<parameter name>.original` containing the original parameter values
	// before the query.
	OutputContexts []*Context `protobuf:"bytes,10,rep,name=output_contexts,json=outputContexts" json:"output_contexts,omitempty"`
	// The intent that matched the conversational query. Some, not
	// all fields are filled in this message, including but not limited to:
	// `name`, `display_name` and `webhook_state`.
	Intent *Intent `protobuf:"bytes,11,opt,name=intent" json:"intent,omitempty"`
	// The intent detection confidence. Values range from 0.0
	// (completely uncertain) to 1.0 (completely certain).
	IntentDetectionConfidence float32 `protobuf:"fixed32,12,opt,name=intent_detection_confidence,json=intentDetectionConfidence" json:"intent_detection_confidence,omitempty"`
	// The free-form diagnostic info. For example, this field
	// could contain webhook call latency.
	DiagnosticInfo *google_protobuf4.Struct `protobuf:"bytes,14,opt,name=diagnostic_info,json=diagnosticInfo" json:"diagnostic_info,omitempty"`
}

func (m *QueryResult) Reset()                    { *m = QueryResult{} }
func (m *QueryResult) String() string            { return proto.CompactTextString(m) }
func (*QueryResult) ProtoMessage()               {}
func (*QueryResult) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{4} }

func (m *QueryResult) GetQueryText() string {
	if m != nil {
		return m.QueryText
	}
	return ""
}

func (m *QueryResult) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

func (m *QueryResult) GetSpeechRecognitionConfidence() float32 {
	if m != nil {
		return m.SpeechRecognitionConfidence
	}
	return 0
}

func (m *QueryResult) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *QueryResult) GetParameters() *google_protobuf4.Struct {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *QueryResult) GetAllRequiredParamsPresent() bool {
	if m != nil {
		return m.AllRequiredParamsPresent
	}
	return false
}

func (m *QueryResult) GetFulfillmentText() string {
	if m != nil {
		return m.FulfillmentText
	}
	return ""
}

func (m *QueryResult) GetFulfillmentMessages() []*Intent_Message {
	if m != nil {
		return m.FulfillmentMessages
	}
	return nil
}

func (m *QueryResult) GetWebhookSource() string {
	if m != nil {
		return m.WebhookSource
	}
	return ""
}

func (m *QueryResult) GetWebhookPayload() *google_protobuf4.Struct {
	if m != nil {
		return m.WebhookPayload
	}
	return nil
}

func (m *QueryResult) GetOutputContexts() []*Context {
	if m != nil {
		return m.OutputContexts
	}
	return nil
}

func (m *QueryResult) GetIntent() *Intent {
	if m != nil {
		return m.Intent
	}
	return nil
}

func (m *QueryResult) GetIntentDetectionConfidence() float32 {
	if m != nil {
		return m.IntentDetectionConfidence
	}
	return 0
}

func (m *QueryResult) GetDiagnosticInfo() *google_protobuf4.Struct {
	if m != nil {
		return m.DiagnosticInfo
	}
	return nil
}

// The top-level message sent by the client to the
// `StreamingDetectIntent` method.
//
// Multiple request messages should be sent in order:
//
// 1.  The first message must contain `session`, `query_input` plus optionally
//     `query_params` and/or `single_utterance`. The message must not contain
//     `input_audio`.
//
// 2.  If `query_input` was set to a streaming input audio config,
//     all subsequent messages must contain only `input_audio`.
//     Otherwise, finish the request stream.
type StreamingDetectIntentRequest struct {
	// Required. The name of the session the query is sent to.
	// Format of the session name:
	// `projects/<Project ID>/agent/sessions/<Session ID>`.
	// It’s up to the API caller to choose an appropriate <Session ID>. It can be
	// a random number or some type of user identifier (preferably hashed).
	// The length of the session ID must not exceed 36 characters.
	Session string `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	// Optional. The parameters of this query.
	QueryParams *QueryParameters `protobuf:"bytes,2,opt,name=query_params,json=queryParams" json:"query_params,omitempty"`
	// Required. The input specification. It can be set to:
	//
	// 1.  an audio config which instructs the speech recognizer how to process
	//     the speech audio,
	//
	// 2.  a conversational query in the form of text, or
	//
	// 3.  an event that specifies which intent to trigger.
	QueryInput *QueryInput `protobuf:"bytes,3,opt,name=query_input,json=queryInput" json:"query_input,omitempty"`
	// Optional. If `true`, the recognizer will detect a single spoken utterance
	// in input audio. When it detects that the user has paused or stopped
	// speaking, it will cease recognition. This setting is ignored when
	// `query_input` is a piece of text or an event.
	SingleUtterance bool `protobuf:"varint,4,opt,name=single_utterance,json=singleUtterance" json:"single_utterance,omitempty"`
	// Optional. The input audio content to be recognized. Must be sent if
	// `query_input` was set to a streaming input audio config. The complete audio
	// over all streaming messages must not exceed 1 minute.
	InputAudio []byte `protobuf:"bytes,6,opt,name=input_audio,json=inputAudio,proto3" json:"input_audio,omitempty"`
}

func (m *StreamingDetectIntentRequest) Reset()                    { *m = StreamingDetectIntentRequest{} }
func (m *StreamingDetectIntentRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamingDetectIntentRequest) ProtoMessage()               {}
func (*StreamingDetectIntentRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{5} }

func (m *StreamingDetectIntentRequest) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

func (m *StreamingDetectIntentRequest) GetQueryParams() *QueryParameters {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *StreamingDetectIntentRequest) GetQueryInput() *QueryInput {
	if m != nil {
		return m.QueryInput
	}
	return nil
}

func (m *StreamingDetectIntentRequest) GetSingleUtterance() bool {
	if m != nil {
		return m.SingleUtterance
	}
	return false
}

func (m *StreamingDetectIntentRequest) GetInputAudio() []byte {
	if m != nil {
		return m.InputAudio
	}
	return nil
}

// The top-level message returned from the
// `StreamingDetectIntent` method.
//
// Multiple response messages can be returned in order:
//
// 1.  If the input was set to streaming audio, the first one or more messages
//     contain `recognition_result`. Each `recognition_result` represents a more
//     complete transcript of what the user said. The last `recognition_result`
//     has `is_final` set to `true`.
//
// 2.  The next message contains `response_id`, `query_result`
//     and optionally `webhook_status` if a WebHook was called.
type StreamingDetectIntentResponse struct {
	// The unique identifier of the response. It can be used to
	// locate a response in the training example set or for reporting issues.
	ResponseId string `protobuf:"bytes,1,opt,name=response_id,json=responseId" json:"response_id,omitempty"`
	// The result of speech recognition.
	RecognitionResult *StreamingRecognitionResult `protobuf:"bytes,2,opt,name=recognition_result,json=recognitionResult" json:"recognition_result,omitempty"`
	// The result of the conversational query or event processing.
	QueryResult *QueryResult `protobuf:"bytes,3,opt,name=query_result,json=queryResult" json:"query_result,omitempty"`
	// Specifies the status of the webhook request.
	WebhookStatus *google_rpc.Status `protobuf:"bytes,4,opt,name=webhook_status,json=webhookStatus" json:"webhook_status,omitempty"`
}

func (m *StreamingDetectIntentResponse) Reset()                    { *m = StreamingDetectIntentResponse{} }
func (m *StreamingDetectIntentResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamingDetectIntentResponse) ProtoMessage()               {}
func (*StreamingDetectIntentResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{6} }

func (m *StreamingDetectIntentResponse) GetResponseId() string {
	if m != nil {
		return m.ResponseId
	}
	return ""
}

func (m *StreamingDetectIntentResponse) GetRecognitionResult() *StreamingRecognitionResult {
	if m != nil {
		return m.RecognitionResult
	}
	return nil
}

func (m *StreamingDetectIntentResponse) GetQueryResult() *QueryResult {
	if m != nil {
		return m.QueryResult
	}
	return nil
}

func (m *StreamingDetectIntentResponse) GetWebhookStatus() *google_rpc.Status {
	if m != nil {
		return m.WebhookStatus
	}
	return nil
}

// Contains a speech recognition result corresponding to a portion of the audio
// that is currently being processed or an indication that this is the end
// of the single requested utterance.
//
// Example:
//
// 1.  transcript: "tube"
//
// 2.  transcript: "to be a"
//
// 3.  transcript: "to be"
//
// 4.  transcript: "to be or not to be"
//     is_final: true
//
// 5.  transcript: " that's"
//
// 6.  transcript: " that is"
//
// 7.  recognition_event_type: `RECOGNITION_EVENT_END_OF_SINGLE_UTTERANCE`
//
// 8.  transcript: " that is the question"
//     is_final: true
//
// Only two of the responses contain final results (#4 and #8 indicated by
// `is_final: true`). Concatenating these generates the full transcript: "to be
// or not to be that is the question".
//
// In each response we populate:
//
// *  for `MESSAGE_TYPE_TRANSCRIPT`: `transcript` and possibly `is_final`.
//
// *  for `MESSAGE_TYPE_END_OF_SINGLE_UTTERANCE`: only `event_type`.
type StreamingRecognitionResult struct {
	// Type of the result message.
	MessageType StreamingRecognitionResult_MessageType `protobuf:"varint,1,opt,name=message_type,json=messageType,enum=google.cloud.dialogflow.v2beta1.StreamingRecognitionResult_MessageType" json:"message_type,omitempty"`
	// Transcript text representing the words that the user spoke.
	// Populated if and only if `event_type` = `RECOGNITION_EVENT_TRANSCRIPT`.
	Transcript string `protobuf:"bytes,2,opt,name=transcript" json:"transcript,omitempty"`
	// The default of 0.0 is a sentinel value indicating `confidence` was not set.
	// If `false`, the `StreamingRecognitionResult` represents an
	// interim result that may change. If `true`, the recognizer will not return
	// any further hypotheses about this piece of the audio. May only be populated
	// for `event_type` = `RECOGNITION_EVENT_TRANSCRIPT`.
	IsFinal bool `protobuf:"varint,3,opt,name=is_final,json=isFinal" json:"is_final,omitempty"`
	// The Speech confidence between 0.0 and 1.0 for the current portion of audio.
	// A higher number indicates an estimated greater likelihood that the
	// recognized words are correct. The default of 0.0 is a sentinel value
	// indicating that confidence was not set.
	//
	// This field is typically only provided if `is_final` is true and you should
	// not rely on it being accurate or even set.
	Confidence float32 `protobuf:"fixed32,4,opt,name=confidence" json:"confidence,omitempty"`
}

func (m *StreamingRecognitionResult) Reset()                    { *m = StreamingRecognitionResult{} }
func (m *StreamingRecognitionResult) String() string            { return proto.CompactTextString(m) }
func (*StreamingRecognitionResult) ProtoMessage()               {}
func (*StreamingRecognitionResult) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{7} }

func (m *StreamingRecognitionResult) GetMessageType() StreamingRecognitionResult_MessageType {
	if m != nil {
		return m.MessageType
	}
	return StreamingRecognitionResult_MESSAGE_TYPE_UNSPECIFIED
}

func (m *StreamingRecognitionResult) GetTranscript() string {
	if m != nil {
		return m.Transcript
	}
	return ""
}

func (m *StreamingRecognitionResult) GetIsFinal() bool {
	if m != nil {
		return m.IsFinal
	}
	return false
}

func (m *StreamingRecognitionResult) GetConfidence() float32 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

// Instructs the speech recognizer how to process the audio content.
type InputAudioConfig struct {
	// Required. Audio encoding of the audio content to process.
	AudioEncoding AudioEncoding `protobuf:"varint,1,opt,name=audio_encoding,json=audioEncoding,enum=google.cloud.dialogflow.v2beta1.AudioEncoding" json:"audio_encoding,omitempty"`
	// Required. Sample rate (in Hertz) of the audio content sent in the query.
	// Refer to [Cloud Speech API documentation](/speech/docs/basics) for more
	// details.
	SampleRateHertz int32 `protobuf:"varint,2,opt,name=sample_rate_hertz,json=sampleRateHertz" json:"sample_rate_hertz,omitempty"`
	// Required. The language of the supplied audio. Dialogflow does not do
	// translations. See [Language
	// Support](https://dialogflow.com/docs/languages) for a list of the
	// currently supported language codes. Note that queries in the same session
	// do not necessarily need to specify the same language.
	LanguageCode string `protobuf:"bytes,3,opt,name=language_code,json=languageCode" json:"language_code,omitempty"`
	// Optional. The collection of phrase hints which are used to boost accuracy
	// of speech recognition.
	// Refer to [Cloud Speech API documentation](/speech/docs/basics#phrase-hints)
	// for more details.
	PhraseHints []string `protobuf:"bytes,4,rep,name=phrase_hints,json=phraseHints" json:"phrase_hints,omitempty"`
}

func (m *InputAudioConfig) Reset()                    { *m = InputAudioConfig{} }
func (m *InputAudioConfig) String() string            { return proto.CompactTextString(m) }
func (*InputAudioConfig) ProtoMessage()               {}
func (*InputAudioConfig) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{8} }

func (m *InputAudioConfig) GetAudioEncoding() AudioEncoding {
	if m != nil {
		return m.AudioEncoding
	}
	return AudioEncoding_AUDIO_ENCODING_UNSPECIFIED
}

func (m *InputAudioConfig) GetSampleRateHertz() int32 {
	if m != nil {
		return m.SampleRateHertz
	}
	return 0
}

func (m *InputAudioConfig) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

func (m *InputAudioConfig) GetPhraseHints() []string {
	if m != nil {
		return m.PhraseHints
	}
	return nil
}

// Represents the natural language text to be processed.
type TextInput struct {
	// Required. The UTF-8 encoded natural language text to be processed.
	// Text length must not exceed 256 bytes.
	Text string `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
	// Required. The language of this conversational query. See [Language
	// Support](https://dialogflow.com/docs/languages) for a list of the
	// currently supported language codes. Note that queries in the same session
	// do not necessarily need to specify the same language.
	LanguageCode string `protobuf:"bytes,2,opt,name=language_code,json=languageCode" json:"language_code,omitempty"`
}

func (m *TextInput) Reset()                    { *m = TextInput{} }
func (m *TextInput) String() string            { return proto.CompactTextString(m) }
func (*TextInput) ProtoMessage()               {}
func (*TextInput) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{9} }

func (m *TextInput) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *TextInput) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

// Events allow for matching intents by event name instead of the natural
// language input. For instance, input `<event: { name: “welcome_event”,
// parameters: { name: “Sam” } }>` can trigger a personalized welcome response.
// The parameter `name` may be used by the agent in the response:
// `“Hello #welcome_event.name! What can I do for you today?”`.
type EventInput struct {
	// Required. The unique identifier of the event.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Optional. The collection of parameters associated with the event.
	Parameters *google_protobuf4.Struct `protobuf:"bytes,2,opt,name=parameters" json:"parameters,omitempty"`
	// Required. The language of this query. See [Language
	// Support](https://dialogflow.com/docs/languages) for a list of the
	// currently supported language codes. Note that queries in the same session
	// do not necessarily need to specify the same language.
	LanguageCode string `protobuf:"bytes,3,opt,name=language_code,json=languageCode" json:"language_code,omitempty"`
}

func (m *EventInput) Reset()                    { *m = EventInput{} }
func (m *EventInput) String() string            { return proto.CompactTextString(m) }
func (*EventInput) ProtoMessage()               {}
func (*EventInput) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{10} }

func (m *EventInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventInput) GetParameters() *google_protobuf4.Struct {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *EventInput) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

func init() {
	proto.RegisterType((*DetectIntentRequest)(nil), "google.cloud.dialogflow.v2beta1.DetectIntentRequest")
	proto.RegisterType((*DetectIntentResponse)(nil), "google.cloud.dialogflow.v2beta1.DetectIntentResponse")
	proto.RegisterType((*QueryParameters)(nil), "google.cloud.dialogflow.v2beta1.QueryParameters")
	proto.RegisterType((*QueryInput)(nil), "google.cloud.dialogflow.v2beta1.QueryInput")
	proto.RegisterType((*QueryResult)(nil), "google.cloud.dialogflow.v2beta1.QueryResult")
	proto.RegisterType((*StreamingDetectIntentRequest)(nil), "google.cloud.dialogflow.v2beta1.StreamingDetectIntentRequest")
	proto.RegisterType((*StreamingDetectIntentResponse)(nil), "google.cloud.dialogflow.v2beta1.StreamingDetectIntentResponse")
	proto.RegisterType((*StreamingRecognitionResult)(nil), "google.cloud.dialogflow.v2beta1.StreamingRecognitionResult")
	proto.RegisterType((*InputAudioConfig)(nil), "google.cloud.dialogflow.v2beta1.InputAudioConfig")
	proto.RegisterType((*TextInput)(nil), "google.cloud.dialogflow.v2beta1.TextInput")
	proto.RegisterType((*EventInput)(nil), "google.cloud.dialogflow.v2beta1.EventInput")
	proto.RegisterEnum("google.cloud.dialogflow.v2beta1.AudioEncoding", AudioEncoding_name, AudioEncoding_value)
	proto.RegisterEnum("google.cloud.dialogflow.v2beta1.StreamingRecognitionResult_MessageType", StreamingRecognitionResult_MessageType_name, StreamingRecognitionResult_MessageType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Sessions service

type SessionsClient interface {
	// Processes a natural language query and returns structured, actionable data
	// as a result. This method is not idempotent, because it may cause contexts
	// and session entity types to be updated, which in turn might affect
	// results of future queries.
	DetectIntent(ctx context.Context, in *DetectIntentRequest, opts ...grpc.CallOption) (*DetectIntentResponse, error)
	// Processes a natural language query in audio format in a streaming fashion
	// and returns structured, actionable data as a result. This method is only
	// available via the gRPC API (not REST).
	StreamingDetectIntent(ctx context.Context, opts ...grpc.CallOption) (Sessions_StreamingDetectIntentClient, error)
}

type sessionsClient struct {
	cc *grpc.ClientConn
}

func NewSessionsClient(cc *grpc.ClientConn) SessionsClient {
	return &sessionsClient{cc}
}

func (c *sessionsClient) DetectIntent(ctx context.Context, in *DetectIntentRequest, opts ...grpc.CallOption) (*DetectIntentResponse, error) {
	out := new(DetectIntentResponse)
	err := grpc.Invoke(ctx, "/google.cloud.dialogflow.v2beta1.Sessions/DetectIntent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionsClient) StreamingDetectIntent(ctx context.Context, opts ...grpc.CallOption) (Sessions_StreamingDetectIntentClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Sessions_serviceDesc.Streams[0], c.cc, "/google.cloud.dialogflow.v2beta1.Sessions/StreamingDetectIntent", opts...)
	if err != nil {
		return nil, err
	}
	x := &sessionsStreamingDetectIntentClient{stream}
	return x, nil
}

type Sessions_StreamingDetectIntentClient interface {
	Send(*StreamingDetectIntentRequest) error
	Recv() (*StreamingDetectIntentResponse, error)
	grpc.ClientStream
}

type sessionsStreamingDetectIntentClient struct {
	grpc.ClientStream
}

func (x *sessionsStreamingDetectIntentClient) Send(m *StreamingDetectIntentRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sessionsStreamingDetectIntentClient) Recv() (*StreamingDetectIntentResponse, error) {
	m := new(StreamingDetectIntentResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Sessions service

type SessionsServer interface {
	// Processes a natural language query and returns structured, actionable data
	// as a result. This method is not idempotent, because it may cause contexts
	// and session entity types to be updated, which in turn might affect
	// results of future queries.
	DetectIntent(context.Context, *DetectIntentRequest) (*DetectIntentResponse, error)
	// Processes a natural language query in audio format in a streaming fashion
	// and returns structured, actionable data as a result. This method is only
	// available via the gRPC API (not REST).
	StreamingDetectIntent(Sessions_StreamingDetectIntentServer) error
}

func RegisterSessionsServer(s *grpc.Server, srv SessionsServer) {
	s.RegisterService(&_Sessions_serviceDesc, srv)
}

func _Sessions_DetectIntent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectIntentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionsServer).DetectIntent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.cloud.dialogflow.v2beta1.Sessions/DetectIntent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionsServer).DetectIntent(ctx, req.(*DetectIntentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sessions_StreamingDetectIntent_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SessionsServer).StreamingDetectIntent(&sessionsStreamingDetectIntentServer{stream})
}

type Sessions_StreamingDetectIntentServer interface {
	Send(*StreamingDetectIntentResponse) error
	Recv() (*StreamingDetectIntentRequest, error)
	grpc.ServerStream
}

type sessionsStreamingDetectIntentServer struct {
	grpc.ServerStream
}

func (x *sessionsStreamingDetectIntentServer) Send(m *StreamingDetectIntentResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sessionsStreamingDetectIntentServer) Recv() (*StreamingDetectIntentRequest, error) {
	m := new(StreamingDetectIntentRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Sessions_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.dialogflow.v2beta1.Sessions",
	HandlerType: (*SessionsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DetectIntent",
			Handler:    _Sessions_DetectIntent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamingDetectIntent",
			Handler:       _Sessions_StreamingDetectIntent_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "google/cloud/dialogflow/v2beta1/session.proto",
}

func init() { proto.RegisterFile("google/cloud/dialogflow/v2beta1/session.proto", fileDescriptor4) }

var fileDescriptor4 = []byte{
	// 1580 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0x3f, 0x73, 0x1b, 0xc7,
	0x15, 0xd7, 0x81, 0xff, 0x1f, 0x40, 0x12, 0x5e, 0xc9, 0xd6, 0x89, 0x94, 0x2c, 0x05, 0x1e, 0x4f,
	0x28, 0xc6, 0x01, 0x2c, 0x26, 0x71, 0xc6, 0xd6, 0xc8, 0x11, 0x08, 0x1c, 0x49, 0xcc, 0x80, 0x20,
	0xbc, 0x00, 0x2d, 0xdb, 0xcd, 0xce, 0xf2, 0xb0, 0x38, 0x9e, 0x72, 0xd8, 0x3d, 0xde, 0x2e, 0x6c,
	0xd3, 0x99, 0xa4, 0xc8, 0x57, 0x48, 0x97, 0x32, 0x4d, 0x66, 0xdc, 0xa6, 0x49, 0x93, 0xca, 0x1f,
	0x21, 0x75, 0xba, 0x94, 0x49, 0x95, 0x14, 0x99, 0x49, 0x93, 0xb9, 0xdd, 0x3d, 0x00, 0x02, 0x29,
	0x03, 0x4a, 0x52, 0xb9, 0xc3, 0xbe, 0xf7, 0x7b, 0x6f, 0xdf, 0x7b, 0xf7, 0x7b, 0xef, 0x2d, 0xe0,
	0x87, 0x81, 0x10, 0x41, 0xc4, 0x2a, 0x7e, 0x24, 0x86, 0xbd, 0x4a, 0x2f, 0xa4, 0x91, 0x08, 0xfa,
	0x91, 0xf8, 0xa2, 0xf2, 0xf9, 0xde, 0x19, 0x53, 0xf4, 0x51, 0x45, 0x32, 0x29, 0x43, 0xc1, 0xcb,
	0x71, 0x22, 0x94, 0x40, 0xf7, 0x0d, 0xbc, 0xac, 0xe1, 0xe5, 0x31, 0xbc, 0x6c, 0xe1, 0x5b, 0x77,
	0xad, 0x3f, 0x1a, 0x87, 0x15, 0xca, 0xb9, 0x50, 0x54, 0x85, 0x82, 0x4b, 0x63, 0xbe, 0x35, 0xf3,
	0x36, 0x5f, 0x70, 0xc5, 0xbe, 0x54, 0x16, 0xfe, 0xce, 0x2c, 0x78, 0xc8, 0x15, 0xe3, 0x19, 0xfa,
	0xfd, 0x39, 0x53, 0x21, 0x8c, 0xab, 0x50, 0x5d, 0x12, 0x75, 0x19, 0x33, 0x6b, 0x9a, 0x45, 0xad,
	0x4f, 0x67, 0xc3, 0x7e, 0x45, 0xaa, 0x64, 0xe8, 0x67, 0x8e, 0x6f, 0x5b, 0x6d, 0x12, 0xfb, 0x15,
	0xa9, 0xa8, 0x1a, 0x66, 0xe9, 0xb8, 0x56, 0x91, 0x7a, 0xaa, 0x44, 0x54, 0x45, 0x3c, 0x30, 0x9a,
	0xd2, 0x3f, 0x1c, 0xb8, 0x59, 0x67, 0x8a, 0xf9, 0xaa, 0xa1, 0x43, 0xc4, 0xec, 0x62, 0xc8, 0xa4,
	0x42, 0x2e, 0xac, 0xd8, 0x28, 0x5c, 0xe7, 0x81, 0xb3, 0xb3, 0x86, 0xb3, 0x23, 0xea, 0x40, 0xe1,
	0x62, 0xc8, 0x92, 0x4b, 0x12, 0xd3, 0x84, 0x0e, 0xa4, 0x9b, 0x7b, 0xe0, 0xec, 0xe4, 0xf7, 0xde,
	0x2d, 0xcf, 0x28, 0x78, 0xf9, 0xa3, 0xd4, 0xa8, 0x9d, 0xda, 0x30, 0xc5, 0x12, 0x89, 0xf3, 0x17,
	0x23, 0x81, 0x44, 0x4d, 0x30, 0x47, 0x12, 0xf2, 0x78, 0xa8, 0xdc, 0x05, 0xed, 0xf3, 0x07, 0xf3,
	0xf9, 0x6c, 0xa4, 0x26, 0x18, 0x2e, 0x46, 0xbf, 0xd1, 0x7d, 0xc8, 0x6b, 0x3f, 0x84, 0x0e, 0x7b,
	0xa1, 0x70, 0x97, 0x1e, 0x38, 0x3b, 0x05, 0x0c, 0x5a, 0x54, 0x4d, 0x25, 0xa5, 0x6f, 0x1c, 0xb8,
	0xf5, 0x62, 0xd6, 0x32, 0x16, 0x5c, 0xb2, 0xd4, 0x32, 0xb1, 0xbf, 0x49, 0xd8, 0xb3, 0xa9, 0x43,
	0x26, 0x6a, 0xf4, 0xd0, 0x49, 0x96, 0x7d, 0xc2, 0xe4, 0x30, 0x52, 0x36, 0xfb, 0x77, 0xe6, 0x8b,
	0x14, 0x6b, 0x1b, 0x9b, 0xb9, 0x39, 0xa0, 0xf7, 0x61, 0xe3, 0x0b, 0x76, 0x76, 0x2e, 0xc4, 0xcf,
	0x89, 0xf9, 0x64, 0x36, 0x79, 0x94, 0xb9, 0x4c, 0x62, 0xbf, 0xdc, 0xd1, 0x1a, 0xbc, 0x6e, 0x91,
	0xe6, 0x58, 0xfa, 0x5b, 0x0e, 0x36, 0xa7, 0xaa, 0x8a, 0xb6, 0x61, 0x4d, 0x85, 0x03, 0x46, 0xbe,
	0x12, 0x9c, 0xd9, 0xf0, 0x57, 0x53, 0xc1, 0x67, 0x82, 0x33, 0xf4, 0x1e, 0x14, 0x02, 0x26, 0x48,
	0x24, 0x7c, 0x4d, 0x76, 0x1b, 0xfc, 0xcd, 0xec, 0x26, 0xcd, 0xb3, 0x26, 0x55, 0x4d, 0x1e, 0xe0,
	0x7c, 0xc0, 0x44, 0xd3, 0xe2, 0x50, 0x1d, 0x56, 0x2d, 0xdf, 0xd3, 0xe8, 0x16, 0x76, 0xf2, 0x7b,
	0x3b, 0x33, 0x13, 0xae, 0x19, 0x03, 0x3c, 0xb2, 0x44, 0x6f, 0xc3, 0x46, 0xc2, 0x24, 0x53, 0x64,
	0xe4, 0x6b, 0xf1, 0x81, 0xb3, 0xb3, 0x8a, 0xd7, 0xb5, 0xb4, 0x96, 0xc1, 0x7a, 0x70, 0xeb, 0x1a,
	0xfe, 0x4b, 0x77, 0x49, 0x5f, 0xbc, 0x37, 0xf3, 0xe2, 0x8e, 0x31, 0xf6, 0xb4, 0x6d, 0xf7, 0x32,
	0x66, 0x18, 0xc9, 0x69, 0x91, 0x44, 0x8f, 0x60, 0x25, 0xa6, 0x97, 0x91, 0xa0, 0x3d, 0x77, 0x59,
	0x57, 0xe1, 0x76, 0xe6, 0x38, 0x6b, 0xad, 0x72, 0x47, 0xb7, 0x16, 0xce, 0x70, 0xa5, 0x7f, 0x3a,
	0x00, 0x63, 0xc2, 0xa1, 0x8f, 0xa1, 0xa0, 0xe9, 0x95, 0xa6, 0xd3, 0x0f, 0x03, 0x5d, 0xec, 0xfc,
	0xde, 0xa3, 0x99, 0xf1, 0x35, 0x46, 0x34, 0xac, 0x69, 0xc3, 0xa3, 0x1b, 0x38, 0x4f, 0xc7, 0x47,
	0xf4, 0x14, 0x16, 0xd3, 0x42, 0xd8, 0x8f, 0xb3, 0x3b, 0xd3, 0x5f, 0x97, 0x7d, 0xa9, 0xb4, 0xcf,
	0xa3, 0x1b, 0x58, 0x5b, 0xa2, 0x1a, 0x2c, 0xb1, 0xcf, 0x19, 0x9f, 0xbf, 0x8d, 0xbc, 0x14, 0x9d,
	0xf9, 0x30, 0xb6, 0xfb, 0x2b, 0xb0, 0xa4, 0x1b, 0xa6, 0xf4, 0x87, 0x65, 0xc8, 0x4f, 0xb0, 0x17,
	0xdd, 0x03, 0xd3, 0x6a, 0x44, 0x47, 0x69, 0x28, 0xb6, 0xa6, 0x25, 0x69, 0x24, 0xe8, 0x2d, 0x58,
	0x8f, 0x28, 0x0f, 0x86, 0x34, 0x60, 0xc4, 0x17, 0x3d, 0xe6, 0x6e, 0x6a, 0x44, 0x21, 0x13, 0xd6,
	0x44, 0x8f, 0xa1, 0x7d, 0xb8, 0x27, 0x63, 0xc6, 0xfc, 0x73, 0x92, 0x30, 0x5f, 0x04, 0x3c, 0x4c,
	0x69, 0x66, 0x0a, 0xd9, 0x63, 0xdc, 0x67, 0x3a, 0xf9, 0x1c, 0xde, 0x36, 0x20, 0x3c, 0xc6, 0xd4,
	0x46, 0x10, 0xf4, 0x06, 0x2c, 0x53, 0x5f, 0xd3, 0x78, 0x41, 0xdf, 0x60, 0x4f, 0xe8, 0xa7, 0x00,
	0xf1, 0xa8, 0x1f, 0x34, 0xc5, 0xbe, 0xe5, 0xe3, 0x4e, 0x40, 0xd1, 0x13, 0xd8, 0xa6, 0x51, 0x44,
	0x12, 0x76, 0x31, 0x0c, 0x13, 0xd6, 0xb3, 0xf3, 0x8d, 0xc4, 0x29, 0x3d, 0xb9, 0xd2, 0x53, 0x64,
	0x15, 0xbb, 0x34, 0x8a, 0xb0, 0x45, 0x98, 0xd9, 0xd5, 0x36, 0x7a, 0xf4, 0x10, 0x8a, 0xfd, 0x61,
	0xd4, 0x0f, 0xa3, 0x68, 0xc0, 0xb8, 0x32, 0xd5, 0x59, 0xd6, 0x91, 0x6d, 0x4e, 0xc8, 0x75, 0x8d,
	0xce, 0xe0, 0xd6, 0x24, 0x74, 0xc0, 0xa4, 0xa4, 0x01, 0x93, 0xee, 0x8a, 0xa6, 0x78, 0x65, 0x0e,
	0x0a, 0xe9, 0x6d, 0x72, 0x6c, 0xec, 0xf0, 0xcd, 0x09, 0x67, 0x56, 0xa6, 0xbb, 0x6d, 0x34, 0x57,
	0xc4, 0x30, 0xf1, 0x99, 0xbb, 0xaa, 0x83, 0x19, 0xcd, 0x10, 0x2d, 0x44, 0x4f, 0x61, 0x33, 0x83,
	0x65, 0xfd, 0xb0, 0xf6, 0xed, 0x25, 0xcb, 0xdc, 0xb6, 0x0d, 0x1c, 0x7d, 0x04, 0x9b, 0x62, 0xa8,
	0xd2, 0x69, 0x3b, 0xea, 0x6b, 0x78, 0xc5, 0x19, 0xb1, 0x61, 0x1c, 0x8c, 0x46, 0xc0, 0xcf, 0x60,
	0xd9, 0x2c, 0x4c, 0x37, 0xaf, 0x63, 0xf9, 0xfe, 0x9c, 0x15, 0xc1, 0xd6, 0x0c, 0x7d, 0x08, 0xdb,
	0xe6, 0x17, 0xe9, 0xe9, 0x29, 0x3f, 0xc5, 0xae, 0x82, 0x66, 0xd7, 0x1d, 0x03, 0xa9, 0x67, 0x88,
	0x09, 0x6e, 0x3d, 0x85, 0xcd, 0x5e, 0x48, 0x03, 0x2e, 0xa4, 0x0a, 0x7d, 0x12, 0xf2, 0xbe, 0x70,
	0x37, 0x66, 0x54, 0x65, 0x8c, 0x6f, 0xf0, 0xbe, 0x28, 0xfd, 0x3e, 0x07, 0x77, 0x3b, 0x2a, 0x61,
	0x74, 0x10, 0xf2, 0xe0, 0x3b, 0xb7, 0x60, 0x1f, 0x42, 0x51, 0x86, 0x3c, 0x88, 0x18, 0x19, 0x2a,
	0xc5, 0x12, 0x9a, 0x16, 0xd5, 0x0c, 0xf3, 0x4d, 0x23, 0x3f, 0xcd, 0xc4, 0xd3, 0xbb, 0x78, 0xf9,
	0xca, 0x2e, 0xfe, 0x63, 0x0e, 0xee, 0xbd, 0xa4, 0x52, 0xf3, 0x2e, 0xe5, 0xe7, 0x80, 0x26, 0xe7,
	0xc8, 0x0b, 0xab, 0xf9, 0xf1, 0xec, 0x85, 0x91, 0x5d, 0x3e, 0x31, 0x67, 0xec, 0xa6, 0x7e, 0x2d,
	0x99, 0x16, 0x5d, 0x79, 0x00, 0x2c, 0xfc, 0xff, 0x1f, 0x00, 0x8b, 0xf3, 0x3e, 0x00, 0xfe, 0x94,
	0x83, 0xad, 0x97, 0x47, 0x8f, 0x9e, 0x43, 0xc1, 0x8e, 0x16, 0xbd, 0x42, 0x75, 0xe1, 0x36, 0xf6,
	0x0e, 0xff, 0x87, 0x82, 0x64, 0x23, 0x47, 0xaf, 0xd5, 0xfc, 0x60, 0x7c, 0x40, 0x6f, 0x02, 0xa8,
	0x84, 0x72, 0xe9, 0x27, 0x61, 0x6c, 0x4a, 0xbf, 0x86, 0x27, 0x24, 0xe8, 0x0e, 0xac, 0x86, 0x92,
	0xf4, 0x43, 0x4e, 0x23, 0x5d, 0xb2, 0x55, 0xbc, 0x12, 0xca, 0x83, 0xf4, 0x98, 0x9a, 0x4e, 0xf4,
	0xe6, 0xa2, 0xee, 0xcd, 0x09, 0x49, 0xe9, 0x13, 0xc8, 0x4f, 0x5c, 0x8b, 0xee, 0x82, 0x7b, 0xec,
	0x75, 0x3a, 0xd5, 0x43, 0x8f, 0x74, 0x3f, 0x6d, 0x7b, 0xe4, 0xb4, 0xd5, 0x69, 0x7b, 0xb5, 0xc6,
	0x41, 0xc3, 0xab, 0x17, 0x6f, 0xa0, 0x0d, 0x80, 0x2e, 0xae, 0xb6, 0x3a, 0x35, 0xdc, 0x68, 0x77,
	0x8b, 0x0e, 0xda, 0x86, 0xdb, 0x5e, 0xab, 0x4e, 0x4e, 0x0e, 0x48, 0xa7, 0xd1, 0x3a, 0x6c, 0x7a,
	0xe4, 0xb4, 0xdb, 0xf5, 0x70, 0xb5, 0x55, 0xf3, 0x8a, 0xb9, 0xd2, 0x5f, 0x1c, 0x28, 0x4e, 0xaf,
	0x63, 0x74, 0x0a, 0x1b, 0x66, 0xaf, 0x33, 0xee, 0x8b, 0x5e, 0xc8, 0x03, 0x5b, 0xb7, 0xf2, 0xcc,
	0xba, 0x69, 0x2f, 0x9e, 0xb5, 0xc2, 0xeb, 0x74, 0xf2, 0x88, 0x76, 0xe1, 0x35, 0x49, 0x07, 0x71,
	0xc4, 0x48, 0x42, 0x15, 0x23, 0xe7, 0x2c, 0x51, 0x5f, 0xe9, 0x3a, 0x2d, 0xe1, 0x4d, 0xa3, 0xc0,
	0x54, 0xb1, 0xa3, 0x54, 0x7c, 0x75, 0x87, 0x2e, 0x5c, 0xb3, 0x43, 0xbf, 0x07, 0x85, 0xf8, 0x3c,
	0xa1, 0x92, 0x91, 0xf3, 0x90, 0xeb, 0xc7, 0xd4, 0xc2, 0xce, 0x1a, 0xce, 0x1b, 0xd9, 0x51, 0x2a,
	0x2a, 0xd5, 0x61, 0x6d, 0xf4, 0x3a, 0x40, 0xc8, 0xbe, 0x2b, 0x4c, 0xfb, 0x98, 0x97, 0xc2, 0x95,
	0x8b, 0x72, 0x57, 0x2f, 0x2a, 0xfd, 0x0a, 0x60, 0xfc, 0x40, 0x48, 0xdd, 0x70, 0x3a, 0xc8, 0xde,
	0x96, 0xfa, 0xf7, 0xd4, 0xca, 0xcd, 0xcd, 0xbf, 0x72, 0xe7, 0x49, 0x74, 0xf7, 0xdf, 0x0e, 0xac,
	0xbf, 0x50, 0x5a, 0xf4, 0x26, 0x6c, 0x55, 0x4f, 0xeb, 0x8d, 0x13, 0xe2, 0xb5, 0x6a, 0x27, 0xf5,
	0x46, 0xeb, 0x70, 0x8a, 0x04, 0x77, 0xc1, 0x9d, 0xd2, 0x37, 0x1b, 0x2d, 0xaf, 0x8a, 0xc9, 0xa3,
	0xf7, 0x8a, 0x0e, 0xba, 0x0d, 0x37, 0xa7, 0xb4, 0x07, 0xcd, 0x6a, 0xad, 0x98, 0x43, 0x2e, 0xdc,
	0x9a, 0x52, 0x1c, 0x9f, 0x36, 0xab, 0xcf, 0x8a, 0x0b, 0xe8, 0x0d, 0x40, 0x53, 0x9a, 0xea, 0x31,
	0x2e, 0x2e, 0xa2, 0x3b, 0xf0, 0xfa, 0x55, 0x39, 0x79, 0xb6, 0x5f, 0x5c, 0x4a, 0x89, 0x37, 0xa5,
	0x3a, 0x39, 0x3c, 0x24, 0x27, 0xed, 0xd3, 0x4e, 0x71, 0x19, 0x3d, 0x84, 0xb7, 0xa7, 0x94, 0x9d,
	0xb6, 0xe7, 0x7d, 0x42, 0x9e, 0x35, 0xba, 0x47, 0xe4, 0xc8, 0xab, 0xd6, 0x3d, 0x4c, 0xf6, 0x3f,
	0xed, 0x7a, 0xc5, 0x95, 0xbd, 0xbf, 0xe7, 0x60, 0xd5, 0x3e, 0x69, 0x25, 0xfa, 0xc6, 0x81, 0xc2,
	0xe4, 0x88, 0x44, 0x3f, 0x9e, 0x49, 0xca, 0x6b, 0x76, 0xcf, 0xd6, 0x4f, 0x5e, 0xd1, 0xca, 0x0c,
	0xda, 0xd2, 0xc1, 0xaf, 0xff, 0xfc, 0xd7, 0xdf, 0xe4, 0x9e, 0x96, 0x1e, 0x8f, 0xfe, 0xa8, 0xfe,
	0xc2, 0xee, 0xac, 0x27, 0x71, 0x22, 0x9e, 0x33, 0x5f, 0xc9, 0xca, 0x6e, 0x85, 0x06, 0x8c, 0xab,
	0xec, 0x2f, 0xac, 0xac, 0xec, 0xfe, 0xf2, 0x83, 0xde, 0x84, 0xb3, 0x0f, 0x9c, 0x5d, 0xf4, 0x5b,
	0x07, 0x5e, 0xbf, 0x76, 0xe2, 0xa3, 0x27, 0xf3, 0xcf, 0xa6, 0xeb, 0xf2, 0xfa, 0xf0, 0xbf, 0x35,
	0x37, 0x09, 0xee, 0x38, 0xef, 0x3a, 0xfb, 0x5f, 0x3b, 0xf0, 0x96, 0x2f, 0x06, 0xb3, 0x3c, 0xed,
	0x17, 0xec, 0x47, 0x69, 0xa7, 0xf4, 0x6e, 0x3b, 0x9f, 0x35, 0xac, 0x41, 0x20, 0x52, 0xf2, 0x96,
	0x45, 0x12, 0x54, 0x02, 0xc6, 0x35, 0xf9, 0x2b, 0x46, 0x45, 0xe3, 0x50, 0xbe, 0xf4, 0x3f, 0xff,
	0xe3, 0xb1, 0xe8, 0x5f, 0x8e, 0xf3, 0xbb, 0x5c, 0xae, 0x7e, 0xf0, 0x75, 0xee, 0xfe, 0xa1, 0xf1,
	0x59, 0xd3, 0x41, 0xd4, 0xc7, 0x41, 0x7c, 0x6c, 0x8c, 0xce, 0x96, 0xb5, 0xff, 0x1f, 0xfd, 0x27,
	0x00, 0x00, 0xff, 0xff, 0x78, 0xce, 0xe5, 0x99, 0x1d, 0x11, 0x00, 0x00,
}

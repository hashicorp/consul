// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

syntax = "proto3";

package hashicorp.consul.proxystate.v1alpha1;

import "google/protobuf/wrappers.proto";
import "google/protobuf/duration.proto";

message Route {
  // name is the name of the route.
  string name = 1;
  // virtual_hosts is a list of virtual hosts. A virtual host is selected based on an incoming request's host header.
  repeated VirtualHost virtual_hosts = 2;
}

message VirtualHost {
  string name = 1;
  // domains are used to match an incoming request's host header and determine which virtual host to use.
  repeated string domains = 2;
  // header_mutations to apply to the request when it matches this virtual host. These are applied after any headers in
  // the RouteRule.
  repeated HeaderMutation header_mutations = 3;
  // route_rules are a list of rules to use for what to do next with this request. The first rule with a match will be
  // used.
  repeated RouteRule route_rules = 4;
}

message RouteRule {
  // match determines how to match the request. The first match determines which destination the request will go to.
  RouteMatch match = 1;
  // destination is where to send the request to.
  RouteDestination destination = 2;
  // header_mutations to apply to the request. These are applied before the VirtualHost header mutations.
  repeated HeaderMutation header_mutations = 3;
}

// RouteMatch has configuration to match a request.
message RouteMatch {
  oneof path_match {
    string exact = 1;
    string prefix = 2;
    string regex = 3;
  }
  repeated HeaderMatch header_matches = 4;
  repeated string method_matches = 5;
  repeated QueryParameterMatch query_parameter_matches = 6;
}

message QueryParameterMatch {
  string name = 1;
  oneof match {
    string exact = 2;
    string regex = 3;
    bool present = 4;
  }
}

message HeaderMatch {
  string name = 1;
  oneof match {
    string exact = 2;
    string prefix = 3;
    string suffix = 4;
    string regex = 5;
    bool present = 6;
  }
  bool invert_match = 7;
}

// RouteDestination has configuration for where to send a request.
message RouteDestination {
  // destination is one or more clusters to route to.
  oneof destination{
    DestinationCluster cluster = 1;
    WeightedDestinationClusters weighted_clusters = 2;
  }
  DestinationConfiguration destination_configuration = 3;
}

message DestinationConfiguration {
  google.protobuf.BoolValue auto_host_rewrite = 1;
  repeated LoadBalancerHashPolicy hash_policies = 2;
  TimeoutConfig timeout_config = 3;
  string prefix_rewrite = 4;
  RetryPolicy retry_policy = 5;

}

message RetryPolicy {
  string retry_on = 1;
  google.protobuf.UInt32Value num_retries = 2;
  repeated uint32 retriable_status_codes = 3;
}

message TimeoutConfig {
  google.protobuf.Duration timeout = 1;
  google.protobuf.Duration idle_timeout = 2;
}

message LoadBalancerHashPolicy {
  oneof policy {
    CookiePolicy cookie = 1;
    HeaderPolicy header = 2;
    QueryParameterPolicy query_parameter = 3;
    ConnectionPropertiesPolicy connection_properties = 4;
  }
}

message CookiePolicy {
  string name = 1;
  google.protobuf.Duration ttl = 2;
  string path = 3;
  bool terminal = 4;
}
message HeaderPolicy {
  string name = 1;
  bool terminal = 2;
}
message QueryParameterPolicy {
  string name = 1;
  bool terminal = 2;
}
message ConnectionPropertiesPolicy {
  bool source_ip = 1;
  bool terminal = 2;
}

message DestinationCluster {
  // name is the name of the cluster. This will be used to look up a cluster in the clusters map.
  string name = 1;
}

message WeightedDestinationClusters {
  // clusters to route to by weight.
  repeated WeightedDestinationCluster clusters = 1;
  google.protobuf.UInt32Value total_weight = 2;
}

message WeightedDestinationCluster {
  // name is the name of the cluster. This will be used to look up a cluster in the clusters map.
  string name = 1;
  google.protobuf.UInt32Value weight = 2;
  repeated HeaderMutation header_mutations = 3;
}

// Note: it's nice to have this list of header mutations as opposed to configuration similar to Envoy because it
// translates more nicely from GAMMA HTTPRoute, and our existing service router config. Then xds code can handle turning
// it into envoy xds.
message HeaderMutation {
  oneof action {
    RequestHeaderAdd request_header_add = 1;
    RequestHeaderRemove request_header_remove = 2;
    ResponseHeaderAdd response_header_add = 3;
    ResponseHeaderRemove response_header_remove = 4;

  }
}

message RequestHeaderAdd {
  Header header = 1;
  AppendAction append_action = 2;
}

message RequestHeaderRemove {
  repeated string header_keys = 1;
}

message ResponseHeaderAdd {
  Header header = 1;
  AppendAction append_action = 2;
}

message ResponseHeaderRemove {
  repeated string header_keys = 1;
}

message Header {
  string key = 1;
  string value = 2;
}

enum AppendAction {
  APPEND_ACTION_APPEND_IF_EXISTS_OR_ADD = 0;
  APPEND_ACTION_OVERWRITE_IF_EXISTS_OR_ADD = 1;
}


package logging

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/hashicorp/hil"
	"github.com/hashicorp/hil/ast"
)

var (
	now = time.Now
)

//LogFile is used to setup a file based logger that also performs log rotation
type LogFile struct {
	//Name of the log file
	fileName string

	//Path to the log file
	logPath string

	//Duration between each file rotation operation
	duration time.Duration

	//LastCreated represents the creation time of the latest log
	LastCreated time.Time

	//FileInfo is the pointer to the current file being written to
	FileInfo *os.File

	//MaxBytes is the maximum number of desired bytes for a log file
	MaxBytes int

	//BytesWritten is the number of bytes written in the current log file
	BytesWritten int64

	// Max rotated files to keep before removing them.
	MaxFiles int

	//acquire is the mutex utilized to ensure we have no concurrency issues
	acquire sync.Mutex
}

// Splits a full filename ("consul.log") into the name without extension ("consul")
// and the extension (".log"). If the full filename has no extension, the ".log"
// extension will be returned.
func splitExtensionFromFileName(fileName string) (fileNameWithoutExt string, fileExt string) {
	// Extract the file extension
	fileExt = filepath.Ext(fileName)

	// If we have no file extension we append .log
	if fileExt == "" {
		fileExt = ".log"
	}

	// Remove the file extension from the filename
	fileNameWithoutExt = strings.TrimSuffix(fileName, fileExt)

	return
}

// Based on the configured filename, generates an output filename with the
// following characteristics:
// - the ".log" extension is appended if the configured filename has no extension
// - a Unix timestamp is appended before the extension unless the configured
//   filename is a template that uses ${timestamp-human} or ${timestamp-unix}
// - occurrences of ${timestamp-human} are replaced with the
//   timestampStringHumanReadable input
// - occurrences of ${timestamp-unix} are replaced with the
//   timestampStringUnix input
func (l *LogFile) getGenericFileName(timestampStringUnix string, timestampStringHumanReadable string) (string, error) {
	fileNameWithoutExt, fileExt := splitExtensionFromFileName(l.fileName)

	parsedFileNameWithoutExtNode, err := hil.Parse(fileNameWithoutExt)
	if err != nil {
		return "", fmt.Errorf("failed to parse log filename template: %s", err)
	}

	// Build HIL evaluation context that maps template fields to values
	nodeEvalConfig := &hil.EvalConfig{
		GlobalScope: &ast.BasicScope{
			VarMap: map[string]ast.Variable{
				"timestamp-human": {
					Type:  ast.TypeString,
					Value: timestampStringHumanReadable,
				},
				"timestamp-unix": {
					Type:  ast.TypeString,
					Value: timestampStringUnix,
				},
			},
		},
	}

	// Replace templates with values
	fileNameWithoutExtEvalResult, err := hil.Eval(parsedFileNameWithoutExtNode, nodeEvalConfig)
	if err != nil {
		return "", fmt.Errorf("failed to evaluate log filename template: %s", err)
	}
	if fileNameWithoutExtEvalResult.Type != hil.TypeString {
		return "", fmt.Errorf("expected log filename template to evaluate to TypeString, not %s",
			fileNameWithoutExtEvalResult.Type)
	}

	evaluatedFileNameWithoutExt := fileNameWithoutExtEvalResult.Value.(string)

	// If a valid timestamp has not been injected to the string, append one.
	//
	// Ideally, there would be some way to check whether the hil.Eval used any
	// of the variables in the provided evaluation context, but I'm not aware
	// of such a way. Therefore, search for whether any of the variables were
	// injected into the output string instead.
	if !strings.Contains(evaluatedFileNameWithoutExt, timestampStringUnix) &&
		!strings.Contains(evaluatedFileNameWithoutExt, timestampStringHumanReadable) {
		evaluatedFileNameWithoutExt += "-" + timestampStringUnix
	}

	// Append extension to get final filename
	return evaluatedFileNameWithoutExt + fileExt, nil
}

// Generates a filename using getGenericFileName where:
// - timestampStringUnix is createTime in Unix timestamp format
// - timestampStringHumanReadable is createTime in
//   YEAR-MONTH-DATE_HOUR-MINUTE-SECOND-NANOSECOND format
func (l *LogFile) getNewFileName(createTime time.Time) (string, error) {
	// Build HIL evaluation context that maps template fields to values
	timestampStringUnix:= strconv.FormatInt(createTime.UnixNano(), 10)
	timestampStringHumanReadable := fmt.Sprintf("%04d-%02d-%02d_%02d-%02d-%02d-%09d",
        createTime.Year(), createTime.Month(), createTime.Day(),
        createTime.Hour(), createTime.Minute(), createTime.Second(),
        createTime.Nanosecond())

    return l.getGenericFileName(timestampStringUnix, timestampStringHumanReadable)
}

// Generates a filename using getGenericFileName where both timestampStringUnix
// and timestampStringHumanReadable are the glob character "*". Allows for
// matching against filenames generated by this LogFile.
func (l *LogFile) getGlobFileName() (string, error) {
	return l.getGenericFileName("*", "*")
}

func (l *LogFile) openNew() error {
	createTime := now()
	newfileName, err := l.getNewFileName(createTime)
	if err != nil {
		return err
	}
	newfilePath := filepath.Join(l.logPath, newfileName)

	// Try creating a file. We truncate the file because we are the only authority to write the logs
	filePointer, err := os.OpenFile(newfilePath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0640)
	if err != nil {
		return err
	}

	l.FileInfo = filePointer
	// New file, new bytes tracker, new creation time :)
	l.LastCreated = createTime
	l.BytesWritten = 0
	return nil
}

func (l *LogFile) rotate() error {
	// Get the time from the last point of contact
	timeElapsed := time.Since(l.LastCreated)
	// Rotate if we hit the byte file limit or the time limit
	if (l.BytesWritten >= int64(l.MaxBytes) && (l.MaxBytes > 0)) || timeElapsed >= l.duration {
		l.FileInfo.Close()
		if err := l.pruneFiles(); err != nil {
			return err
		}
		return l.openNew()
	}
	return nil
}

func (l *LogFile) pruneFiles() error {
	if l.MaxFiles == 0 {
		return nil
	}

	globFileName, err := l.getGlobFileName()
	if err != nil {
		return err
	}

	pattern := filepath.Join(l.logPath, globFileName)
	matches, err := filepath.Glob(pattern)
	if err != nil {
		return err
	}

	switch {
	case l.MaxFiles < 0:
		return removeFiles(matches)
	case len(matches) < l.MaxFiles:
		return nil
	}

	sort.Strings(matches)
	last := len(matches) - l.MaxFiles
	return removeFiles(matches[:last])
}

func removeFiles(files []string) error {
	for _, file := range files {
		if err := os.Remove(file); err != nil {
			return err
		}
	}
	return nil
}

// Write is used to implement io.Writer
func (l *LogFile) Write(b []byte) (n int, err error) {
	l.acquire.Lock()
	defer l.acquire.Unlock()
	// Create a new file if we have no file to write to
	if l.FileInfo == nil {
		if err := l.openNew(); err != nil {
			return 0, err
		}
	}
	// Check for the last contact and rotate if necessary
	if err := l.rotate(); err != nil {
		return 0, err
	}
	l.BytesWritten += int64(len(b))
	return l.FileInfo.Write(b)
}

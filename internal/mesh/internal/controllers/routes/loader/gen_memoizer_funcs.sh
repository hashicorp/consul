#!/usr/bin/env bash
# Copyright (c) HashiCorp, Inc.
# SPDX-License-Identifier: BUSL-1.1

unset CDPATH

set -euo pipefail

# NOTE: this script could be made more generic if folks find it useful.

if [[ $# -lt 2 ]]; then
    echo "expected at least 2 args" >&2
    exit 1
fi

# first argument is output path
output="$1"
shift

if [[ "$output" != *.go ]]; then
    echo "output file should end with a .go suffix" >&2
    exit 2
fi

cat > "${output}.tmp" <<EOF
// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: BUSL-1.1
package loader

// Code generated by gen_memoizer_funcs.sh. DO NOT EDIT.

import (
	"context"
	"fmt"

	"github.com/hashicorp/consul/internal/catalog"
	"github.com/hashicorp/consul/internal/mesh/internal/types"
	"github.com/hashicorp/consul/internal/resource"
	pbcatalog "github.com/hashicorp/consul/proto-public/pbcatalog/v1alpha1"
	pbmesh "github.com/hashicorp/consul/proto-public/pbmesh/v1alpha1"
	"github.com/hashicorp/consul/proto-public/pbresource"
)

// Avoid unused imports in generated code.
var _ *pbmesh.ParentReference

var _ *pbcatalog.Service

var _ = types.HTTPRouteType

var _ = catalog.ServiceType

EOF

# each argument is the name of a protobuf type
for typ in "$@"; do
    IFS=. read pkg message <<<"${typ}"
    if [[ -z "$pkg" ]] || [[ -z "$message" ]]; then
        echo "input should be a list of 'pkg.Name' strings" >&2
        exit 1
    fi
    gopkg="types"
    if [[ "$pkg" = "pbcatalog" ]]; then
        gopkg="catalog"
    fi
    ######################
    cat >> "${output}.tmp" <<EOF
func (m *memoizingLoader) Get${message}(ctx context.Context, id *pbresource.ID) (*types.Decoded${message}, error) {
	if !resource.EqualType(id.Type, ${gopkg}.${message}Type) {
		return nil, fmt.Errorf("expected *${pkg}.${message}, not %s", resource.TypeToString(id.Type))
	}

	rk := resource.NewReferenceKey(id)

	if cached, ok := m.map${message}[rk]; ok {
		return cached, nil // cached value may be nil
	}

	dec, err := resource.GetDecodedResource[${pkg}.${message}, *${pkg}.${message}](ctx, m.client, id)
	if err != nil {
		return nil, err
	}

	m.map${message}[rk] = dec
	return dec, nil
}

EOF
done

mv -f "${output}.tmp" "${output}"
gofmt -s -w "${output}"

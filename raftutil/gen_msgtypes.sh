#!/bin/sh

set -e

generate_file() {
  cat <<EOF
// Code generated by go generate; DO NOT EDIT.
package raftutil

import "github.com/hashicorp/consul/agent/structs"

var msgTypeNames = map[structs.MessageType]string{
EOF
  cat ../../consul/agent/structs/structs.go |
    grep -A500 'MessageType = 0' |
    grep -v -e '//' |
    grep -v -e '^$' |
    awk '/^\)$/ { exit; } /.*/ { printf "  structs.%s: \"%s\",\n", $1, $1}'

  echo '}'
}

echo "==> Generating type map..."
generate_file > msgtypes.go

echo "==> Formatting type map..."
gofmt -w msgtypes.go
# grep -A500 'MessageType = 0':
#         => This uses grep to search for the line containing 'MessageType = 0' and prints it along with the
#            next 500 lines after it (-A500 stands for "after context"). The idea here is to capture a significant
#            portion of the file following the specific line of interest, assuming that the
#            relevant data is within 500 lines.
#
# grep -v -e '//':
#         => This filters out any lines that contain //, removing comments from the output of the previous step.
#
# grep -v -e '^$':
#         => This removes empty lines from the output, where ^$ matches the start and end of a line with
#            nothing between, indicating an empty line.
#
# awk '/^\)$/ { exit; } /.*/ { printf " structs.%s: \"%s\",\n", $1, $1}':
#     This awk command processes each line of input with two patterns:
#         1. /^\)$/ { exit; }
#             => Stop processing at the end of a Go struct or a block of constants
#                It tells awk to exit (stop processing) when it encounters a line that only contains ')'.
#         2. /.*/ { printf " structs.%s: \"%s\",\n", $1, $1}'
#             => Matches every line (since .* matches any character except a newline, any number of times) and
#                uses printf to format each line in a specific way. For each line, it prints the first word ($1),
#                which is can be a constant or field name, in a specific format: structs.FieldName: "FieldName",.
#                This is creating a mapping of struct field names or constant names to their string representations,
#                prefixed with structs. indicating their package or namespace.